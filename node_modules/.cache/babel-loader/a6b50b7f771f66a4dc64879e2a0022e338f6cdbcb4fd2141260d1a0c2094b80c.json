{"ast":null,"code":"import { inRange, decoderError, encoderError, isASCIICodePoint, end_of_stream, finished, isASCIIByte, floor } from '../utils';\nimport index, { indexGB18030RangesCodePointFor, indexGB18030RangesPointerFor, indexCodePointFor, indexPointerFor } from '../indexes';\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nexport class GB18030Decoder {\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    this.gb18030_first = 0x00;\n    this.gb18030_second = 0x00, this.gb18030_third = 0x00;\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return The next code point(s) decoded, or null if not enough data exists in the input stream to decode a complete code point.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (bite === end_of_stream && this.gb18030_first === 0x00 && this.gb18030_second === 0x00 && this.gb18030_third === 0x00) {\n      return finished;\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (bite === end_of_stream && (this.gb18030_first !== 0x00 || this.gb18030_second !== 0x00 || this.gb18030_third !== 0x00)) {\n      this.gb18030_first = 0x00;\n      this.gb18030_second = 0x00;\n      this.gb18030_third = 0x00;\n      decoderError(this.fatal);\n    }\n    var code_point;\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (this.gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null;\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n      // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor((((this.gb18030_first - 0x81) * 10 + this.gb18030_second - 0x30) * 126 + this.gb18030_third - 0x81) * 10 + bite - 0x30);\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [this.gb18030_second, this.gb18030_third, bite];\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      this.gb18030_first = 0x00;\n      this.gb18030_second = 0x00;\n      this.gb18030_third = 0x00;\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer);\n        return decoderError(this.fatal);\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (this.gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        this.gb18030_third = bite;\n        return null;\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([this.gb18030_second, bite]);\n      this.gb18030_first = 0x00;\n      this.gb18030_second = 0x00;\n      return decoderError(this.fatal);\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (this.gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        this.gb18030_second = bite;\n        return null;\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = this.gb18030_first;\n      var pointer = null;\n      this.gb18030_first = 0x00;\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7F ? 0x40 : 0x41;\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - offset);\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(this.fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80) return 0x20AC;\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.gb18030_first = bite;\n      return null;\n    }\n\n    // 9. Return error.\n    return decoderError(this.fatal);\n  }\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @implements {Encoder}\n */\nexport class GB18030Encoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xE5E5) return encoderError(code_point);\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (this.gbk_flag && code_point === 0x20AC) return 0x80;\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'));\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n      // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190;\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x41;\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (this.gbk_flag) return encoderError(code_point);\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point);\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10);\n\n    // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n    pointer = pointer - byte1 * 10 * 126 * 10;\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126);\n\n    // 12. Set pointer to pointer − byte2 × 10 × 126.\n    pointer = pointer - byte2 * 10 * 126;\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10);\n\n    // 14. Let byte4 be pointer − byte3 × 10.\n    var byte4 = pointer - byte3 * 10;\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n  }\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let gbk_flag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    this.gbk_flag = gbk_flag;\n  }\n}","map":{"version":3,"names":["inRange","decoderError","encoderError","isASCIICodePoint","end_of_stream","finished","isASCIIByte","floor","index","indexGB18030RangesCodePointFor","indexGB18030RangesPointerFor","indexCodePointFor","indexPointerFor","GB18030Decoder","constructor","options","fatal","gb18030_first","gb18030_second","gb18030_third","handler","stream","bite","code_point","buffer","prepend","lead","pointer","offset","GB18030Encoder","gbk_flag","trail","byte1","byte2","byte3","byte4","arguments","length","undefined"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/gb18030.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, {\n  indexGB18030RangesCodePointFor, indexGB18030RangesPointerFor,\n  indexCodePointFor, indexPointerFor } from '../indexes'\n\n// 11.2 gb18030\n\n// 11.2.1 gb18030 decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nexport class GB18030Decoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    this.gb18030_first = 0x00\n    this.gb18030_second = 0x00,\n    this.gb18030_third = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return The next code point(s) decoded, or null if not enough data exists in the input stream to decode a complete code point.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and gb18030 first, gb18030\n    // second, and gb18030 third are 0x00, return finished.\n    if (bite === end_of_stream && this.gb18030_first === 0x00 &&\n        this.gb18030_second === 0x00 && this.gb18030_third === 0x00) {\n      return finished\n    }\n    // 2. If byte is end-of-stream, and gb18030 first, gb18030\n    // second, or gb18030 third is not 0x00, set gb18030 first,\n    // gb18030 second, and gb18030 third to 0x00, and return error.\n    if (bite === end_of_stream &&\n        (this.gb18030_first !== 0x00 || this.gb18030_second !== 0x00 ||\n          this.gb18030_third !== 0x00)) {\n      this.gb18030_first = 0x00\n      this.gb18030_second = 0x00\n      this.gb18030_third = 0x00\n      decoderError(this.fatal)\n    }\n    var code_point\n    // 3. If gb18030 third is not 0x00, run these substeps:\n    if (this.gb18030_third !== 0x00) {\n      // 1. Let code point be null.\n      code_point = null\n      // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n      // code point to the index gb18030 ranges code point for\n      // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n      // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n      if (inRange(bite, 0x30, 0x39)) {\n        code_point = indexGB18030RangesCodePointFor(\n          (((this.gb18030_first - 0x81) * 10 + this.gb18030_second - 0x30) * 126 +\n              this.gb18030_third - 0x81) * 10 + bite - 0x30)\n      }\n\n      // 3. Let buffer be a byte sequence consisting of gb18030\n      // second, gb18030 third, and byte, in order.\n      var buffer = [this.gb18030_second, this.gb18030_third, bite]\n\n      // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n      // 0x00.\n      this.gb18030_first = 0x00\n      this.gb18030_second = 0x00\n      this.gb18030_third = 0x00\n\n      // 5. If code point is null, prepend buffer to stream and\n      // return error.\n      if (code_point === null) {\n        stream.prepend(buffer)\n        return decoderError(this.fatal)\n      }\n\n      // 6. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If gb18030 second is not 0x00, run these substeps:\n    if (this.gb18030_second !== 0x00) {\n      // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 third to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        this.gb18030_third = bite\n        return null\n      }\n\n      // 2. Prepend gb18030 second followed by byte to stream, set\n      // gb18030 first and gb18030 second to 0x00, and return error.\n      stream.prepend([this.gb18030_second, bite])\n      this.gb18030_first = 0x00\n      this.gb18030_second = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 5. If gb18030 first is not 0x00, run these substeps:\n    if (this.gb18030_first !== 0x00) {\n      // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n      // gb18030 second to byte and return continue.\n      if (inRange(bite, 0x30, 0x39)) {\n        this.gb18030_second = bite\n        return null\n      }\n\n      // 2. Let lead be gb18030 first, let pointer be null, and set\n      // gb18030 first to 0x00.\n      var lead = this.gb18030_first\n      var pointer = null\n      this.gb18030_first = 0x00\n\n      // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n      // otherwise.\n      var offset = bite < 0x7F ? 0x40 : 0x41\n\n      // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n        pointer = (lead - 0x81) * 190 + (bite - offset)\n\n      // 5. Let code point be null if pointer is null and the index\n      // code point for pointer in index gb18030 otherwise.\n      code_point = pointer === null ? null :\n        indexCodePointFor(pointer, index('gb18030'))\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 7. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 8. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 7. If byte is 0x80, return code point U+20AC.\n    if (bite === 0x80)\n      return 0x20AC\n\n    // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // gb18030 first to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.gb18030_first = bite\n      return null\n    }\n\n    // 9. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 11.2.2 gb18030 encoder\n/**\n * @implements {Encoder}\n */\nexport class GB18030Encoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. If code point is U+E5E5, return error with code point.\n    if (code_point === 0xE5E5)\n      return encoderError(code_point)\n\n    // 4. If the gbk flag is set and code point is U+20AC, return\n    // byte 0x80.\n    if (this.gbk_flag && code_point === 0x20AC)\n      return 0x80\n\n    // 5. Let pointer be the index pointer for code point in index\n    // gb18030.\n    var pointer = indexPointerFor(code_point, index('gb18030'))\n\n    // 6. If pointer is not null, run these substeps:\n    if (pointer !== null) {\n    // 1. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81\n\n      // 2. Let trail be pointer % 190.\n      var trail = pointer % 190\n\n      // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x41\n\n      // 4. Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset]\n    }\n\n    // 7. If gbk flag is set, return error with code point.\n    if (this.gbk_flag)\n      return encoderError(code_point)\n\n    // 8. Set pointer to the index gb18030 ranges pointer for code\n    // point.\n    pointer = indexGB18030RangesPointerFor(code_point)\n\n    // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n    var byte1 = floor(pointer / 10 / 126 / 10)\n\n    // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n    pointer = pointer - byte1 * 10 * 126 * 10\n\n    // 11. Let byte2 be floor(pointer / 10 / 126).\n    var byte2 = floor(pointer / 10 / 126)\n\n    // 12. Set pointer to pointer − byte2 × 10 × 126.\n    pointer = pointer - byte2 * 10 * 126\n\n    // 13. Let byte3 be floor(pointer / 10).\n    var byte3 = floor(pointer / 10)\n\n    // 14. Let byte4 be pointer − byte3 × 10.\n    var byte4 = pointer - byte3 * 10\n\n    // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n    // 0x30, byte3 + 0x81, byte4 + 0x30.\n    return [byte1 + 0x81,\n      byte2 + 0x30,\n      byte3 + 0x81,\n      byte4 + 0x30]\n  }\n\n  constructor(options = {}, gbk_flag = false) {\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    this.gbk_flag = gbk_flag\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}