{"ast":null,"code":"//\n// Utilities\n//\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nexport function inRange(a, min, max) {\n  return min <= a && a <= max;\n}\nexport const floor = Math.floor;\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nexport function stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nexport function codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return The code point to insert on a decoding error.\n */\nexport function decoderError(fatal, opt_code_point) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nexport function encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.');\n}\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n */\nexport function convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  const byte1 = code_unit >> 8;\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  const byte2 = code_unit & 0x00FF;\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be) return [byte1, byte2];\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1];\n}\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nexport function isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7F;\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nexport const isASCIICodePoint = isASCIIByte;\n\n/**\n * End-of-stream is a special token that signifies no more tokens are in the stream.\n */\nexport const end_of_stream = -1;\nexport const finished = -1;","map":{"version":3,"names":["inRange","a","min","max","floor","Math","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","decoderError","fatal","opt_code_point","TypeError","encoderError","code_point","convertCodeUnitToBytes","code_unit","utf16be","byte1","byte2","isASCIIByte","isASCIICodePoint","end_of_stream","finished"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/utils.js"],"sourcesContent":["//\n// Utilities\n//\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nexport function inRange(a, min, max) {\n  return min <= a && a <= max\n}\n\nexport const floor = Math.floor\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nexport function stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string)\n\n  // 2. Let n be the length of S.\n  var n = s.length\n\n  // 3. Initialize i to 0.\n  var i = 0\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = []\n\n  // 5. While i < n:\n  while (i < n) {\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i)\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c)\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD)\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD)\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = s.charCodeAt(i + 1)\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b)\n\n          // 4. Set i to i+1.\n          i += 1\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD)\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1\n  }\n\n  // 6. Return U.\n  return u\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nexport function codePointsToString(code_points) {\n  var s = ''\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i]\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp)\n    } else {\n      cp -= 0x10000\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n        (cp & 0x3FF) + 0xDC00)\n    }\n  }\n  return s\n}\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return The code point to insert on a decoding error.\n */\nexport function decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error')\n  return opt_code_point || 0xFFFD\n}\n\n/**\n * @param {number} code_point The code point that could not be encoded.\n * @return {number} Always throws, no value is actually returned.\n */\nexport function encoderError(code_point) {\n  throw TypeError('The code point ' + code_point + ' could not be encoded.')\n}\n\n/**\n * @param {number} code_unit\n * @param {boolean} utf16be\n */\nexport function convertCodeUnitToBytes(code_unit, utf16be) {\n  // 1. Let byte1 be code unit >> 8.\n  const byte1 = code_unit >> 8\n\n  // 2. Let byte2 be code unit & 0x00FF.\n  const byte2 = code_unit & 0x00FF\n\n  // 3. Then return the bytes in order:\n  // utf-16be flag is set: byte1, then byte2.\n  if (utf16be)\n    return [byte1, byte2]\n  // utf-16be flag is unset: byte2, then byte1.\n  return [byte2, byte1]\n}\n\n\n//\n// 4. Terminology\n//\n\n/**\n * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n * @param {number} a The number to test.\n * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n */\nexport function isASCIIByte(a) {\n  return 0x00 <= a && a <= 0x7F\n}\n\n/**\n * An ASCII code point is a code point in the range U+0000 to\n * U+007F, inclusive.\n */\nexport const isASCIICodePoint = isASCIIByte\n\n/**\n * End-of-stream is a special token that signifies no more tokens are in the stream.\n */\nexport const end_of_stream = -1\n\nexport const finished = -1"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}