{"ast":null,"code":"'use strict';\n\nconst decodeText = require('./decodeText');\nconst RE_ENCODED = /%([a-fA-F0-9]{2})/g;\nfunction encodedReplacer(match, byte) {\n  return String.fromCharCode(parseInt(byte, 16));\n}\nfunction parseParams(str) {\n  const res = [];\n  let state = 'key';\n  let charset = '';\n  let inquote = false;\n  let escaping = false;\n  let p = 0;\n  let tmp = '';\n  for (var i = 0, len = str.length; i < len; ++i) {\n    // eslint-disable-line no-var\n    const char = str[i];\n    if (char === '\\\\' && inquote) {\n      if (escaping) {\n        escaping = false;\n      } else {\n        escaping = true;\n        continue;\n      }\n    } else if (char === '\"') {\n      if (!escaping) {\n        if (inquote) {\n          inquote = false;\n          state = 'key';\n        } else {\n          inquote = true;\n        }\n        continue;\n      } else {\n        escaping = false;\n      }\n    } else {\n      if (escaping && inquote) {\n        tmp += '\\\\';\n      }\n      escaping = false;\n      if ((state === 'charset' || state === 'lang') && char === \"'\") {\n        if (state === 'charset') {\n          state = 'lang';\n          charset = tmp.substring(1);\n        } else {\n          state = 'value';\n        }\n        tmp = '';\n        continue;\n      } else if (state === 'key' && (char === '*' || char === '=') && res.length) {\n        if (char === '*') {\n          state = 'charset';\n        } else {\n          state = 'value';\n        }\n        res[p] = [tmp, undefined];\n        tmp = '';\n        continue;\n      } else if (!inquote && char === ';') {\n        state = 'key';\n        if (charset) {\n          if (tmp.length) {\n            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), 'binary', charset);\n          }\n          charset = '';\n        } else if (tmp.length) {\n          tmp = decodeText(tmp, 'binary', 'utf8');\n        }\n        if (res[p] === undefined) {\n          res[p] = tmp;\n        } else {\n          res[p][1] = tmp;\n        }\n        tmp = '';\n        ++p;\n        continue;\n      } else if (!inquote && (char === ' ' || char === '\\t')) {\n        continue;\n      }\n    }\n    tmp += char;\n  }\n  if (charset && tmp.length) {\n    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), 'binary', charset);\n  } else if (tmp) {\n    tmp = decodeText(tmp, 'binary', 'utf8');\n  }\n  if (res[p] === undefined) {\n    if (tmp) {\n      res[p] = tmp;\n    }\n  } else {\n    res[p][1] = tmp;\n  }\n  return res;\n}\nmodule.exports = parseParams;","map":{"version":3,"names":["decodeText","require","RE_ENCODED","encodedReplacer","match","byte","String","fromCharCode","parseInt","parseParams","str","res","state","charset","inquote","escaping","p","tmp","i","len","length","char","substring","undefined","replace","module","exports"],"sources":["D:/Coding/React/taskmybusiness/node_modules/@fastify/busboy/lib/utils/parseParams.js"],"sourcesContent":["'use strict'\n\nconst decodeText = require('./decodeText')\n\nconst RE_ENCODED = /%([a-fA-F0-9]{2})/g\n\nfunction encodedReplacer (match, byte) {\n  return String.fromCharCode(parseInt(byte, 16))\n}\n\nfunction parseParams (str) {\n  const res = []\n  let state = 'key'\n  let charset = ''\n  let inquote = false\n  let escaping = false\n  let p = 0\n  let tmp = ''\n\n  for (var i = 0, len = str.length; i < len; ++i) { // eslint-disable-line no-var\n    const char = str[i]\n    if (char === '\\\\' && inquote) {\n      if (escaping) { escaping = false } else {\n        escaping = true\n        continue\n      }\n    } else if (char === '\"') {\n      if (!escaping) {\n        if (inquote) {\n          inquote = false\n          state = 'key'\n        } else { inquote = true }\n        continue\n      } else { escaping = false }\n    } else {\n      if (escaping && inquote) { tmp += '\\\\' }\n      escaping = false\n      if ((state === 'charset' || state === 'lang') && char === \"'\") {\n        if (state === 'charset') {\n          state = 'lang'\n          charset = tmp.substring(1)\n        } else { state = 'value' }\n        tmp = ''\n        continue\n      } else if (state === 'key' &&\n        (char === '*' || char === '=') &&\n        res.length) {\n        if (char === '*') { state = 'charset' } else { state = 'value' }\n        res[p] = [tmp, undefined]\n        tmp = ''\n        continue\n      } else if (!inquote && char === ';') {\n        state = 'key'\n        if (charset) {\n          if (tmp.length) {\n            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),\n              'binary',\n              charset)\n          }\n          charset = ''\n        } else if (tmp.length) {\n          tmp = decodeText(tmp, 'binary', 'utf8')\n        }\n        if (res[p] === undefined) { res[p] = tmp } else { res[p][1] = tmp }\n        tmp = ''\n        ++p\n        continue\n      } else if (!inquote && (char === ' ' || char === '\\t')) { continue }\n    }\n    tmp += char\n  }\n  if (charset && tmp.length) {\n    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),\n      'binary',\n      charset)\n  } else if (tmp) {\n    tmp = decodeText(tmp, 'binary', 'utf8')\n  }\n\n  if (res[p] === undefined) {\n    if (tmp) { res[p] = tmp }\n  } else { res[p][1] = tmp }\n\n  return res\n}\n\nmodule.exports = parseParams\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}