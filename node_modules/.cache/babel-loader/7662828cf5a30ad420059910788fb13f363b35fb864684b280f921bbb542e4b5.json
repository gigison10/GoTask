{"ast":null,"code":"\"use strict\";\n\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = exports.SignerExceptionMessages = void 0;\nconst crypto = require(\"crypto\");\nconst url = require(\"url\");\nconst storage_1 = require(\"./storage\");\nconst util_1 = require(\"./util\");\nvar SignerExceptionMessages;\n(function (SignerExceptionMessages) {\n  SignerExceptionMessages[\"ACCESSIBLE_DATE_INVALID\"] = \"The accessible at date provided was invalid.\";\n  SignerExceptionMessages[\"EXPIRATION_BEFORE_ACCESSIBLE_DATE\"] = \"An expiration date cannot be before accessible date.\";\n  SignerExceptionMessages[\"X_GOOG_CONTENT_SHA256\"] = \"The header X-Goog-Content-SHA256 must be a hexadecimal string.\";\n})(SignerExceptionMessages = exports.SignerExceptionMessages || (exports.SignerExceptionMessages = {}));\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 7 * 24 * 60 * 60;\n/**\n * @const {string}\n * @private\n */\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\nclass URLSigner {\n  constructor(authClient, bucket, file) {\n    this.bucket = bucket;\n    this.file = file;\n    this.authClient = authClient;\n  }\n  getSignedUrl(cfg) {\n    const expiresInSeconds = this.parseExpires(cfg.expires);\n    const method = cfg.method;\n    const accessibleAtInSeconds = this.parseAccessibleAt(cfg.accessibleAt);\n    if (expiresInSeconds < accessibleAtInSeconds) {\n      throw new Error(SignerExceptionMessages.EXPIRATION_BEFORE_ACCESSIBLE_DATE);\n    }\n    let customHost;\n    // Default style is `path`.\n    const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n    if (cfg.cname) {\n      customHost = cfg.cname;\n    } else if (isVirtualHostedStyle) {\n      customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n    }\n    const secondsToMilliseconds = 1000;\n    const config = Object.assign({}, cfg, {\n      method,\n      expiration: expiresInSeconds,\n      accessibleAt: new Date(secondsToMilliseconds * accessibleAtInSeconds),\n      bucket: this.bucket.name,\n      file: this.file ? (0, util_1.encodeURI)(this.file.name, false) : undefined\n    });\n    if (customHost) {\n      config.cname = customHost;\n    }\n    const version = cfg.version || DEFAULT_SIGNING_VERSION;\n    let promise;\n    if (version === 'v2') {\n      promise = this.getSignedUrlV2(config);\n    } else if (version === 'v4') {\n      promise = this.getSignedUrlV4(config);\n    } else {\n      throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n    }\n    return promise.then(query => {\n      query = Object.assign(query, cfg.queryParams);\n      const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n      signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      signedUrl.search = (0, util_1.qsStringify)(query);\n      return signedUrl.href;\n    });\n  }\n  getSignedUrlV2(config) {\n    const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n    const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n    const blobToSign = [config.method, config.contentMd5 || '', config.contentType || '', config.expiration, canonicalHeadersString + resourcePath].join('\\n');\n    const sign = async () => {\n      const authClient = this.authClient;\n      try {\n        const signature = await authClient.sign(blobToSign);\n        const credentials = await authClient.getCredentials();\n        return {\n          GoogleAccessId: credentials.client_email,\n          Expires: config.expiration,\n          Signature: signature\n        };\n      } catch (err) {\n        const error = err;\n        const signingErr = new SigningError(error.message);\n        signingErr.stack = error.stack;\n        throw signingErr;\n      }\n    };\n    return sign();\n  }\n  getSignedUrlV4(config) {\n    config.accessibleAt = config.accessibleAt ? config.accessibleAt : new Date();\n    const millisecondsToSeconds = 1.0 / 1000.0;\n    const expiresPeriodInSeconds = config.expiration - config.accessibleAt.valueOf() * millisecondsToSeconds;\n    // v4 limit expiration to be 7 days maximum\n    if (expiresPeriodInSeconds > SEVEN_DAYS) {\n      throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n    }\n    const extensionHeaders = Object.assign({}, config.extensionHeaders);\n    const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n    extensionHeaders.host = fqdn.host;\n    if (config.contentMd5) {\n      extensionHeaders['content-md5'] = config.contentMd5;\n    }\n    if (config.contentType) {\n      extensionHeaders['content-type'] = config.contentType;\n    }\n    let contentSha256;\n    const sha256Header = extensionHeaders['x-goog-content-sha256'];\n    if (sha256Header) {\n      if (typeof sha256Header !== 'string' || !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n        throw new Error(SignerExceptionMessages.X_GOOG_CONTENT_SHA256);\n      }\n      contentSha256 = sha256Header;\n    }\n    const signedHeaders = Object.keys(extensionHeaders).map(header => header.toLowerCase()).sort().join(';');\n    const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n    const datestamp = (0, util_1.formatAsUTCISO)(config.accessibleAt);\n    const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n    const sign = async () => {\n      const credentials = await this.authClient.getCredentials();\n      const credential = `${credentials.client_email}/${credentialScope}`;\n      const dateISO = (0, util_1.formatAsUTCISO)(config.accessibleAt ? config.accessibleAt : new Date(), true);\n      const queryParams = {\n        'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n        'X-Goog-Credential': credential,\n        'X-Goog-Date': dateISO,\n        'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n        'X-Goog-SignedHeaders': signedHeaders,\n        ...(config.queryParams || {})\n      };\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n      const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n      const hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');\n      const blobToSign = ['GOOG4-RSA-SHA256', dateISO, credentialScope, hash].join('\\n');\n      try {\n        const signature = await this.authClient.sign(blobToSign);\n        const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n        const signedQuery = Object.assign({}, queryParams, {\n          'X-Goog-Signature': signatureHex\n        });\n        return signedQuery;\n      } catch (err) {\n        const error = err;\n        const signingErr = new SigningError(error.message);\n        signingErr.stack = error.stack;\n        throw signingErr;\n      }\n    };\n    return sign();\n  }\n  /**\n   * Create canonical headers for signing v4 url.\n   *\n   * The canonical headers for v4-signing a request demands header names are\n   * first lowercased, followed by sorting the header names.\n   * Then, construct the canonical headers part of the request:\n   *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n   *  ..\n   *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n   *\n   * @param headers\n   * @private\n   */\n  getCanonicalHeaders(headers) {\n    // Sort headers by their lowercased names\n    const sortedHeaders = (0, util_1.objectEntries)(headers)\n    // Convert header names to lowercase\n    .map(_ref => {\n      let [headerName, value] = _ref;\n      return [headerName.toLowerCase(), value];\n    }).sort((a, b) => a[0].localeCompare(b[0]));\n    return sortedHeaders.filter(_ref2 => {\n      let [, value] = _ref2;\n      return value !== undefined;\n    }).map(_ref3 => {\n      let [headerName, value] = _ref3;\n      // - Convert Array (multi-valued header) into string, delimited by\n      //      ',' (no space).\n      // - Trim leading and trailing spaces.\n      // - Convert sequential (2+) spaces into a single space\n      const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n      return `${headerName}:${canonicalValue}\\n`;\n    }).join('');\n  }\n  getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n    return [method, path, query, headers, signedHeaders, contentSha256 || 'UNSIGNED-PAYLOAD'].join('\\n');\n  }\n  getCanonicalQueryParams(query) {\n    return (0, util_1.objectEntries)(query).map(_ref4 => {\n      let [key, value] = _ref4;\n      return [(0, util_1.encodeURI)(key, true), (0, util_1.encodeURI)(value, true)];\n    }).sort((a, b) => a[0] < b[0] ? -1 : 1).map(_ref5 => {\n      let [key, value] = _ref5;\n      return `${key}=${value}`;\n    }).join('&');\n  }\n  getResourcePath(cname, bucket, file) {\n    if (cname) {\n      return '/' + (file || '');\n    } else if (file) {\n      return `/${bucket}/${file}`;\n    } else {\n      return `/${bucket}`;\n    }\n  }\n  parseExpires(expires) {\n    let current = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();\n    const expiresInMSeconds = new Date(expires).valueOf();\n    if (isNaN(expiresInMSeconds)) {\n      throw new Error(storage_1.ExceptionMessages.EXPIRATION_DATE_INVALID);\n    }\n    if (expiresInMSeconds < current.valueOf()) {\n      throw new Error(storage_1.ExceptionMessages.EXPIRATION_DATE_PAST);\n    }\n    return Math.floor(expiresInMSeconds / 1000); // The API expects seconds.\n  }\n\n  parseAccessibleAt(accessibleAt) {\n    const accessibleAtInMSeconds = new Date(accessibleAt || new Date()).valueOf();\n    if (isNaN(accessibleAtInMSeconds)) {\n      throw new Error(SignerExceptionMessages.ACCESSIBLE_DATE_INVALID);\n    }\n    return Math.floor(accessibleAtInMSeconds / 1000); // The API expects seconds.\n  }\n}\n\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\nclass SigningError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'SigningError';\n  }\n}\nexports.SigningError = SigningError;","map":{"version":3,"names":["Object","defineProperty","exports","value","SigningError","URLSigner","PATH_STYLED_HOST","SignerExceptionMessages","crypto","require","url","storage_1","util_1","DEFAULT_SIGNING_VERSION","SEVEN_DAYS","constructor","authClient","bucket","file","getSignedUrl","cfg","expiresInSeconds","parseExpires","expires","method","accessibleAtInSeconds","parseAccessibleAt","accessibleAt","Error","EXPIRATION_BEFORE_ACCESSIBLE_DATE","customHost","isVirtualHostedStyle","virtualHostedStyle","cname","name","secondsToMilliseconds","config","assign","expiration","Date","encodeURI","undefined","version","promise","getSignedUrlV2","getSignedUrlV4","then","query","queryParams","signedUrl","URL","pathname","getResourcePath","search","qsStringify","href","canonicalHeadersString","getCanonicalHeaders","extensionHeaders","resourcePath","blobToSign","contentMd5","contentType","join","sign","signature","credentials","getCredentials","GoogleAccessId","client_email","Expires","Signature","err","error","signingErr","message","stack","millisecondsToSeconds","expiresPeriodInSeconds","valueOf","fqdn","host","contentSha256","sha256Header","test","X_GOOG_CONTENT_SHA256","signedHeaders","keys","map","header","toLowerCase","sort","extensionHeadersString","datestamp","formatAsUTCISO","credentialScope","credential","dateISO","toString","canonicalQueryParams","getCanonicalQueryParams","canonicalRequest","getCanonicalRequest","hash","createHash","update","digest","signatureHex","Buffer","from","signedQuery","headers","sortedHeaders","objectEntries","_ref","headerName","a","b","localeCompare","filter","_ref2","_ref3","canonicalValue","trim","replace","path","_ref4","key","_ref5","current","arguments","length","expiresInMSeconds","isNaN","ExceptionMessages","EXPIRATION_DATE_INVALID","EXPIRATION_DATE_PAST","Math","floor","accessibleAtInMSeconds","ACCESSIBLE_DATE_INVALID"],"sources":["D:/Coding/React/taskmybusiness/node_modules/@google-cloud/storage/build/src/signer.js"],"sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = exports.SignerExceptionMessages = void 0;\nconst crypto = require(\"crypto\");\nconst url = require(\"url\");\nconst storage_1 = require(\"./storage\");\nconst util_1 = require(\"./util\");\nvar SignerExceptionMessages;\n(function (SignerExceptionMessages) {\n    SignerExceptionMessages[\"ACCESSIBLE_DATE_INVALID\"] = \"The accessible at date provided was invalid.\";\n    SignerExceptionMessages[\"EXPIRATION_BEFORE_ACCESSIBLE_DATE\"] = \"An expiration date cannot be before accessible date.\";\n    SignerExceptionMessages[\"X_GOOG_CONTENT_SHA256\"] = \"The header X-Goog-Content-SHA256 must be a hexadecimal string.\";\n})(SignerExceptionMessages = exports.SignerExceptionMessages || (exports.SignerExceptionMessages = {}));\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 7 * 24 * 60 * 60;\n/**\n * @const {string}\n * @private\n */\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\nclass URLSigner {\n    constructor(authClient, bucket, file) {\n        this.bucket = bucket;\n        this.file = file;\n        this.authClient = authClient;\n    }\n    getSignedUrl(cfg) {\n        const expiresInSeconds = this.parseExpires(cfg.expires);\n        const method = cfg.method;\n        const accessibleAtInSeconds = this.parseAccessibleAt(cfg.accessibleAt);\n        if (expiresInSeconds < accessibleAtInSeconds) {\n            throw new Error(SignerExceptionMessages.EXPIRATION_BEFORE_ACCESSIBLE_DATE);\n        }\n        let customHost;\n        // Default style is `path`.\n        const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n        if (cfg.cname) {\n            customHost = cfg.cname;\n        }\n        else if (isVirtualHostedStyle) {\n            customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n        }\n        const secondsToMilliseconds = 1000;\n        const config = Object.assign({}, cfg, {\n            method,\n            expiration: expiresInSeconds,\n            accessibleAt: new Date(secondsToMilliseconds * accessibleAtInSeconds),\n            bucket: this.bucket.name,\n            file: this.file ? (0, util_1.encodeURI)(this.file.name, false) : undefined,\n        });\n        if (customHost) {\n            config.cname = customHost;\n        }\n        const version = cfg.version || DEFAULT_SIGNING_VERSION;\n        let promise;\n        if (version === 'v2') {\n            promise = this.getSignedUrlV2(config);\n        }\n        else if (version === 'v4') {\n            promise = this.getSignedUrlV4(config);\n        }\n        else {\n            throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n        }\n        return promise.then(query => {\n            query = Object.assign(query, cfg.queryParams);\n            const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n            signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signedUrl.search = (0, util_1.qsStringify)(query);\n            return signedUrl.href;\n        });\n    }\n    getSignedUrlV2(config) {\n        const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n        const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n        const blobToSign = [\n            config.method,\n            config.contentMd5 || '',\n            config.contentType || '',\n            config.expiration,\n            canonicalHeadersString + resourcePath,\n        ].join('\\n');\n        const sign = async () => {\n            const authClient = this.authClient;\n            try {\n                const signature = await authClient.sign(blobToSign);\n                const credentials = await authClient.getCredentials();\n                return {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature,\n                };\n            }\n            catch (err) {\n                const error = err;\n                const signingErr = new SigningError(error.message);\n                signingErr.stack = error.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    getSignedUrlV4(config) {\n        config.accessibleAt = config.accessibleAt\n            ? config.accessibleAt\n            : new Date();\n        const millisecondsToSeconds = 1.0 / 1000.0;\n        const expiresPeriodInSeconds = config.expiration - config.accessibleAt.valueOf() * millisecondsToSeconds;\n        // v4 limit expiration to be 7 days maximum\n        if (expiresPeriodInSeconds > SEVEN_DAYS) {\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n        }\n        const extensionHeaders = Object.assign({}, config.extensionHeaders);\n        const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        extensionHeaders.host = fqdn.host;\n        if (config.contentMd5) {\n            extensionHeaders['content-md5'] = config.contentMd5;\n        }\n        if (config.contentType) {\n            extensionHeaders['content-type'] = config.contentType;\n        }\n        let contentSha256;\n        const sha256Header = extensionHeaders['x-goog-content-sha256'];\n        if (sha256Header) {\n            if (typeof sha256Header !== 'string' ||\n                !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n                throw new Error(SignerExceptionMessages.X_GOOG_CONTENT_SHA256);\n            }\n            contentSha256 = sha256Header;\n        }\n        const signedHeaders = Object.keys(extensionHeaders)\n            .map(header => header.toLowerCase())\n            .sort()\n            .join(';');\n        const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n        const datestamp = (0, util_1.formatAsUTCISO)(config.accessibleAt);\n        const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n        const sign = async () => {\n            const credentials = await this.authClient.getCredentials();\n            const credential = `${credentials.client_email}/${credentialScope}`;\n            const dateISO = (0, util_1.formatAsUTCISO)(config.accessibleAt ? config.accessibleAt : new Date(), true);\n            const queryParams = {\n                'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n                'X-Goog-Credential': credential,\n                'X-Goog-Date': dateISO,\n                'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n                'X-Goog-SignedHeaders': signedHeaders,\n                ...(config.queryParams || {}),\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n            const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n            const hash = crypto\n                .createHash('sha256')\n                .update(canonicalRequest)\n                .digest('hex');\n            const blobToSign = [\n                'GOOG4-RSA-SHA256',\n                dateISO,\n                credentialScope,\n                hash,\n            ].join('\\n');\n            try {\n                const signature = await this.authClient.sign(blobToSign);\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                const signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex,\n                });\n                return signedQuery;\n            }\n            catch (err) {\n                const error = err;\n                const signingErr = new SigningError(error.message);\n                signingErr.stack = error.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n    getCanonicalHeaders(headers) {\n        // Sort headers by their lowercased names\n        const sortedHeaders = (0, util_1.objectEntries)(headers)\n            // Convert header names to lowercase\n            .map(([headerName, value]) => [\n            headerName.toLowerCase(),\n            value,\n        ])\n            .sort((a, b) => a[0].localeCompare(b[0]));\n        return sortedHeaders\n            .filter(([, value]) => value !== undefined)\n            .map(([headerName, value]) => {\n            // - Convert Array (multi-valued header) into string, delimited by\n            //      ',' (no space).\n            // - Trim leading and trailing spaces.\n            // - Convert sequential (2+) spaces into a single space\n            const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n            return `${headerName}:${canonicalValue}\\n`;\n        })\n            .join('');\n    }\n    getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n        return [\n            method,\n            path,\n            query,\n            headers,\n            signedHeaders,\n            contentSha256 || 'UNSIGNED-PAYLOAD',\n        ].join('\\n');\n    }\n    getCanonicalQueryParams(query) {\n        return (0, util_1.objectEntries)(query)\n            .map(([key, value]) => [(0, util_1.encodeURI)(key, true), (0, util_1.encodeURI)(value, true)])\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\n            .map(([key, value]) => `${key}=${value}`)\n            .join('&');\n    }\n    getResourcePath(cname, bucket, file) {\n        if (cname) {\n            return '/' + (file || '');\n        }\n        else if (file) {\n            return `/${bucket}/${file}`;\n        }\n        else {\n            return `/${bucket}`;\n        }\n    }\n    parseExpires(expires, current = new Date()) {\n        const expiresInMSeconds = new Date(expires).valueOf();\n        if (isNaN(expiresInMSeconds)) {\n            throw new Error(storage_1.ExceptionMessages.EXPIRATION_DATE_INVALID);\n        }\n        if (expiresInMSeconds < current.valueOf()) {\n            throw new Error(storage_1.ExceptionMessages.EXPIRATION_DATE_PAST);\n        }\n        return Math.floor(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n    parseAccessibleAt(accessibleAt) {\n        const accessibleAtInMSeconds = new Date(accessibleAt || new Date()).valueOf();\n        if (isNaN(accessibleAtInMSeconds)) {\n            throw new Error(SignerExceptionMessages.ACCESSIBLE_DATE_INVALID);\n        }\n        return Math.floor(accessibleAtInMSeconds / 1000); // The API expects seconds.\n    }\n}\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\nclass SigningError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SigningError';\n    }\n}\nexports.SigningError = SigningError;\n//# sourceMappingURL=signer.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}