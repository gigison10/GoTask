{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.appCheckErrorFromCryptoSignerError = exports.AppCheckTokenGenerator = void 0;\nconst validator = require(\"../utils/validator\");\nconst utils_1 = require(\"../utils\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\nconst app_check_api_client_internal_1 = require(\"./app-check-api-client-internal\");\nconst ONE_MINUTE_IN_SECONDS = 60;\nconst ONE_MINUTE_IN_MILLIS = ONE_MINUTE_IN_SECONDS * 1000;\nconst ONE_DAY_IN_MILLIS = 24 * 60 * 60 * 1000;\n// Audience to use for Firebase App Check Custom tokens\nconst FIREBASE_APP_CHECK_AUDIENCE = 'https://firebaseappcheck.googleapis.com/google.firebase.appcheck.v1.TokenExchangeService';\n/**\n * Class for generating Firebase App Check tokens.\n *\n * @internal\n */\nclass AppCheckTokenGenerator {\n  /**\n   * The AppCheckTokenGenerator class constructor.\n   *\n   * @param signer - The CryptoSigner instance for this token generator.\n   * @constructor\n   */\n  constructor(signer) {\n    if (!validator.isNonNullObject(signer)) {\n      throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'INTERNAL ASSERT: Must provide a CryptoSigner to use AppCheckTokenGenerator.');\n    }\n    this.signer = signer;\n  }\n  /**\n   * Creates a new custom token that can be exchanged to an App Check token.\n   *\n   * @param appId - The Application ID to use for the generated token.\n   *\n   * @returns A Promise fulfilled with a custom token signed with a service account key\n   * that can be exchanged to an App Check token.\n   */\n  createCustomToken(appId, options) {\n    if (!validator.isNonEmptyString(appId)) {\n      throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', '`appId` must be a non-empty string.');\n    }\n    let customOptions = {};\n    if (typeof options !== 'undefined') {\n      customOptions = this.validateTokenOptions(options);\n    }\n    return this.signer.getAccountId().then(account => {\n      const header = {\n        alg: this.signer.algorithm,\n        typ: 'JWT'\n      };\n      const iat = Math.floor(Date.now() / 1000);\n      const body = {\n        iss: account,\n        sub: account,\n        app_id: appId,\n        aud: FIREBASE_APP_CHECK_AUDIENCE,\n        exp: iat + ONE_MINUTE_IN_SECONDS * 5,\n        iat,\n        ...customOptions\n      };\n      const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;\n      return this.signer.sign(Buffer.from(token)).then(signature => {\n        return `${token}.${this.encodeSegment(signature)}`;\n      });\n    }).catch(err => {\n      throw appCheckErrorFromCryptoSignerError(err);\n    });\n  }\n  encodeSegment(segment) {\n    const buffer = segment instanceof Buffer ? segment : Buffer.from(JSON.stringify(segment));\n    return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, '');\n  }\n  /**\n   * Checks if a given `AppCheckTokenOptions` object is valid. If successful, returns an object with\n   * custom properties.\n   *\n   * @param options - An options object to be validated.\n   * @returns A custom object with ttl converted to protobuf Duration string format.\n   */\n  validateTokenOptions(options) {\n    if (!validator.isNonNullObject(options)) {\n      throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'AppCheckTokenOptions must be a non-null object.');\n    }\n    if (typeof options.ttlMillis !== 'undefined') {\n      if (!validator.isNumber(options.ttlMillis)) {\n        throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds.');\n      }\n      // ttlMillis must be between 30 minutes and 7 days (inclusive)\n      if (options.ttlMillis < ONE_MINUTE_IN_MILLIS * 30 || options.ttlMillis > ONE_DAY_IN_MILLIS * 7) {\n        throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds between 30 minutes and 7 days (inclusive).');\n      }\n      return {\n        ttl: (0, utils_1.transformMillisecondsToSecondsString)(options.ttlMillis)\n      };\n    }\n    return {};\n  }\n}\nexports.AppCheckTokenGenerator = AppCheckTokenGenerator;\n/**\n * Creates a new `FirebaseAppCheckError` by extracting the error code, message and other relevant\n * details from a `CryptoSignerError`.\n *\n * @param err - The Error to convert into a `FirebaseAppCheckError` error\n * @returns A Firebase App Check error that can be returned to the user.\n */\nfunction appCheckErrorFromCryptoSignerError(err) {\n  if (!(err instanceof crypto_signer_1.CryptoSignerError)) {\n    return err;\n  }\n  if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {\n    const httpError = err.cause;\n    const errorResponse = httpError.response.data;\n    if (errorResponse?.error) {\n      const status = errorResponse.error.status;\n      const description = errorResponse.error.message || JSON.stringify(httpError.response);\n      let code = 'unknown-error';\n      if (status && status in app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING) {\n        code = app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING[status];\n      }\n      return new app_check_api_client_internal_1.FirebaseAppCheckError(code, `Error returned from server while signing a custom token: ${description}`);\n    }\n    return new app_check_api_client_internal_1.FirebaseAppCheckError('internal-error', 'Error returned from server: ' + JSON.stringify(errorResponse) + '.');\n  }\n  return new app_check_api_client_internal_1.FirebaseAppCheckError(mapToAppCheckErrorCode(err.code), err.message);\n}\nexports.appCheckErrorFromCryptoSignerError = appCheckErrorFromCryptoSignerError;\nfunction mapToAppCheckErrorCode(code) {\n  switch (code) {\n    case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:\n      return 'invalid-credential';\n    case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:\n      return 'invalid-argument';\n    default:\n      return 'internal-error';\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","appCheckErrorFromCryptoSignerError","AppCheckTokenGenerator","validator","require","utils_1","crypto_signer_1","app_check_api_client_internal_1","ONE_MINUTE_IN_SECONDS","ONE_MINUTE_IN_MILLIS","ONE_DAY_IN_MILLIS","FIREBASE_APP_CHECK_AUDIENCE","constructor","signer","isNonNullObject","FirebaseAppCheckError","createCustomToken","appId","options","isNonEmptyString","customOptions","validateTokenOptions","getAccountId","then","account","header","alg","algorithm","typ","iat","Math","floor","Date","now","body","iss","sub","app_id","aud","exp","token","encodeSegment","sign","Buffer","from","signature","catch","err","segment","buffer","JSON","stringify","toWebSafeBase64","replace","ttlMillis","isNumber","ttl","transformMillisecondsToSecondsString","CryptoSignerError","code","CryptoSignerErrorCode","SERVER_ERROR","cause","httpError","errorResponse","response","data","error","status","description","message","APP_CHECK_ERROR_CODE_MAPPING","mapToAppCheckErrorCode","INVALID_CREDENTIAL","INVALID_ARGUMENT"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/app-check/token-generator.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.appCheckErrorFromCryptoSignerError = exports.AppCheckTokenGenerator = void 0;\nconst validator = require(\"../utils/validator\");\nconst utils_1 = require(\"../utils\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\nconst app_check_api_client_internal_1 = require(\"./app-check-api-client-internal\");\nconst ONE_MINUTE_IN_SECONDS = 60;\nconst ONE_MINUTE_IN_MILLIS = ONE_MINUTE_IN_SECONDS * 1000;\nconst ONE_DAY_IN_MILLIS = 24 * 60 * 60 * 1000;\n// Audience to use for Firebase App Check Custom tokens\nconst FIREBASE_APP_CHECK_AUDIENCE = 'https://firebaseappcheck.googleapis.com/google.firebase.appcheck.v1.TokenExchangeService';\n/**\n * Class for generating Firebase App Check tokens.\n *\n * @internal\n */\nclass AppCheckTokenGenerator {\n    /**\n     * The AppCheckTokenGenerator class constructor.\n     *\n     * @param signer - The CryptoSigner instance for this token generator.\n     * @constructor\n     */\n    constructor(signer) {\n        if (!validator.isNonNullObject(signer)) {\n            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'INTERNAL ASSERT: Must provide a CryptoSigner to use AppCheckTokenGenerator.');\n        }\n        this.signer = signer;\n    }\n    /**\n     * Creates a new custom token that can be exchanged to an App Check token.\n     *\n     * @param appId - The Application ID to use for the generated token.\n     *\n     * @returns A Promise fulfilled with a custom token signed with a service account key\n     * that can be exchanged to an App Check token.\n     */\n    createCustomToken(appId, options) {\n        if (!validator.isNonEmptyString(appId)) {\n            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', '`appId` must be a non-empty string.');\n        }\n        let customOptions = {};\n        if (typeof options !== 'undefined') {\n            customOptions = this.validateTokenOptions(options);\n        }\n        return this.signer.getAccountId().then((account) => {\n            const header = {\n                alg: this.signer.algorithm,\n                typ: 'JWT',\n            };\n            const iat = Math.floor(Date.now() / 1000);\n            const body = {\n                iss: account,\n                sub: account,\n                app_id: appId,\n                aud: FIREBASE_APP_CHECK_AUDIENCE,\n                exp: iat + (ONE_MINUTE_IN_SECONDS * 5),\n                iat,\n                ...customOptions,\n            };\n            const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;\n            return this.signer.sign(Buffer.from(token))\n                .then((signature) => {\n                return `${token}.${this.encodeSegment(signature)}`;\n            });\n        }).catch((err) => {\n            throw appCheckErrorFromCryptoSignerError(err);\n        });\n    }\n    encodeSegment(segment) {\n        const buffer = (segment instanceof Buffer) ? segment : Buffer.from(JSON.stringify(segment));\n        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, '');\n    }\n    /**\n     * Checks if a given `AppCheckTokenOptions` object is valid. If successful, returns an object with\n     * custom properties.\n     *\n     * @param options - An options object to be validated.\n     * @returns A custom object with ttl converted to protobuf Duration string format.\n     */\n    validateTokenOptions(options) {\n        if (!validator.isNonNullObject(options)) {\n            throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'AppCheckTokenOptions must be a non-null object.');\n        }\n        if (typeof options.ttlMillis !== 'undefined') {\n            if (!validator.isNumber(options.ttlMillis)) {\n                throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds.');\n            }\n            // ttlMillis must be between 30 minutes and 7 days (inclusive)\n            if (options.ttlMillis < (ONE_MINUTE_IN_MILLIS * 30) || options.ttlMillis > (ONE_DAY_IN_MILLIS * 7)) {\n                throw new app_check_api_client_internal_1.FirebaseAppCheckError('invalid-argument', 'ttlMillis must be a duration in milliseconds between 30 minutes and 7 days (inclusive).');\n            }\n            return { ttl: (0, utils_1.transformMillisecondsToSecondsString)(options.ttlMillis) };\n        }\n        return {};\n    }\n}\nexports.AppCheckTokenGenerator = AppCheckTokenGenerator;\n/**\n * Creates a new `FirebaseAppCheckError` by extracting the error code, message and other relevant\n * details from a `CryptoSignerError`.\n *\n * @param err - The Error to convert into a `FirebaseAppCheckError` error\n * @returns A Firebase App Check error that can be returned to the user.\n */\nfunction appCheckErrorFromCryptoSignerError(err) {\n    if (!(err instanceof crypto_signer_1.CryptoSignerError)) {\n        return err;\n    }\n    if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {\n        const httpError = err.cause;\n        const errorResponse = httpError.response.data;\n        if (errorResponse?.error) {\n            const status = errorResponse.error.status;\n            const description = errorResponse.error.message || JSON.stringify(httpError.response);\n            let code = 'unknown-error';\n            if (status && status in app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING) {\n                code = app_check_api_client_internal_1.APP_CHECK_ERROR_CODE_MAPPING[status];\n            }\n            return new app_check_api_client_internal_1.FirebaseAppCheckError(code, `Error returned from server while signing a custom token: ${description}`);\n        }\n        return new app_check_api_client_internal_1.FirebaseAppCheckError('internal-error', 'Error returned from server: ' + JSON.stringify(errorResponse) + '.');\n    }\n    return new app_check_api_client_internal_1.FirebaseAppCheckError(mapToAppCheckErrorCode(err.code), err.message);\n}\nexports.appCheckErrorFromCryptoSignerError = appCheckErrorFromCryptoSignerError;\nfunction mapToAppCheckErrorCode(code) {\n    switch (code) {\n        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:\n            return 'invalid-credential';\n        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:\n            return 'invalid-argument';\n        default:\n            return 'internal-error';\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}