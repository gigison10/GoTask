{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2022 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransferManager = void 0;\nconst pLimit = require(\"p-limit\");\nconst path = require(\"path\");\nconst extend = require(\"extend\");\nconst fs_1 = require(\"fs\");\nconst crc32c_1 = require(\"./crc32c\");\n/**\n * Default number of concurrently executing promises to use when calling uploadManyFiles.\n * @experimental\n */\nconst DEFAULT_PARALLEL_UPLOAD_LIMIT = 2;\n/**\n * Default number of concurrently executing promises to use when calling downloadManyFiles.\n * @experimental\n */\nconst DEFAULT_PARALLEL_DOWNLOAD_LIMIT = 2;\n/**\n * Default number of concurrently executing promises to use when calling downloadFileInChunks.\n * @experimental\n */\nconst DEFAULT_PARALLEL_CHUNKED_DOWNLOAD_LIMIT = 2;\n/**\n * The minimum size threshold in bytes at which to apply a chunked download strategy when calling downloadFileInChunks.\n * @experimental\n */\nconst DOWNLOAD_IN_CHUNKS_FILE_SIZE_THRESHOLD = 32 * 1024 * 1024;\n/**\n * The chunk size in bytes to use when calling downloadFileInChunks.\n * @experimental\n */\nconst DOWNLOAD_IN_CHUNKS_DEFAULT_CHUNK_SIZE = 10 * 1024 * 1024;\nconst EMPTY_REGEX = '(?:)';\n/**\n * Create a TransferManager object to perform parallel transfer operations on a Cloud Storage bucket.\n *\n * @class\n * @hideconstructor\n *\n * @param {Bucket} bucket A {@link Bucket} instance\n * @experimental\n */\nclass TransferManager {\n  constructor(bucket) {\n    this.bucket = bucket;\n  }\n  /**\n   * @typedef {object} UploadManyFilesOptions\n   * @property {number} [concurrencyLimit] The number of concurrently executing promises\n   * to use when uploading the files.\n   * @property {boolean} [skipIfExists] Do not upload the file if it already exists in\n   * the bucket. This will set the precondition ifGenerationMatch = 0.\n   * @property {string} [prefix] A prefix to append to all of the uploaded files.\n   * @property {object} [passthroughOptions] {@link UploadOptions} Options to be passed through\n   * to each individual upload operation.\n   * @experimental\n   */\n  /**\n   * Upload multiple files in parallel to the bucket. This is a convenience method\n   * that utilizes {@link Bucket#upload} to perform the upload.\n   *\n   * @param {array | string} [filePathsOrDirectory] An array of fully qualified paths to the files or a directory name.\n   * If a directory name is provided, the directory will be recursively walked and all files will be added to the upload list.\n   * to be uploaded to the bucket\n   * @param {UploadManyFilesOptions} [options] Configuration options.\n   * @returns {Promise<UploadResponse[]>}\n   *\n   * @example\n   * ```\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const bucket = storage.bucket('my-bucket');\n   * const transferManager = new TransferManager(bucket);\n   *\n   * //-\n   * // Upload multiple files in parallel.\n   * //-\n   * const response = await transferManager.uploadManyFiles(['/local/path/file1.txt, 'local/path/file2.txt']);\n   * // Your bucket now contains:\n   * // - \"local/path/file1.txt\" (with the contents of '/local/path/file1.txt')\n   * // - \"local/path/file2.txt\" (with the contents of '/local/path/file2.txt')\n   * const response = await transferManager.uploadManyFiles('/local/directory');\n   * // Your bucket will now contain all files contained in '/local/directory' maintaining the subdirectory structure.\n   * ```\n   * @experimental\n   */\n  async uploadManyFiles(filePathsOrDirectory) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    if (options.skipIfExists && ((_a = options.passthroughOptions) === null || _a === void 0 ? void 0 : _a.preconditionOpts)) {\n      options.passthroughOptions.preconditionOpts.ifGenerationMatch = 0;\n    } else if (options.skipIfExists && options.passthroughOptions === undefined) {\n      options.passthroughOptions = {\n        preconditionOpts: {\n          ifGenerationMatch: 0\n        }\n      };\n    }\n    const limit = pLimit(options.concurrencyLimit || DEFAULT_PARALLEL_UPLOAD_LIMIT);\n    const promises = [];\n    let allPaths = [];\n    if (!Array.isArray(filePathsOrDirectory)) {\n      for await (const curPath of this.getPathsFromDirectory(filePathsOrDirectory)) {\n        allPaths.push(curPath);\n      }\n    } else {\n      allPaths = filePathsOrDirectory;\n    }\n    for (const filePath of allPaths) {\n      const stat = await fs_1.promises.lstat(filePath);\n      if (stat.isDirectory()) {\n        continue;\n      }\n      const passThroughOptionsCopy = extend(true, {}, options.passthroughOptions);\n      passThroughOptionsCopy.destination = filePath;\n      if (options.prefix) {\n        passThroughOptionsCopy.destination = path.join(options.prefix, passThroughOptionsCopy.destination);\n      }\n      promises.push(limit(() => this.bucket.upload(filePath, passThroughOptionsCopy)));\n    }\n    return Promise.all(promises);\n  }\n  /**\n   * @typedef {object} DownloadManyFilesOptions\n   * @property {number} [concurrencyLimit] The number of concurrently executing promises\n   * to use when downloading the files.\n   * @property {string} [prefix] A prefix to append to all of the downloaded files.\n   * @property {string} [stripPrefix] A prefix to remove from all of the downloaded files.\n   * @property {object} [passthroughOptions] {@link DownloadOptions} Options to be passed through\n   * to each individual download operation.\n   * @experimental\n   */\n  /**\n   * Download multiple files in parallel to the local filesystem. This is a convenience method\n   * that utilizes {@link File#download} to perform the download.\n   *\n   * @param {array | string} [filesOrFolder] An array of file name strings or file objects to be downloaded. If\n   * a string is provided this will be treated as a GCS prefix and all files with that prefix will be downloaded.\n   * @param {DownloadManyFilesOptions} [options] Configuration options.\n   * @returns {Promise<DownloadResponse[]>}\n   *\n   * @example\n   * ```\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const bucket = storage.bucket('my-bucket');\n   * const transferManager = new TransferManager(bucket);\n   *\n   * //-\n   * // Download multiple files in parallel.\n   * //-\n   * const response = await transferManager.downloadManyFiles(['file1.txt', 'file2.txt']);\n   * // The following files have been downloaded:\n   * // - \"file1.txt\" (with the contents from my-bucket.file1.txt)\n   * // - \"file2.txt\" (with the contents from my-bucket.file2.txt)\n   * const response = await transferManager.downloadManyFiles([bucket.File('file1.txt'), bucket.File('file2.txt')]);\n   * // The following files have been downloaded:\n   * // - \"file1.txt\" (with the contents from my-bucket.file1.txt)\n   * // - \"file2.txt\" (with the contents from my-bucket.file2.txt)\n   * const response = await transferManager.downloadManyFiles('test-folder');\n   * // All files with GCS prefix of 'test-folder' have been downloaded.\n   * ```\n   * @experimental\n   */\n  async downloadManyFiles(filesOrFolder) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const limit = pLimit(options.concurrencyLimit || DEFAULT_PARALLEL_DOWNLOAD_LIMIT);\n    const promises = [];\n    let files = [];\n    if (!Array.isArray(filesOrFolder)) {\n      const directoryFiles = await this.bucket.getFiles({\n        prefix: filesOrFolder\n      });\n      files = directoryFiles[0];\n    } else {\n      files = filesOrFolder.map(curFile => {\n        if (typeof curFile === 'string') {\n          return this.bucket.file(curFile);\n        }\n        return curFile;\n      });\n    }\n    const stripRegexString = options.stripPrefix ? `^${options.stripPrefix}` : EMPTY_REGEX;\n    const regex = new RegExp(stripRegexString, 'g');\n    for (const file of files) {\n      const passThroughOptionsCopy = extend(true, {}, options.passthroughOptions);\n      if (options.prefix) {\n        passThroughOptionsCopy.destination = path.join(options.prefix || '', passThroughOptionsCopy.destination || '', file.name);\n      }\n      if (options.stripPrefix) {\n        passThroughOptionsCopy.destination = file.name.replace(regex, '');\n      }\n      promises.push(limit(() => file.download(passThroughOptionsCopy)));\n    }\n    return Promise.all(promises);\n  }\n  /**\n   * @typedef {object} DownloadFileInChunksOptions\n   * @property {number} [concurrencyLimit] The number of concurrently executing promises\n   * to use when downloading the file.\n   * @property {number} [chunkSizeBytes] The size in bytes of each chunk to be downloaded.\n   * @property {string | boolean} [validation] Whether or not to perform a CRC32C validation check when download is complete.\n   * @experimental\n   */\n  /**\n   * Download a large file in chunks utilizing parallel download operations. This is a convenience method\n   * that utilizes {@link File#download} to perform the download.\n   *\n   * @param {object} [file | string] {@link File} to download.\n   * @param {DownloadFileInChunksOptions} [options] Configuration options.\n   * @returns {Promise<DownloadResponse>}\n   *\n   * @example\n   * ```\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const bucket = storage.bucket('my-bucket');\n   * const transferManager = new TransferManager(bucket);\n   *\n   * //-\n   * // Download a large file in chunks utilizing parallel operations.\n   * //-\n   * const response = await transferManager.downloadLargeFile(bucket.file('large-file.txt');\n   * // Your local directory now contains:\n   * // - \"large-file.txt\" (with the contents from my-bucket.large-file.txt)\n   * ```\n   * @experimental\n   */\n  async downloadFileInChunks(fileOrName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let chunkSize = options.chunkSizeBytes || DOWNLOAD_IN_CHUNKS_DEFAULT_CHUNK_SIZE;\n    let limit = pLimit(options.concurrencyLimit || DEFAULT_PARALLEL_CHUNKED_DOWNLOAD_LIMIT);\n    const promises = [];\n    const file = typeof fileOrName === 'string' ? this.bucket.file(fileOrName) : fileOrName;\n    const fileInfo = await file.get();\n    const size = parseInt(fileInfo[0].metadata.size);\n    // If the file size does not meet the threshold download it as a single chunk.\n    if (size < DOWNLOAD_IN_CHUNKS_FILE_SIZE_THRESHOLD) {\n      limit = pLimit(1);\n      chunkSize = size;\n    }\n    let start = 0;\n    const filePath = options.destination || path.basename(file.name);\n    const fileToWrite = await fs_1.promises.open(filePath, 'w+');\n    while (start < size) {\n      const chunkStart = start;\n      let chunkEnd = start + chunkSize - 1;\n      chunkEnd = chunkEnd > size ? size : chunkEnd;\n      promises.push(limit(() => file.download({\n        start: chunkStart,\n        end: chunkEnd\n      }).then(resp => {\n        return fileToWrite.write(resp[0], 0, resp[0].length, chunkStart);\n      })));\n      start += chunkSize;\n    }\n    return new Promise((resolve, reject) => {\n      let results;\n      Promise.all(promises).then(data => {\n        results = data.map(result => result.buffer);\n        if (options.validation === 'crc32c') {\n          return crc32c_1.CRC32C.fromFile(filePath);\n        }\n        return;\n      }).then(() => {\n        resolve(results);\n      }).catch(e => {\n        reject(e);\n      }).finally(() => {\n        fileToWrite.close();\n      });\n    });\n  }\n  async *getPathsFromDirectory(directory) {\n    const filesAndSubdirectories = await fs_1.promises.readdir(directory, {\n      withFileTypes: true\n    });\n    for (const curFileOrDirectory of filesAndSubdirectories) {\n      const fullPath = path.join(directory, curFileOrDirectory.name);\n      curFileOrDirectory.isDirectory() ? yield* this.getPathsFromDirectory(fullPath) : yield fullPath;\n    }\n  }\n}\nexports.TransferManager = TransferManager;","map":{"version":3,"names":["Object","defineProperty","exports","value","TransferManager","pLimit","require","path","extend","fs_1","crc32c_1","DEFAULT_PARALLEL_UPLOAD_LIMIT","DEFAULT_PARALLEL_DOWNLOAD_LIMIT","DEFAULT_PARALLEL_CHUNKED_DOWNLOAD_LIMIT","DOWNLOAD_IN_CHUNKS_FILE_SIZE_THRESHOLD","DOWNLOAD_IN_CHUNKS_DEFAULT_CHUNK_SIZE","EMPTY_REGEX","constructor","bucket","uploadManyFiles","filePathsOrDirectory","options","arguments","length","undefined","_a","skipIfExists","passthroughOptions","preconditionOpts","ifGenerationMatch","limit","concurrencyLimit","promises","allPaths","Array","isArray","curPath","getPathsFromDirectory","push","filePath","stat","lstat","isDirectory","passThroughOptionsCopy","destination","prefix","join","upload","Promise","all","downloadManyFiles","filesOrFolder","files","directoryFiles","getFiles","map","curFile","file","stripRegexString","stripPrefix","regex","RegExp","name","replace","download","downloadFileInChunks","fileOrName","chunkSize","chunkSizeBytes","fileInfo","get","size","parseInt","metadata","start","basename","fileToWrite","open","chunkStart","chunkEnd","end","then","resp","write","resolve","reject","results","data","result","buffer","validation","CRC32C","fromFile","catch","e","finally","close","directory","filesAndSubdirectories","readdir","withFileTypes","curFileOrDirectory","fullPath"],"sources":["D:/Coding/React/taskmybusiness/node_modules/@google-cloud/storage/build/src/transfer-manager.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2022 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransferManager = void 0;\nconst pLimit = require(\"p-limit\");\nconst path = require(\"path\");\nconst extend = require(\"extend\");\nconst fs_1 = require(\"fs\");\nconst crc32c_1 = require(\"./crc32c\");\n/**\n * Default number of concurrently executing promises to use when calling uploadManyFiles.\n * @experimental\n */\nconst DEFAULT_PARALLEL_UPLOAD_LIMIT = 2;\n/**\n * Default number of concurrently executing promises to use when calling downloadManyFiles.\n * @experimental\n */\nconst DEFAULT_PARALLEL_DOWNLOAD_LIMIT = 2;\n/**\n * Default number of concurrently executing promises to use when calling downloadFileInChunks.\n * @experimental\n */\nconst DEFAULT_PARALLEL_CHUNKED_DOWNLOAD_LIMIT = 2;\n/**\n * The minimum size threshold in bytes at which to apply a chunked download strategy when calling downloadFileInChunks.\n * @experimental\n */\nconst DOWNLOAD_IN_CHUNKS_FILE_SIZE_THRESHOLD = 32 * 1024 * 1024;\n/**\n * The chunk size in bytes to use when calling downloadFileInChunks.\n * @experimental\n */\nconst DOWNLOAD_IN_CHUNKS_DEFAULT_CHUNK_SIZE = 10 * 1024 * 1024;\nconst EMPTY_REGEX = '(?:)';\n/**\n * Create a TransferManager object to perform parallel transfer operations on a Cloud Storage bucket.\n *\n * @class\n * @hideconstructor\n *\n * @param {Bucket} bucket A {@link Bucket} instance\n * @experimental\n */\nclass TransferManager {\n    constructor(bucket) {\n        this.bucket = bucket;\n    }\n    /**\n     * @typedef {object} UploadManyFilesOptions\n     * @property {number} [concurrencyLimit] The number of concurrently executing promises\n     * to use when uploading the files.\n     * @property {boolean} [skipIfExists] Do not upload the file if it already exists in\n     * the bucket. This will set the precondition ifGenerationMatch = 0.\n     * @property {string} [prefix] A prefix to append to all of the uploaded files.\n     * @property {object} [passthroughOptions] {@link UploadOptions} Options to be passed through\n     * to each individual upload operation.\n     * @experimental\n     */\n    /**\n     * Upload multiple files in parallel to the bucket. This is a convenience method\n     * that utilizes {@link Bucket#upload} to perform the upload.\n     *\n     * @param {array | string} [filePathsOrDirectory] An array of fully qualified paths to the files or a directory name.\n     * If a directory name is provided, the directory will be recursively walked and all files will be added to the upload list.\n     * to be uploaded to the bucket\n     * @param {UploadManyFilesOptions} [options] Configuration options.\n     * @returns {Promise<UploadResponse[]>}\n     *\n     * @example\n     * ```\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     * const transferManager = new TransferManager(bucket);\n     *\n     * //-\n     * // Upload multiple files in parallel.\n     * //-\n     * const response = await transferManager.uploadManyFiles(['/local/path/file1.txt, 'local/path/file2.txt']);\n     * // Your bucket now contains:\n     * // - \"local/path/file1.txt\" (with the contents of '/local/path/file1.txt')\n     * // - \"local/path/file2.txt\" (with the contents of '/local/path/file2.txt')\n     * const response = await transferManager.uploadManyFiles('/local/directory');\n     * // Your bucket will now contain all files contained in '/local/directory' maintaining the subdirectory structure.\n     * ```\n     * @experimental\n     */\n    async uploadManyFiles(filePathsOrDirectory, options = {}) {\n        var _a;\n        if (options.skipIfExists && ((_a = options.passthroughOptions) === null || _a === void 0 ? void 0 : _a.preconditionOpts)) {\n            options.passthroughOptions.preconditionOpts.ifGenerationMatch = 0;\n        }\n        else if (options.skipIfExists &&\n            options.passthroughOptions === undefined) {\n            options.passthroughOptions = {\n                preconditionOpts: {\n                    ifGenerationMatch: 0,\n                },\n            };\n        }\n        const limit = pLimit(options.concurrencyLimit || DEFAULT_PARALLEL_UPLOAD_LIMIT);\n        const promises = [];\n        let allPaths = [];\n        if (!Array.isArray(filePathsOrDirectory)) {\n            for await (const curPath of this.getPathsFromDirectory(filePathsOrDirectory)) {\n                allPaths.push(curPath);\n            }\n        }\n        else {\n            allPaths = filePathsOrDirectory;\n        }\n        for (const filePath of allPaths) {\n            const stat = await fs_1.promises.lstat(filePath);\n            if (stat.isDirectory()) {\n                continue;\n            }\n            const passThroughOptionsCopy = extend(true, {}, options.passthroughOptions);\n            passThroughOptionsCopy.destination = filePath;\n            if (options.prefix) {\n                passThroughOptionsCopy.destination = path.join(options.prefix, passThroughOptionsCopy.destination);\n            }\n            promises.push(limit(() => this.bucket.upload(filePath, passThroughOptionsCopy)));\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * @typedef {object} DownloadManyFilesOptions\n     * @property {number} [concurrencyLimit] The number of concurrently executing promises\n     * to use when downloading the files.\n     * @property {string} [prefix] A prefix to append to all of the downloaded files.\n     * @property {string} [stripPrefix] A prefix to remove from all of the downloaded files.\n     * @property {object} [passthroughOptions] {@link DownloadOptions} Options to be passed through\n     * to each individual download operation.\n     * @experimental\n     */\n    /**\n     * Download multiple files in parallel to the local filesystem. This is a convenience method\n     * that utilizes {@link File#download} to perform the download.\n     *\n     * @param {array | string} [filesOrFolder] An array of file name strings or file objects to be downloaded. If\n     * a string is provided this will be treated as a GCS prefix and all files with that prefix will be downloaded.\n     * @param {DownloadManyFilesOptions} [options] Configuration options.\n     * @returns {Promise<DownloadResponse[]>}\n     *\n     * @example\n     * ```\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     * const transferManager = new TransferManager(bucket);\n     *\n     * //-\n     * // Download multiple files in parallel.\n     * //-\n     * const response = await transferManager.downloadManyFiles(['file1.txt', 'file2.txt']);\n     * // The following files have been downloaded:\n     * // - \"file1.txt\" (with the contents from my-bucket.file1.txt)\n     * // - \"file2.txt\" (with the contents from my-bucket.file2.txt)\n     * const response = await transferManager.downloadManyFiles([bucket.File('file1.txt'), bucket.File('file2.txt')]);\n     * // The following files have been downloaded:\n     * // - \"file1.txt\" (with the contents from my-bucket.file1.txt)\n     * // - \"file2.txt\" (with the contents from my-bucket.file2.txt)\n     * const response = await transferManager.downloadManyFiles('test-folder');\n     * // All files with GCS prefix of 'test-folder' have been downloaded.\n     * ```\n     * @experimental\n     */\n    async downloadManyFiles(filesOrFolder, options = {}) {\n        const limit = pLimit(options.concurrencyLimit || DEFAULT_PARALLEL_DOWNLOAD_LIMIT);\n        const promises = [];\n        let files = [];\n        if (!Array.isArray(filesOrFolder)) {\n            const directoryFiles = await this.bucket.getFiles({\n                prefix: filesOrFolder,\n            });\n            files = directoryFiles[0];\n        }\n        else {\n            files = filesOrFolder.map(curFile => {\n                if (typeof curFile === 'string') {\n                    return this.bucket.file(curFile);\n                }\n                return curFile;\n            });\n        }\n        const stripRegexString = options.stripPrefix\n            ? `^${options.stripPrefix}`\n            : EMPTY_REGEX;\n        const regex = new RegExp(stripRegexString, 'g');\n        for (const file of files) {\n            const passThroughOptionsCopy = extend(true, {}, options.passthroughOptions);\n            if (options.prefix) {\n                passThroughOptionsCopy.destination = path.join(options.prefix || '', passThroughOptionsCopy.destination || '', file.name);\n            }\n            if (options.stripPrefix) {\n                passThroughOptionsCopy.destination = file.name.replace(regex, '');\n            }\n            promises.push(limit(() => file.download(passThroughOptionsCopy)));\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * @typedef {object} DownloadFileInChunksOptions\n     * @property {number} [concurrencyLimit] The number of concurrently executing promises\n     * to use when downloading the file.\n     * @property {number} [chunkSizeBytes] The size in bytes of each chunk to be downloaded.\n     * @property {string | boolean} [validation] Whether or not to perform a CRC32C validation check when download is complete.\n     * @experimental\n     */\n    /**\n     * Download a large file in chunks utilizing parallel download operations. This is a convenience method\n     * that utilizes {@link File#download} to perform the download.\n     *\n     * @param {object} [file | string] {@link File} to download.\n     * @param {DownloadFileInChunksOptions} [options] Configuration options.\n     * @returns {Promise<DownloadResponse>}\n     *\n     * @example\n     * ```\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     * const transferManager = new TransferManager(bucket);\n     *\n     * //-\n     * // Download a large file in chunks utilizing parallel operations.\n     * //-\n     * const response = await transferManager.downloadLargeFile(bucket.file('large-file.txt');\n     * // Your local directory now contains:\n     * // - \"large-file.txt\" (with the contents from my-bucket.large-file.txt)\n     * ```\n     * @experimental\n     */\n    async downloadFileInChunks(fileOrName, options = {}) {\n        let chunkSize = options.chunkSizeBytes || DOWNLOAD_IN_CHUNKS_DEFAULT_CHUNK_SIZE;\n        let limit = pLimit(options.concurrencyLimit || DEFAULT_PARALLEL_CHUNKED_DOWNLOAD_LIMIT);\n        const promises = [];\n        const file = typeof fileOrName === 'string'\n            ? this.bucket.file(fileOrName)\n            : fileOrName;\n        const fileInfo = await file.get();\n        const size = parseInt(fileInfo[0].metadata.size);\n        // If the file size does not meet the threshold download it as a single chunk.\n        if (size < DOWNLOAD_IN_CHUNKS_FILE_SIZE_THRESHOLD) {\n            limit = pLimit(1);\n            chunkSize = size;\n        }\n        let start = 0;\n        const filePath = options.destination || path.basename(file.name);\n        const fileToWrite = await fs_1.promises.open(filePath, 'w+');\n        while (start < size) {\n            const chunkStart = start;\n            let chunkEnd = start + chunkSize - 1;\n            chunkEnd = chunkEnd > size ? size : chunkEnd;\n            promises.push(limit(() => file.download({ start: chunkStart, end: chunkEnd }).then(resp => {\n                return fileToWrite.write(resp[0], 0, resp[0].length, chunkStart);\n            })));\n            start += chunkSize;\n        }\n        return new Promise((resolve, reject) => {\n            let results;\n            Promise.all(promises)\n                .then(data => {\n                results = data.map(result => result.buffer);\n                if (options.validation === 'crc32c') {\n                    return crc32c_1.CRC32C.fromFile(filePath);\n                }\n                return;\n            })\n                .then(() => {\n                resolve(results);\n            })\n                .catch(e => {\n                reject(e);\n            })\n                .finally(() => {\n                fileToWrite.close();\n            });\n        });\n    }\n    async *getPathsFromDirectory(directory) {\n        const filesAndSubdirectories = await fs_1.promises.readdir(directory, {\n            withFileTypes: true,\n        });\n        for (const curFileOrDirectory of filesAndSubdirectories) {\n            const fullPath = path.join(directory, curFileOrDirectory.name);\n            curFileOrDirectory.isDirectory()\n                ? yield* this.getPathsFromDirectory(fullPath)\n                : yield fullPath;\n        }\n    }\n}\nexports.TransferManager = TransferManager;\n//# sourceMappingURL=transfer-manager.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}