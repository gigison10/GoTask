{"ast":null,"code":"import { inRange, decoderError, encoderError, isASCIICodePoint, end_of_stream, finished, isASCIIByte, floor } from '../utils';\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes';\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @implements {Decoder}\n */\nexport class EUCKRDecoder {\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    this.euckr_lead = 0x00;\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && this.euckr_lead !== 0) {\n      this.euckr_lead = 0x00;\n      return decoderError(this.fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.euckr_lead === 0) return finished;\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (this.euckr_lead !== 0x00) {\n      const lead = this.euckr_lead;\n      let pointer = null;\n      this.euckr_lead = 0x00;\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n      if (inRange(bite, 0x41, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      const code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 4. If code point is null, return error.\n      if (code_point === null) return decoderError(this.fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.euckr_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(this.fatal);\n  }\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @implements {Encoder}\n */\nexport class EUCKREncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    const pointer = indexPointerFor(code_point, index('euc-kr'));\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    const lead = floor(pointer / 190) + 0x81;\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    const trail = pointer % 190 + 0x41;\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  }\n}","map":{"version":3,"names":["inRange","decoderError","encoderError","isASCIICodePoint","end_of_stream","finished","isASCIIByte","floor","index","indexCodePointFor","indexPointerFor","EUCKRDecoder","constructor","options","fatal","euckr_lead","handler","stream","bite","lead","pointer","code_point","prepend","EUCKREncoder","trail"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/euc-kr.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes'\n\n//\n// 14. Legacy multi-byte Korean encodings\n//\n\n// 14.1 euc-kr\n\n// 14.1.1 euc-kr decoder\n/**\n * @implements {Decoder}\n */\nexport class EUCKRDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    this.euckr_lead = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n    // euc-kr lead to 0x00 and return error.\n    if (bite === end_of_stream && this.euckr_lead !== 0) {\n      this.euckr_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.euckr_lead === 0)\n      return finished\n\n    // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n    // pointer be null, set euc-kr lead to 0x00, and then run these\n    // substeps:\n    if (this.euckr_lead !== 0x00) {\n      const lead = this.euckr_lead\n      let pointer = null\n      this.euckr_lead = 0x00\n\n      // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n      // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n      if (inRange(bite, 0x41, 0xFE))\n        pointer = (lead - 0x81) * 190 + (bite - 0x41)\n\n      // 2. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index euc-kr otherwise.\n      const code_point = (pointer === null)\n        ? null : indexCodePointFor(pointer, index('euc-kr'))\n\n      // 3. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (pointer === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 5. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n    // euc-kr lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.euckr_lead = bite\n      return null\n    }\n\n    // 6. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 14.1.2 euc-kr encoder\n/**\n * @implements {Encoder}\n */\nexport class EUCKREncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. Let pointer be the index pointer for code point in index\n    // euc-kr.\n    const pointer = indexPointerFor(code_point, index('euc-kr'))\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 5. Let lead be floor(pointer / 190) + 0x81.\n    const lead = floor(pointer / 190) + 0x81\n\n    // 6. Let trail be pointer % 190 + 0x41.\n    const trail = (pointer % 190) + 0x41\n\n    // 7. Return two bytes whose values are lead and trail.\n    return [lead, trail]\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}