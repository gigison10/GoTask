{"ast":null,"code":"import Stream, { DEFAULT_ENCODING, getEncoding } from './';\nimport { end_of_stream, finished, codePointsToString } from '../utils';\nimport { decoders } from '../table';\n\n// 8.1 Interface TextDecoder\n\nexport default class TextDecoder {\n  /**\n   * @param {string=} label The label of the encoding; defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  constructor() {\n    let label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_ENCODING;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    const encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name == 'replacement') throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    }\n\n    // 4. Set dec's encoding to encoding.\n    this._encoding = encoding;\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (options['fatal']) this._error_mode = 'fatal';\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (options['ignoreBOM']) this._ignoreBOM = true;\n  }\n  get encoding() {\n    return this._encoding.name.toLowerCase();\n  }\n  get fatal() {\n    return this._error_mode === 'fatal';\n  }\n  get ignoreBOM() {\n    return this._ignoreBOM;\n  }\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return The decoded string.\n   */\n  decode(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'\n      });\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    const input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    const output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    let result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      const token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream) break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished) break;\n      if (result !== null) {\n        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished) break;\n        if (result === null) continue;\n        if (Array.isArray(result)) output.push.apply(output, /**@type {!Array.<number>}*/result);else output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n    return this.serializeStream(output);\n  }\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   */\n  serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (['UTF-8', 'UTF-16LE', 'UTF-16BE'].includes(this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {\n      if (stream.length > 0 && stream[0] === 0xFEFF) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true;\n        stream.shift();\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true;\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream);\n  }\n}","map":{"version":3,"names":["Stream","DEFAULT_ENCODING","getEncoding","end_of_stream","finished","codePointsToString","decoders","TextDecoder","constructor","label","arguments","length","undefined","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","encoding","name","RangeError","Error","toLowerCase","fatal","ignoreBOM","decode","input","bytes","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","Boolean","input_stream","output","result","token","read","handler","Array","isArray","push","apply","endOfStream","serializeStream","stream","includes","shift"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/lib/TextDecoder.js"],"sourcesContent":["import Stream, { DEFAULT_ENCODING, getEncoding } from './'\nimport { end_of_stream, finished, codePointsToString } from '../utils'\nimport { decoders } from '../table'\n\n// 8.1 Interface TextDecoder\n\nexport default class TextDecoder {\n  /**\n   * @param {string=} label The label of the encoding; defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  constructor(label = DEFAULT_ENCODING, options = {}) {\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null\n    /** @private @type {?Decoder} */\n    this._decoder = null\n    /** @private @type {boolean} */\n    this._ignoreBOM = false\n    /** @private @type {boolean} */\n    this._BOMseen = false\n    /** @private @type {string} */\n    this._error_mode = 'replacement'\n    /** @private @type {boolean} */\n    this._do_not_flush = false\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    const encoding = getEncoding(label)\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name == 'replacement')\n      throw RangeError('Unknown encoding: ' + label)\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?')\n    }\n\n    // 4. Set dec's encoding to encoding.\n    this._encoding = encoding\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (options['fatal'])\n      this._error_mode = 'fatal'\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (options['ignoreBOM'])\n      this._ignoreBOM = true\n  }\n\n  get encoding() {\n    return this._encoding.name.toLowerCase()\n  }\n  get fatal() {\n    return this._error_mode === 'fatal'\n  }\n  get ignoreBOM() {\n    return this._ignoreBOM\n  }\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return The decoded string.\n   */\n  decode(input, options = {}) {\n    let bytes\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input)\n    } else if (typeof input === 'object' && 'buffer' in input &&\n                input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n        input.byteOffset,\n        input.byteLength)\n    } else {\n      bytes = new Uint8Array(0)\n    }\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal' })\n      this._BOMseen = false\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream'])\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    const input_stream = new Stream(bytes)\n\n    // 4. Let output be a new stream.\n    const output = []\n\n    /** @type {?(number|!Array.<number>)} */\n    let result\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      const token = input_stream.read()\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token)\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result))\n        else\n          output.push(result)\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read())\n        if (result === finished)\n          break\n        if (result === null)\n          continue\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result))\n        else\n          output.push(result)\n      } while (!input_stream.endOfStream())\n      this._decoder = null\n    }\n\n    return this.serializeStream(output)\n  }\n  // A TextDecoder object also has an associated serialize stream\n  // algorithm...\n  /**\n   * @param {!Array.<number>} stream\n   */\n  serializeStream(stream) {\n    // 1. Let token be the result of reading from stream.\n    // (Done in-place on array, rather than as a stream)\n\n    // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n    // BOM flag and BOM seen flag are unset, run these subsubsteps:\n    if (['UTF-8', 'UTF-16LE', 'UTF-16BE'].includes(this._encoding.name) &&\n        !this._ignoreBOM && !this._BOMseen) {\n      if (stream.length > 0 && stream[0] === 0xFEFF) {\n        // 1. If token is U+FEFF, set BOM seen flag.\n        this._BOMseen = true\n        stream.shift()\n      } else if (stream.length > 0) {\n        // 2. Otherwise, if token is not end-of-stream, set BOM seen\n        // flag and append token to stream.\n        this._BOMseen = true\n      } else {\n        // 3. Otherwise, if token is not end-of-stream, append token\n        // to output.\n        // (no-op)\n      }\n    }\n    // 4. Otherwise, return output.\n    return codePointsToString(stream)\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}