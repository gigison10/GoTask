{"ast":null,"code":"/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\nvar TokenBucket = function (bucketSize, tokensPerInterval, interval, parentBucket) {\n  this.bucketSize = bucketSize;\n  this.tokensPerInterval = tokensPerInterval;\n  if (typeof interval === 'string') {\n    switch (interval) {\n      case 'sec':\n      case 'second':\n        this.interval = 1000;\n        break;\n      case 'min':\n      case 'minute':\n        this.interval = 1000 * 60;\n        break;\n      case 'hr':\n      case 'hour':\n        this.interval = 1000 * 60 * 60;\n        break;\n      case 'day':\n        this.interval = 1000 * 60 * 60 * 24;\n        break;\n      default:\n        throw new Error('Invaid interval ' + interval);\n    }\n  } else {\n    this.interval = interval;\n  }\n  this.parentBucket = parentBucket;\n  this.content = 0;\n  this.lastDrip = +new Date();\n};\nTokenBucket.prototype = {\n  bucketSize: 1,\n  tokensPerInterval: 1,\n  interval: 1000,\n  parentBucket: null,\n  content: 0,\n  lastDrip: 0,\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\n  removeTokens: function (count, callback) {\n    var self = this;\n\n    // Is this an infinite size bucket?\n    if (!this.bucketSize) {\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\n      return true;\n    }\n\n    // Make sure the bucket can hold the requested number of tokens\n    if (count > this.bucketSize) {\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' + this.bucketSize, null));\n      return false;\n    }\n\n    // Drip new tokens into this bucket\n    this.drip();\n\n    // If we don't have enough tokens in this bucket, come back later\n    if (count > this.content) return comeBackLater();\n    if (this.parentBucket) {\n      // Remove the requested from the parent bucket first\n      return this.parentBucket.removeTokens(count, function (err, remainingTokens) {\n        if (err) return callback(err, null);\n\n        // Check that we still have enough tokens in this bucket\n        if (count > self.content) return comeBackLater();\n\n        // Tokens were removed from the parent bucket, now remove them from\n        // this bucket and fire the callback. Note that we look at the current\n        // bucket and parent bucket's remaining tokens and return the smaller\n        // of the two values\n        self.content -= count;\n        callback(null, Math.min(remainingTokens, self.content));\n      });\n    } else {\n      // Remove the requested tokens from this bucket and fire the callback\n      this.content -= count;\n      process.nextTick(callback.bind(null, null, this.content));\n      return true;\n    }\n    function comeBackLater() {\n      // How long do we need to wait to make up the difference in tokens?\n      var waitInterval = Math.ceil((count - self.content) * (self.interval / self.tokensPerInterval));\n      setTimeout(function () {\n        self.removeTokens(count, callback);\n      }, waitInterval);\n      return false;\n    }\n  },\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\n  tryRemoveTokens: function (count) {\n    // Is this an infinite size bucket?\n    if (!this.bucketSize) return true;\n\n    // Make sure the bucket can hold the requested number of tokens\n    if (count > this.bucketSize) return false;\n\n    // Drip new tokens into this bucket\n    this.drip();\n\n    // If we don't have enough tokens in this bucket, return false\n    if (count > this.content) return false;\n\n    // Try to remove the requested tokens from the parent bucket\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count)) return false;\n\n    // Remove the requested tokens from this bucket and return\n    this.content -= count;\n    return true;\n  },\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\n  drip: function () {\n    if (!this.tokensPerInterval) {\n      this.content = this.bucketSize;\n      return;\n    }\n    var now = +new Date();\n    var deltaMS = Math.max(now - this.lastDrip, 0);\n    this.lastDrip = now;\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\n  }\n};\nmodule.exports = TokenBucket;","map":{"version":3,"names":["TokenBucket","bucketSize","tokensPerInterval","interval","parentBucket","Error","content","lastDrip","Date","prototype","removeTokens","count","callback","self","process","nextTick","bind","Number","POSITIVE_INFINITY","drip","comeBackLater","err","remainingTokens","Math","min","waitInterval","ceil","setTimeout","tryRemoveTokens","now","deltaMS","max","dripAmount","module","exports"],"sources":["D:/Coding/React/taskmybusiness/node_modules/limiter/lib/tokenBucket.js"],"sourcesContent":["\r\n/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\r\nvar TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {\r\n  this.bucketSize = bucketSize;\r\n  this.tokensPerInterval = tokensPerInterval;\r\n\r\n  if (typeof interval === 'string') {\r\n    switch (interval) {\r\n      case 'sec': case 'second':\r\n        this.interval = 1000; break;\r\n      case 'min': case 'minute':\r\n        this.interval = 1000 * 60; break;\r\n      case 'hr': case 'hour':\r\n        this.interval = 1000 * 60 * 60; break;\r\n      case 'day':\r\n        this.interval = 1000 * 60 * 60 * 24; break;\r\n      default:\r\n        throw new Error('Invaid interval ' + interval);\r\n    }\r\n  } else {\r\n    this.interval = interval;\r\n  }\r\n\r\n  this.parentBucket = parentBucket;\r\n  this.content = 0;\r\n  this.lastDrip = +new Date();\r\n};\r\n\r\nTokenBucket.prototype = {\r\n  bucketSize: 1,\r\n  tokensPerInterval: 1,\r\n  interval: 1000,\r\n  parentBucket: null,\r\n  content: 0,\r\n  lastDrip: 0,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    var self = this;\r\n\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize) {\r\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\r\n      return true;\r\n    }\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +\r\n        this.bucketSize, null));\r\n      return false;\r\n    }\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, come back later\r\n    if (count > this.content)\r\n      return comeBackLater();\r\n\r\n    if (this.parentBucket) {\r\n      // Remove the requested from the parent bucket first\r\n      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {\r\n        if (err) return callback(err, null);\r\n\r\n        // Check that we still have enough tokens in this bucket\r\n        if (count > self.content)\r\n          return comeBackLater();\r\n\r\n        // Tokens were removed from the parent bucket, now remove them from\r\n        // this bucket and fire the callback. Note that we look at the current\r\n        // bucket and parent bucket's remaining tokens and return the smaller\r\n        // of the two values\r\n        self.content -= count;\r\n        callback(null, Math.min(remainingTokens, self.content));\r\n      });\r\n    } else {\r\n      // Remove the requested tokens from this bucket and fire the callback\r\n      this.content -= count;\r\n      process.nextTick(callback.bind(null, null, this.content));\r\n      return true;\r\n    }\r\n\r\n    function comeBackLater() {\r\n      // How long do we need to wait to make up the difference in tokens?\r\n      var waitInterval = Math.ceil(\r\n        (count - self.content) * (self.interval / self.tokensPerInterval));\r\n      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize)\r\n      return true;\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize)\r\n      return false;\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, return false\r\n    if (count > this.content)\r\n      return false;\r\n\r\n    // Try to remove the requested tokens from the parent bucket\r\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))\r\n      return false;\r\n\r\n    // Remove the requested tokens from this bucket and return\r\n    this.content -= count;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\r\n  drip: function() {\r\n    if (!this.tokensPerInterval) {\r\n      this.content = this.bucketSize;\r\n      return;\r\n    }\r\n\r\n    var now = +new Date();\r\n    var deltaMS = Math.max(now - this.lastDrip, 0);\r\n    this.lastDrip = now;\r\n\r\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\r\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\r\n  }\r\n};\r\n\r\nmodule.exports = TokenBucket;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}