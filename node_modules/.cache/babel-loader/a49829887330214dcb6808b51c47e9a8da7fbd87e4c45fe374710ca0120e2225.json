{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;\nconst validator = require(\"./validator\");\nconst jwt = require(\"jsonwebtoken\");\nconst jwks = require(\"jwks-rsa\");\nconst api_request_1 = require(\"../utils/api-request\");\nexports.ALGORITHM_RS256 = 'RS256';\n// `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type\n// and prefixes the error message with the following. Use the prefix to identify errors thrown\n// from the key provider callback.\n// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96\nconst JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';\nconst NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';\nconst NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';\nconst HOUR_IN_SECONDS = 3600;\nclass JwksFetcher {\n  constructor(jwksUrl) {\n    this.publicKeysExpireAt = 0;\n    if (!validator.isURL(jwksUrl)) {\n      throw new Error('The provided JWKS URL is not a valid URL.');\n    }\n    this.client = jwks({\n      jwksUri: jwksUrl,\n      cache: false // disable jwks-rsa LRU cache as the keys are always cached for 6 hours.\n    });\n  }\n\n  fetchPublicKeys() {\n    if (this.shouldRefresh()) {\n      return this.refresh();\n    }\n    return Promise.resolve(this.publicKeys);\n  }\n  shouldRefresh() {\n    return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n  }\n  refresh() {\n    return this.client.getSigningKeys().then(signingKeys => {\n      // reset expire at from previous set of keys.\n      this.publicKeysExpireAt = 0;\n      const newKeys = signingKeys.reduce((map, signingKey) => {\n        map[signingKey.kid] = signingKey.getPublicKey();\n        return map;\n      }, {});\n      this.publicKeysExpireAt = Date.now() + HOUR_IN_SECONDS * 6 * 1000;\n      this.publicKeys = newKeys;\n      return newKeys;\n    }).catch(err => {\n      throw new Error(`Error fetching Json Web Keys: ${err.message}`);\n    });\n  }\n}\nexports.JwksFetcher = JwksFetcher;\n/**\n * Class to fetch public keys from a client certificates URL.\n */\nclass UrlKeyFetcher {\n  constructor(clientCertUrl, httpAgent) {\n    this.clientCertUrl = clientCertUrl;\n    this.httpAgent = httpAgent;\n    this.publicKeysExpireAt = 0;\n    if (!validator.isURL(clientCertUrl)) {\n      throw new Error('The provided public client certificate URL is not a valid URL.');\n    }\n  }\n  /**\n   * Fetches the public keys for the Google certs.\n   *\n   * @returns A promise fulfilled with public keys for the Google certs.\n   */\n  fetchPublicKeys() {\n    if (this.shouldRefresh()) {\n      return this.refresh();\n    }\n    return Promise.resolve(this.publicKeys);\n  }\n  /**\n   * Checks if the cached public keys need to be refreshed.\n   *\n   * @returns Whether the keys should be fetched from the client certs url or not.\n   */\n  shouldRefresh() {\n    return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n  }\n  refresh() {\n    const client = new api_request_1.HttpClient();\n    const request = {\n      method: 'GET',\n      url: this.clientCertUrl,\n      httpAgent: this.httpAgent\n    };\n    return client.send(request).then(resp => {\n      if (!resp.isJson() || resp.data.error) {\n        // Treat all non-json messages and messages with an 'error' field as\n        // error responses.\n        throw new api_request_1.HttpError(resp);\n      }\n      // reset expire at from previous set of keys.\n      this.publicKeysExpireAt = 0;\n      if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n        const cacheControlHeader = resp.headers['cache-control'];\n        const parts = cacheControlHeader.split(',');\n        parts.forEach(part => {\n          const subParts = part.trim().split('=');\n          if (subParts[0] === 'max-age') {\n            const maxAge = +subParts[1];\n            this.publicKeysExpireAt = Date.now() + maxAge * 1000;\n          }\n        });\n      }\n      this.publicKeys = resp.data;\n      return resp.data;\n    }).catch(err => {\n      if (err instanceof api_request_1.HttpError) {\n        let errorMessage = 'Error fetching public keys for Google certs: ';\n        const resp = err.response;\n        if (resp.isJson() && resp.data.error) {\n          errorMessage += `${resp.data.error}`;\n          if (resp.data.error_description) {\n            errorMessage += ' (' + resp.data.error_description + ')';\n          }\n        } else {\n          errorMessage += `${resp.text}`;\n        }\n        throw new Error(errorMessage);\n      }\n      throw err;\n    });\n  }\n}\nexports.UrlKeyFetcher = UrlKeyFetcher;\n/**\n * Class for verifying JWT signature with a public key.\n */\nclass PublicKeySignatureVerifier {\n  constructor(keyFetcher) {\n    this.keyFetcher = keyFetcher;\n    if (!validator.isNonNullObject(keyFetcher)) {\n      throw new Error('The provided key fetcher is not an object or null.');\n    }\n  }\n  static withCertificateUrl(clientCertUrl, httpAgent) {\n    return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));\n  }\n  static withJwksUrl(jwksUrl) {\n    return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl));\n  }\n  verify(token) {\n    if (!validator.isString(token)) {\n      return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n    return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), {\n      algorithms: [exports.ALGORITHM_RS256]\n    }).catch(error => {\n      if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {\n        // No kid in JWT header. Try with all the public keys.\n        return this.verifyWithoutKid(token);\n      }\n      throw error;\n    });\n  }\n  verifyWithoutKid(token) {\n    return this.keyFetcher.fetchPublicKeys().then(publicKeys => this.verifyWithAllKeys(token, publicKeys));\n  }\n  verifyWithAllKeys(token, keys) {\n    const promises = [];\n    Object.values(keys).forEach(key => {\n      const result = verifyJwtSignature(token, key).then(() => true).catch(error => {\n        if (error.code === JwtErrorCode.TOKEN_EXPIRED) {\n          throw error;\n        }\n        return false;\n      });\n      promises.push(result);\n    });\n    return Promise.all(promises).then(result => {\n      if (result.every(r => r === false)) {\n        throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');\n      }\n    });\n  }\n}\nexports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;\n/**\n * Class for verifying unsigned (emulator) JWTs.\n */\nclass EmulatorSignatureVerifier {\n  verify(token) {\n    // Signature checks skipped for emulator; no need to fetch public keys.\n    return verifyJwtSignature(token, undefined, {\n      algorithms: ['none']\n    });\n  }\n}\nexports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;\n/**\n * Provides a callback to fetch public keys.\n *\n * @param fetcher - KeyFetcher to fetch the keys from.\n * @returns A callback function that can be used to get keys in `jsonwebtoken`.\n */\nfunction getKeyCallback(fetcher) {\n  return (header, callback) => {\n    if (!header.kid) {\n      callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));\n    }\n    const kid = header.kid || '';\n    fetcher.fetchPublicKeys().then(publicKeys => {\n      if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {\n        callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));\n      } else {\n        callback(null, publicKeys[kid]);\n      }\n    }).catch(error => {\n      callback(error);\n    });\n  };\n}\n/**\n * Verifies the signature of a JWT using the provided secret or a function to fetch\n * the secret or public key.\n *\n * @param token - The JWT to be verified.\n * @param secretOrPublicKey - The secret or a function to fetch the secret or public key.\n * @param options - JWT verification options.\n * @returns A Promise resolving for a token with a valid signature.\n */\nfunction verifyJwtSignature(token, secretOrPublicKey, options) {\n  if (!validator.isString(token)) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n  }\n  return new Promise((resolve, reject) => {\n    jwt.verify(token, secretOrPublicKey, options, error => {\n      if (!error) {\n        return resolve();\n      }\n      if (error.name === 'TokenExpiredError') {\n        return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' + 'client app and try again.'));\n      } else if (error.name === 'JsonWebTokenError') {\n        if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {\n          const message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';\n          let code = JwtErrorCode.KEY_FETCH_ERROR;\n          if (message === NO_MATCHING_KID_ERROR_MESSAGE) {\n            code = JwtErrorCode.NO_MATCHING_KID;\n          } else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) {\n            code = JwtErrorCode.NO_KID_IN_HEADER;\n          }\n          return reject(new JwtError(code, message));\n        }\n      }\n      return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));\n    });\n  });\n}\nexports.verifyJwtSignature = verifyJwtSignature;\n/**\n * Decodes general purpose Firebase JWTs.\n *\n * @param jwtToken - JWT token to be decoded.\n * @returns Decoded token containing the header and payload.\n */\nfunction decodeJwt(jwtToken) {\n  if (!validator.isString(jwtToken)) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n  }\n  const fullDecodedToken = jwt.decode(jwtToken, {\n    complete: true\n  });\n  if (!fullDecodedToken) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));\n  }\n  const header = fullDecodedToken?.header;\n  const payload = fullDecodedToken?.payload;\n  return Promise.resolve({\n    header,\n    payload\n  });\n}\nexports.decodeJwt = decodeJwt;\n/**\n * Jwt error code structure.\n *\n * @param code - The error code.\n * @param message - The error message.\n * @constructor\n */\nclass JwtError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    this.message = message;\n    this.__proto__ = JwtError.prototype;\n  }\n}\nexports.JwtError = JwtError;\n/**\n * JWT error codes.\n */\nvar JwtErrorCode;\n(function (JwtErrorCode) {\n  JwtErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n  JwtErrorCode[\"INVALID_CREDENTIAL\"] = \"invalid-credential\";\n  JwtErrorCode[\"TOKEN_EXPIRED\"] = \"token-expired\";\n  JwtErrorCode[\"INVALID_SIGNATURE\"] = \"invalid-token\";\n  JwtErrorCode[\"NO_MATCHING_KID\"] = \"no-matching-kid-error\";\n  JwtErrorCode[\"NO_KID_IN_HEADER\"] = \"no-kid-error\";\n  JwtErrorCode[\"KEY_FETCH_ERROR\"] = \"key-fetch-error\";\n})(JwtErrorCode = exports.JwtErrorCode || (exports.JwtErrorCode = {}));","map":{"version":3,"names":["Object","defineProperty","exports","value","JwtErrorCode","JwtError","decodeJwt","verifyJwtSignature","EmulatorSignatureVerifier","PublicKeySignatureVerifier","UrlKeyFetcher","JwksFetcher","ALGORITHM_RS256","validator","require","jwt","jwks","api_request_1","JWT_CALLBACK_ERROR_PREFIX","NO_MATCHING_KID_ERROR_MESSAGE","NO_KID_IN_HEADER_ERROR_MESSAGE","HOUR_IN_SECONDS","constructor","jwksUrl","publicKeysExpireAt","isURL","Error","client","jwksUri","cache","fetchPublicKeys","shouldRefresh","refresh","Promise","resolve","publicKeys","Date","now","getSigningKeys","then","signingKeys","newKeys","reduce","map","signingKey","kid","getPublicKey","catch","err","message","clientCertUrl","httpAgent","HttpClient","request","method","url","send","resp","isJson","data","error","HttpError","prototype","hasOwnProperty","call","headers","cacheControlHeader","parts","split","forEach","part","subParts","trim","maxAge","errorMessage","response","error_description","text","keyFetcher","isNonNullObject","withCertificateUrl","withJwksUrl","verify","token","isString","reject","INVALID_ARGUMENT","getKeyCallback","algorithms","code","NO_KID_IN_HEADER","verifyWithoutKid","verifyWithAllKeys","keys","promises","values","key","result","TOKEN_EXPIRED","push","all","every","r","INVALID_SIGNATURE","undefined","fetcher","header","callback","secretOrPublicKey","options","name","includes","pop","KEY_FETCH_ERROR","NO_MATCHING_KID","jwtToken","fullDecodedToken","decode","complete","payload","__proto__"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/utils/jwt.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;\nconst validator = require(\"./validator\");\nconst jwt = require(\"jsonwebtoken\");\nconst jwks = require(\"jwks-rsa\");\nconst api_request_1 = require(\"../utils/api-request\");\nexports.ALGORITHM_RS256 = 'RS256';\n// `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type\n// and prefixes the error message with the following. Use the prefix to identify errors thrown\n// from the key provider callback.\n// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96\nconst JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';\nconst NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';\nconst NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';\nconst HOUR_IN_SECONDS = 3600;\nclass JwksFetcher {\n    constructor(jwksUrl) {\n        this.publicKeysExpireAt = 0;\n        if (!validator.isURL(jwksUrl)) {\n            throw new Error('The provided JWKS URL is not a valid URL.');\n        }\n        this.client = jwks({\n            jwksUri: jwksUrl,\n            cache: false, // disable jwks-rsa LRU cache as the keys are always cached for 6 hours.\n        });\n    }\n    fetchPublicKeys() {\n        if (this.shouldRefresh()) {\n            return this.refresh();\n        }\n        return Promise.resolve(this.publicKeys);\n    }\n    shouldRefresh() {\n        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n    }\n    refresh() {\n        return this.client.getSigningKeys()\n            .then((signingKeys) => {\n            // reset expire at from previous set of keys.\n            this.publicKeysExpireAt = 0;\n            const newKeys = signingKeys.reduce((map, signingKey) => {\n                map[signingKey.kid] = signingKey.getPublicKey();\n                return map;\n            }, {});\n            this.publicKeysExpireAt = Date.now() + (HOUR_IN_SECONDS * 6 * 1000);\n            this.publicKeys = newKeys;\n            return newKeys;\n        }).catch((err) => {\n            throw new Error(`Error fetching Json Web Keys: ${err.message}`);\n        });\n    }\n}\nexports.JwksFetcher = JwksFetcher;\n/**\n * Class to fetch public keys from a client certificates URL.\n */\nclass UrlKeyFetcher {\n    constructor(clientCertUrl, httpAgent) {\n        this.clientCertUrl = clientCertUrl;\n        this.httpAgent = httpAgent;\n        this.publicKeysExpireAt = 0;\n        if (!validator.isURL(clientCertUrl)) {\n            throw new Error('The provided public client certificate URL is not a valid URL.');\n        }\n    }\n    /**\n     * Fetches the public keys for the Google certs.\n     *\n     * @returns A promise fulfilled with public keys for the Google certs.\n     */\n    fetchPublicKeys() {\n        if (this.shouldRefresh()) {\n            return this.refresh();\n        }\n        return Promise.resolve(this.publicKeys);\n    }\n    /**\n     * Checks if the cached public keys need to be refreshed.\n     *\n     * @returns Whether the keys should be fetched from the client certs url or not.\n     */\n    shouldRefresh() {\n        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n    }\n    refresh() {\n        const client = new api_request_1.HttpClient();\n        const request = {\n            method: 'GET',\n            url: this.clientCertUrl,\n            httpAgent: this.httpAgent,\n        };\n        return client.send(request).then((resp) => {\n            if (!resp.isJson() || resp.data.error) {\n                // Treat all non-json messages and messages with an 'error' field as\n                // error responses.\n                throw new api_request_1.HttpError(resp);\n            }\n            // reset expire at from previous set of keys.\n            this.publicKeysExpireAt = 0;\n            if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n                const cacheControlHeader = resp.headers['cache-control'];\n                const parts = cacheControlHeader.split(',');\n                parts.forEach((part) => {\n                    const subParts = part.trim().split('=');\n                    if (subParts[0] === 'max-age') {\n                        const maxAge = +subParts[1];\n                        this.publicKeysExpireAt = Date.now() + (maxAge * 1000);\n                    }\n                });\n            }\n            this.publicKeys = resp.data;\n            return resp.data;\n        }).catch((err) => {\n            if (err instanceof api_request_1.HttpError) {\n                let errorMessage = 'Error fetching public keys for Google certs: ';\n                const resp = err.response;\n                if (resp.isJson() && resp.data.error) {\n                    errorMessage += `${resp.data.error}`;\n                    if (resp.data.error_description) {\n                        errorMessage += ' (' + resp.data.error_description + ')';\n                    }\n                }\n                else {\n                    errorMessage += `${resp.text}`;\n                }\n                throw new Error(errorMessage);\n            }\n            throw err;\n        });\n    }\n}\nexports.UrlKeyFetcher = UrlKeyFetcher;\n/**\n * Class for verifying JWT signature with a public key.\n */\nclass PublicKeySignatureVerifier {\n    constructor(keyFetcher) {\n        this.keyFetcher = keyFetcher;\n        if (!validator.isNonNullObject(keyFetcher)) {\n            throw new Error('The provided key fetcher is not an object or null.');\n        }\n    }\n    static withCertificateUrl(clientCertUrl, httpAgent) {\n        return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));\n    }\n    static withJwksUrl(jwksUrl) {\n        return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl));\n    }\n    verify(token) {\n        if (!validator.isString(token)) {\n            return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n        }\n        return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), { algorithms: [exports.ALGORITHM_RS256] })\n            .catch((error) => {\n            if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {\n                // No kid in JWT header. Try with all the public keys.\n                return this.verifyWithoutKid(token);\n            }\n            throw error;\n        });\n    }\n    verifyWithoutKid(token) {\n        return this.keyFetcher.fetchPublicKeys()\n            .then(publicKeys => this.verifyWithAllKeys(token, publicKeys));\n    }\n    verifyWithAllKeys(token, keys) {\n        const promises = [];\n        Object.values(keys).forEach((key) => {\n            const result = verifyJwtSignature(token, key)\n                .then(() => true)\n                .catch((error) => {\n                if (error.code === JwtErrorCode.TOKEN_EXPIRED) {\n                    throw error;\n                }\n                return false;\n            });\n            promises.push(result);\n        });\n        return Promise.all(promises)\n            .then((result) => {\n            if (result.every((r) => r === false)) {\n                throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');\n            }\n        });\n    }\n}\nexports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;\n/**\n * Class for verifying unsigned (emulator) JWTs.\n */\nclass EmulatorSignatureVerifier {\n    verify(token) {\n        // Signature checks skipped for emulator; no need to fetch public keys.\n        return verifyJwtSignature(token, undefined, { algorithms: ['none'] });\n    }\n}\nexports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;\n/**\n * Provides a callback to fetch public keys.\n *\n * @param fetcher - KeyFetcher to fetch the keys from.\n * @returns A callback function that can be used to get keys in `jsonwebtoken`.\n */\nfunction getKeyCallback(fetcher) {\n    return (header, callback) => {\n        if (!header.kid) {\n            callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));\n        }\n        const kid = header.kid || '';\n        fetcher.fetchPublicKeys().then((publicKeys) => {\n            if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {\n                callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));\n            }\n            else {\n                callback(null, publicKeys[kid]);\n            }\n        })\n            .catch(error => {\n            callback(error);\n        });\n    };\n}\n/**\n * Verifies the signature of a JWT using the provided secret or a function to fetch\n * the secret or public key.\n *\n * @param token - The JWT to be verified.\n * @param secretOrPublicKey - The secret or a function to fetch the secret or public key.\n * @param options - JWT verification options.\n * @returns A Promise resolving for a token with a valid signature.\n */\nfunction verifyJwtSignature(token, secretOrPublicKey, options) {\n    if (!validator.isString(token)) {\n        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n    return new Promise((resolve, reject) => {\n        jwt.verify(token, secretOrPublicKey, options, (error) => {\n            if (!error) {\n                return resolve();\n            }\n            if (error.name === 'TokenExpiredError') {\n                return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' +\n                    'client app and try again.'));\n            }\n            else if (error.name === 'JsonWebTokenError') {\n                if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {\n                    const message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';\n                    let code = JwtErrorCode.KEY_FETCH_ERROR;\n                    if (message === NO_MATCHING_KID_ERROR_MESSAGE) {\n                        code = JwtErrorCode.NO_MATCHING_KID;\n                    }\n                    else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) {\n                        code = JwtErrorCode.NO_KID_IN_HEADER;\n                    }\n                    return reject(new JwtError(code, message));\n                }\n            }\n            return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));\n        });\n    });\n}\nexports.verifyJwtSignature = verifyJwtSignature;\n/**\n * Decodes general purpose Firebase JWTs.\n *\n * @param jwtToken - JWT token to be decoded.\n * @returns Decoded token containing the header and payload.\n */\nfunction decodeJwt(jwtToken) {\n    if (!validator.isString(jwtToken)) {\n        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n    const fullDecodedToken = jwt.decode(jwtToken, {\n        complete: true,\n    });\n    if (!fullDecodedToken) {\n        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));\n    }\n    const header = fullDecodedToken?.header;\n    const payload = fullDecodedToken?.payload;\n    return Promise.resolve({ header, payload });\n}\nexports.decodeJwt = decodeJwt;\n/**\n * Jwt error code structure.\n *\n * @param code - The error code.\n * @param message - The error message.\n * @constructor\n */\nclass JwtError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        this.message = message;\n        this.__proto__ = JwtError.prototype;\n    }\n}\nexports.JwtError = JwtError;\n/**\n * JWT error codes.\n */\nvar JwtErrorCode;\n(function (JwtErrorCode) {\n    JwtErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n    JwtErrorCode[\"INVALID_CREDENTIAL\"] = \"invalid-credential\";\n    JwtErrorCode[\"TOKEN_EXPIRED\"] = \"token-expired\";\n    JwtErrorCode[\"INVALID_SIGNATURE\"] = \"invalid-token\";\n    JwtErrorCode[\"NO_MATCHING_KID\"] = \"no-matching-kid-error\";\n    JwtErrorCode[\"NO_KID_IN_HEADER\"] = \"no-kid-error\";\n    JwtErrorCode[\"KEY_FETCH_ERROR\"] = \"key-fetch-error\";\n})(JwtErrorCode = exports.JwtErrorCode || (exports.JwtErrorCode = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}