{"ast":null,"code":"'use strict';\n\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\nconst ReadableStream = require('stream').Readable;\nconst inherits = require('util').inherits;\nconst Dicer = require('../../deps/dicer/lib/Dicer');\nconst parseParams = require('../utils/parseParams');\nconst decodeText = require('../utils/decodeText');\nconst basename = require('../utils/basename');\nconst getLimit = require('../utils/getLimit');\nconst RE_BOUNDARY = /^boundary$/i;\nconst RE_FIELD = /^form-data$/i;\nconst RE_CHARSET = /^charset$/i;\nconst RE_FILENAME = /^filename$/i;\nconst RE_NAME = /^name$/i;\nMultipart.detect = /^multipart\\/form-data/i;\nfunction Multipart(boy, cfg) {\n  let i;\n  let len;\n  const self = this;\n  let boundary;\n  const limits = cfg.limits;\n  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === 'application/octet-stream' || fileName !== undefined);\n  const parsedConType = cfg.parsedConType || [];\n  const defCharset = cfg.defCharset || 'utf8';\n  const preservePath = cfg.preservePath;\n  const fileOpts = {\n    highWaterMark: cfg.fileHwm\n  };\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1];\n      break;\n    }\n  }\n  function checkFinished() {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false;\n      process.nextTick(function () {\n        boy._done = true;\n        boy.emit('finish');\n      });\n    }\n  }\n  if (typeof boundary !== 'string') {\n    throw new Error('Multipart: Boundary not found');\n  }\n  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);\n  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);\n  const filesLimit = getLimit(limits, 'files', Infinity);\n  const fieldsLimit = getLimit(limits, 'fields', Infinity);\n  const partsLimit = getLimit(limits, 'parts', Infinity);\n  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);\n  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);\n  let nfiles = 0;\n  let nfields = 0;\n  let nends = 0;\n  let curFile;\n  let curField;\n  let finished = false;\n  this._needDrain = false;\n  this._pause = false;\n  this._cb = undefined;\n  this._nparts = 0;\n  this._boy = boy;\n  const parserCfg = {\n    boundary,\n    maxHeaderPairs: headerPairsLimit,\n    maxHeaderSize: headerSizeLimit,\n    partHwm: fileOpts.highWaterMark,\n    highWaterMark: cfg.highWaterMark\n  };\n  this.parser = new Dicer(parserCfg);\n  this.parser.on('drain', function () {\n    self._needDrain = false;\n    if (self._cb && !self._pause) {\n      const cb = self._cb;\n      self._cb = undefined;\n      cb();\n    }\n  }).on('part', function onPart(part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart);\n      self.parser.on('part', skipPart);\n      boy.hitPartsLimit = true;\n      boy.emit('partsLimit');\n      return skipPart(part);\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      const field = curField;\n      field.emit('end');\n      field.removeAllListeners('end');\n    }\n    part.on('header', function (header) {\n      let contype;\n      let fieldname;\n      let parsed;\n      let charset;\n      let encoding;\n      let filename;\n      let nsize = 0;\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0]);\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase();\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase();\n              break;\n            }\n          }\n        }\n      }\n      if (contype === undefined) {\n        contype = 'text/plain';\n      }\n      if (charset === undefined) {\n        charset = defCharset;\n      }\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0]);\n        if (!RE_FIELD.test(parsed[0])) {\n          return skipPart(part);\n        }\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = parsed[i][1];\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = parsed[i][1];\n            if (!preservePath) {\n              filename = basename(filename);\n            }\n          }\n        }\n      } else {\n        return skipPart(part);\n      }\n      if (header['content-transfer-encoding']) {\n        encoding = header['content-transfer-encoding'][0].toLowerCase();\n      } else {\n        encoding = '7bit';\n      }\n      let onData, onEnd;\n      if (isPartAFile(fieldname, contype, filename)) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true;\n            boy.emit('filesLimit');\n          }\n          return skipPart(part);\n        }\n        ++nfiles;\n        if (!boy._events.file) {\n          self.parser._ignore();\n          return;\n        }\n        ++nends;\n        const file = new FileStream(fileOpts);\n        curFile = file;\n        file.on('end', function () {\n          --nends;\n          self._pause = false;\n          checkFinished();\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        });\n        file._read = function (n) {\n          if (!self._pause) {\n            return;\n          }\n          self._pause = false;\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb;\n            self._cb = undefined;\n            cb();\n          }\n        };\n        boy.emit('file', fieldname, file, filename, encoding, contype);\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            const extralen = fileSizeLimit - nsize + data.length;\n            if (extralen > 0) {\n              file.push(data.slice(0, extralen));\n            }\n            file.truncated = true;\n            file.bytesRead = fileSizeLimit;\n            part.removeAllListeners('data');\n            file.emit('limit');\n            return;\n          } else if (!file.push(data)) {\n            self._pause = true;\n          }\n          file.bytesRead = nsize;\n        };\n        onEnd = function () {\n          curFile = undefined;\n          file.push(null);\n        };\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true;\n            boy.emit('fieldsLimit');\n          }\n          return skipPart(part);\n        }\n        ++nfields;\n        ++nends;\n        let buffer = '';\n        let truncated = false;\n        curField = part;\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            const extralen = fieldSizeLimit - (nsize - data.length);\n            buffer += data.toString('binary', 0, extralen);\n            truncated = true;\n            part.removeAllListeners('data');\n          } else {\n            buffer += data.toString('binary');\n          }\n        };\n        onEnd = function () {\n          curField = undefined;\n          if (buffer.length) {\n            buffer = decodeText(buffer, 'binary', charset);\n          }\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);\n          --nends;\n          checkFinished();\n        };\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false;\n      part.on('data', onData);\n      part.on('end', onEnd);\n    }).on('error', function (err) {\n      if (curFile) {\n        curFile.emit('error', err);\n      }\n    });\n  }).on('error', function (err) {\n    boy.emit('error', err);\n  }).on('finish', function () {\n    finished = true;\n    checkFinished();\n  });\n}\nMultipart.prototype.write = function (chunk, cb) {\n  let r;\n  if ((r = this.parser.write(chunk)) && !this._pause) {\n    cb();\n  } else {\n    this._needDrain = !r;\n    this._cb = cb;\n  }\n};\nMultipart.prototype.end = function () {\n  const self = this;\n  if (this._nparts === 0 && !self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true;\n      self._boy.emit('finish');\n    });\n  } else if (this.parser.writable) {\n    this.parser.end();\n  }\n};\nfunction skipPart(part) {\n  part.resume();\n}\nfunction FileStream(opts) {\n  ReadableStream.call(this, opts);\n  this.bytesRead = 0;\n  this.truncated = false;\n}\ninherits(FileStream, ReadableStream);\nFileStream.prototype._read = function (n) {};\nmodule.exports = Multipart;","map":{"version":3,"names":["ReadableStream","require","Readable","inherits","Dicer","parseParams","decodeText","basename","getLimit","RE_BOUNDARY","RE_FIELD","RE_CHARSET","RE_FILENAME","RE_NAME","Multipart","detect","boy","cfg","i","len","self","boundary","limits","isPartAFile","fieldName","contentType","fileName","undefined","parsedConType","defCharset","preservePath","fileOpts","highWaterMark","fileHwm","length","Array","isArray","test","checkFinished","nends","finished","_done","process","nextTick","emit","Error","fieldSizeLimit","fileSizeLimit","Infinity","filesLimit","fieldsLimit","partsLimit","headerPairsLimit","headerSizeLimit","nfiles","nfields","curFile","curField","_needDrain","_pause","_cb","_nparts","_boy","parserCfg","maxHeaderPairs","maxHeaderSize","partHwm","parser","on","cb","onPart","part","removeListener","skipPart","hitPartsLimit","field","removeAllListeners","header","contype","fieldname","parsed","charset","encoding","filename","nsize","toLowerCase","onData","onEnd","hitFilesLimit","_events","file","_ignore","FileStream","_read","n","data","extralen","push","slice","truncated","bytesRead","hitFieldsLimit","buffer","toString","_readableState","sync","err","prototype","write","chunk","r","end","writable","resume","opts","call","module","exports"],"sources":["D:/Coding/React/taskmybusiness/node_modules/@fastify/busboy/lib/types/multipart.js"],"sourcesContent":["'use strict'\n\n// TODO:\n//  * support 1 nested multipart level\n//    (see second multipart example here:\n//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)\n//  * support limits.fieldNameSize\n//     -- this will require modifications to utils.parseParams\n\nconst ReadableStream = require('stream').Readable\nconst inherits = require('util').inherits\n\nconst Dicer = require('../../deps/dicer/lib/Dicer')\n\nconst parseParams = require('../utils/parseParams')\nconst decodeText = require('../utils/decodeText')\nconst basename = require('../utils/basename')\nconst getLimit = require('../utils/getLimit')\n\nconst RE_BOUNDARY = /^boundary$/i\nconst RE_FIELD = /^form-data$/i\nconst RE_CHARSET = /^charset$/i\nconst RE_FILENAME = /^filename$/i\nconst RE_NAME = /^name$/i\n\nMultipart.detect = /^multipart\\/form-data/i\nfunction Multipart (boy, cfg) {\n  let i\n  let len\n  const self = this\n  let boundary\n  const limits = cfg.limits\n  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined))\n  const parsedConType = cfg.parsedConType || []\n  const defCharset = cfg.defCharset || 'utf8'\n  const preservePath = cfg.preservePath\n  const fileOpts = { highWaterMark: cfg.fileHwm }\n\n  for (i = 0, len = parsedConType.length; i < len; ++i) {\n    if (Array.isArray(parsedConType[i]) &&\n      RE_BOUNDARY.test(parsedConType[i][0])) {\n      boundary = parsedConType[i][1]\n      break\n    }\n  }\n\n  function checkFinished () {\n    if (nends === 0 && finished && !boy._done) {\n      finished = false\n      process.nextTick(function () {\n        boy._done = true\n        boy.emit('finish')\n      })\n    }\n  }\n\n  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }\n\n  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)\n  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity)\n  const filesLimit = getLimit(limits, 'files', Infinity)\n  const fieldsLimit = getLimit(limits, 'fields', Infinity)\n  const partsLimit = getLimit(limits, 'parts', Infinity)\n  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000)\n  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024)\n\n  let nfiles = 0\n  let nfields = 0\n  let nends = 0\n  let curFile\n  let curField\n  let finished = false\n\n  this._needDrain = false\n  this._pause = false\n  this._cb = undefined\n  this._nparts = 0\n  this._boy = boy\n\n  const parserCfg = {\n    boundary,\n    maxHeaderPairs: headerPairsLimit,\n    maxHeaderSize: headerSizeLimit,\n    partHwm: fileOpts.highWaterMark,\n    highWaterMark: cfg.highWaterMark\n  }\n\n  this.parser = new Dicer(parserCfg)\n  this.parser.on('drain', function () {\n    self._needDrain = false\n    if (self._cb && !self._pause) {\n      const cb = self._cb\n      self._cb = undefined\n      cb()\n    }\n  }).on('part', function onPart (part) {\n    if (++self._nparts > partsLimit) {\n      self.parser.removeListener('part', onPart)\n      self.parser.on('part', skipPart)\n      boy.hitPartsLimit = true\n      boy.emit('partsLimit')\n      return skipPart(part)\n    }\n\n    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let\n    // us emit 'end' early since we know the part has ended if we are already\n    // seeing the next part\n    if (curField) {\n      const field = curField\n      field.emit('end')\n      field.removeAllListeners('end')\n    }\n\n    part.on('header', function (header) {\n      let contype\n      let fieldname\n      let parsed\n      let charset\n      let encoding\n      let filename\n      let nsize = 0\n\n      if (header['content-type']) {\n        parsed = parseParams(header['content-type'][0])\n        if (parsed[0]) {\n          contype = parsed[0].toLowerCase()\n          for (i = 0, len = parsed.length; i < len; ++i) {\n            if (RE_CHARSET.test(parsed[i][0])) {\n              charset = parsed[i][1].toLowerCase()\n              break\n            }\n          }\n        }\n      }\n\n      if (contype === undefined) { contype = 'text/plain' }\n      if (charset === undefined) { charset = defCharset }\n\n      if (header['content-disposition']) {\n        parsed = parseParams(header['content-disposition'][0])\n        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }\n        for (i = 0, len = parsed.length; i < len; ++i) {\n          if (RE_NAME.test(parsed[i][0])) {\n            fieldname = parsed[i][1]\n          } else if (RE_FILENAME.test(parsed[i][0])) {\n            filename = parsed[i][1]\n            if (!preservePath) { filename = basename(filename) }\n          }\n        }\n      } else { return skipPart(part) }\n\n      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase() } else { encoding = '7bit' }\n\n      let onData,\n        onEnd\n\n      if (isPartAFile(fieldname, contype, filename)) {\n        // file/binary field\n        if (nfiles === filesLimit) {\n          if (!boy.hitFilesLimit) {\n            boy.hitFilesLimit = true\n            boy.emit('filesLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfiles\n\n        if (!boy._events.file) {\n          self.parser._ignore()\n          return\n        }\n\n        ++nends\n        const file = new FileStream(fileOpts)\n        curFile = file\n        file.on('end', function () {\n          --nends\n          self._pause = false\n          checkFinished()\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        })\n        file._read = function (n) {\n          if (!self._pause) { return }\n          self._pause = false\n          if (self._cb && !self._needDrain) {\n            const cb = self._cb\n            self._cb = undefined\n            cb()\n          }\n        }\n        boy.emit('file', fieldname, file, filename, encoding, contype)\n\n        onData = function (data) {\n          if ((nsize += data.length) > fileSizeLimit) {\n            const extralen = fileSizeLimit - nsize + data.length\n            if (extralen > 0) { file.push(data.slice(0, extralen)) }\n            file.truncated = true\n            file.bytesRead = fileSizeLimit\n            part.removeAllListeners('data')\n            file.emit('limit')\n            return\n          } else if (!file.push(data)) { self._pause = true }\n\n          file.bytesRead = nsize\n        }\n\n        onEnd = function () {\n          curFile = undefined\n          file.push(null)\n        }\n      } else {\n        // non-file field\n        if (nfields === fieldsLimit) {\n          if (!boy.hitFieldsLimit) {\n            boy.hitFieldsLimit = true\n            boy.emit('fieldsLimit')\n          }\n          return skipPart(part)\n        }\n\n        ++nfields\n        ++nends\n        let buffer = ''\n        let truncated = false\n        curField = part\n\n        onData = function (data) {\n          if ((nsize += data.length) > fieldSizeLimit) {\n            const extralen = (fieldSizeLimit - (nsize - data.length))\n            buffer += data.toString('binary', 0, extralen)\n            truncated = true\n            part.removeAllListeners('data')\n          } else { buffer += data.toString('binary') }\n        }\n\n        onEnd = function () {\n          curField = undefined\n          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset) }\n          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype)\n          --nends\n          checkFinished()\n        }\n      }\n\n      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become\n         broken. Streams2/streams3 is a huge black box of confusion, but\n         somehow overriding the sync state seems to fix things again (and still\n         seems to work for previous node versions).\n      */\n      part._readableState.sync = false\n\n      part.on('data', onData)\n      part.on('end', onEnd)\n    }).on('error', function (err) {\n      if (curFile) { curFile.emit('error', err) }\n    })\n  }).on('error', function (err) {\n    boy.emit('error', err)\n  }).on('finish', function () {\n    finished = true\n    checkFinished()\n  })\n}\n\nMultipart.prototype.write = function (chunk, cb) {\n  let r\n  if ((r = this.parser.write(chunk)) && !this._pause) { cb() } else {\n    this._needDrain = !r\n    this._cb = cb\n  }\n}\n\nMultipart.prototype.end = function () {\n  const self = this\n  if (this._nparts === 0 && !self._boy._done) {\n    process.nextTick(function () {\n      self._boy._done = true\n      self._boy.emit('finish')\n    })\n  } else if (this.parser.writable) { this.parser.end() }\n}\n\nfunction skipPart (part) {\n  part.resume()\n}\n\nfunction FileStream (opts) {\n  ReadableStream.call(this, opts)\n\n  this.bytesRead = 0\n\n  this.truncated = false\n}\ninherits(FileStream, ReadableStream)\n\nFileStream.prototype._read = function (n) { }\n\nmodule.exports = Multipart\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}