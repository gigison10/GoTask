{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handleCryptoSignerError = exports.FirebaseTokenGenerator = exports.EmulatedSigner = exports.BLACKLISTED_CLAIMS = void 0;\nconst error_1 = require(\"../utils/error\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\nconst validator = require(\"../utils/validator\");\nconst utils_1 = require(\"../utils\");\nconst ALGORITHM_NONE = 'none';\nconst ONE_HOUR_IN_SECONDS = 60 * 60;\n// List of blacklisted claims which cannot be provided when creating a custom token\nexports.BLACKLISTED_CLAIMS = ['acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti', 'nbf', 'nonce'];\n// Audience to use for Firebase Auth Custom tokens\nconst FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\n/**\n * A CryptoSigner implementation that is used when communicating with the Auth emulator.\n * It produces unsigned tokens.\n */\nclass EmulatedSigner {\n  constructor() {\n    this.algorithm = ALGORITHM_NONE;\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  sign(buffer) {\n    return Promise.resolve(Buffer.from(''));\n  }\n  /**\n   * @inheritDoc\n   */\n  getAccountId() {\n    return Promise.resolve('firebase-auth-emulator@example.com');\n  }\n}\nexports.EmulatedSigner = EmulatedSigner;\n/**\n * Class for generating different types of Firebase Auth tokens (JWTs).\n *\n * @internal\n */\nclass FirebaseTokenGenerator {\n  /**\n   * @param tenantId - The tenant ID to use for the generated Firebase Auth\n   *     Custom token. If absent, then no tenant ID claim will be set in the\n   *     resulting JWT.\n   */\n  constructor(signer, tenantId) {\n    this.tenantId = tenantId;\n    if (!validator.isNonNullObject(signer)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.');\n    }\n    if (typeof this.tenantId !== 'undefined' && !validator.isNonEmptyString(this.tenantId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`tenantId` argument must be a non-empty string.');\n    }\n    this.signer = signer;\n  }\n  /**\n   * Creates a new Firebase Auth Custom token.\n   *\n   * @param uid - The user ID to use for the generated Firebase Auth Custom token.\n   * @param developerClaims - Optional developer claims to include in the generated Firebase\n   *     Auth Custom token.\n   * @returns A Promise fulfilled with a Firebase Auth Custom token signed with a\n   *     service account key and containing the provided payload.\n   */\n  createCustomToken(uid, developerClaims) {\n    let errorMessage;\n    if (!validator.isNonEmptyString(uid)) {\n      errorMessage = '`uid` argument must be a non-empty string uid.';\n    } else if (uid.length > 128) {\n      errorMessage = '`uid` argument must a uid with less than or equal to 128 characters.';\n    } else if (!this.isDeveloperClaimsValid_(developerClaims)) {\n      errorMessage = '`developerClaims` argument must be a valid, non-null object containing the developer claims.';\n    }\n    if (errorMessage) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);\n    }\n    const claims = {};\n    if (typeof developerClaims !== 'undefined') {\n      for (const key in developerClaims) {\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(developerClaims, key)) {\n          if (exports.BLACKLISTED_CLAIMS.indexOf(key) !== -1) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Developer claim \"${key}\" is reserved and cannot be specified.`);\n          }\n          claims[key] = developerClaims[key];\n        }\n      }\n    }\n    return this.signer.getAccountId().then(account => {\n      const header = {\n        alg: this.signer.algorithm,\n        typ: 'JWT'\n      };\n      const iat = Math.floor(Date.now() / 1000);\n      const body = {\n        aud: FIREBASE_AUDIENCE,\n        iat,\n        exp: iat + ONE_HOUR_IN_SECONDS,\n        iss: account,\n        sub: account,\n        uid\n      };\n      if (this.tenantId) {\n        body.tenant_id = this.tenantId;\n      }\n      if (Object.keys(claims).length > 0) {\n        body.claims = claims;\n      }\n      const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;\n      const signPromise = this.signer.sign(Buffer.from(token));\n      return Promise.all([token, signPromise]);\n    }).then(_ref => {\n      let [token, signature] = _ref;\n      return `${token}.${this.encodeSegment(signature)}`;\n    }).catch(err => {\n      throw handleCryptoSignerError(err);\n    });\n  }\n  encodeSegment(segment) {\n    const buffer = segment instanceof Buffer ? segment : Buffer.from(JSON.stringify(segment));\n    return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, '');\n  }\n  /**\n   * Returns whether or not the provided developer claims are valid.\n   *\n   * @param developerClaims - Optional developer claims to validate.\n   * @returns True if the provided claims are valid; otherwise, false.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  isDeveloperClaimsValid_(developerClaims) {\n    if (typeof developerClaims === 'undefined') {\n      return true;\n    }\n    return validator.isNonNullObject(developerClaims);\n  }\n}\nexports.FirebaseTokenGenerator = FirebaseTokenGenerator;\n/**\n * Creates a new FirebaseAuthError by extracting the error code, message and other relevant\n * details from a CryptoSignerError.\n *\n * @param err - The Error to convert into a FirebaseAuthError error\n * @returns A Firebase Auth error that can be returned to the user.\n */\nfunction handleCryptoSignerError(err) {\n  if (!(err instanceof crypto_signer_1.CryptoSignerError)) {\n    return err;\n  }\n  if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {\n    const httpError = err.cause;\n    const errorResponse = httpError.response.data;\n    if (validator.isNonNullObject(errorResponse) && errorResponse.error) {\n      const errorCode = errorResponse.error.status;\n      const description = 'Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens ' + 'for more details on how to use and troubleshoot this feature.';\n      const errorMsg = `${errorResponse.error.message}; ${description}`;\n      return error_1.FirebaseAuthError.fromServerError(errorCode, errorMsg, errorResponse);\n    }\n    return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + errorResponse + '. Additionally, an ' + 'internal error occurred while attempting to extract the ' + 'errorcode from the error.');\n  }\n  return new error_1.FirebaseAuthError(mapToAuthClientErrorCode(err.code), err.message);\n}\nexports.handleCryptoSignerError = handleCryptoSignerError;\nfunction mapToAuthClientErrorCode(code) {\n  switch (code) {\n    case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:\n      return error_1.AuthClientErrorCode.INVALID_CREDENTIAL;\n    case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:\n      return error_1.AuthClientErrorCode.INVALID_ARGUMENT;\n    default:\n      return error_1.AuthClientErrorCode.INTERNAL_ERROR;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","handleCryptoSignerError","FirebaseTokenGenerator","EmulatedSigner","BLACKLISTED_CLAIMS","error_1","require","crypto_signer_1","validator","utils_1","ALGORITHM_NONE","ONE_HOUR_IN_SECONDS","FIREBASE_AUDIENCE","constructor","algorithm","sign","buffer","Promise","resolve","Buffer","from","getAccountId","signer","tenantId","isNonNullObject","FirebaseAuthError","AuthClientErrorCode","INVALID_CREDENTIAL","isNonEmptyString","INVALID_ARGUMENT","createCustomToken","uid","developerClaims","errorMessage","length","isDeveloperClaimsValid_","claims","key","prototype","hasOwnProperty","call","indexOf","then","account","header","alg","typ","iat","Math","floor","Date","now","body","aud","exp","iss","sub","tenant_id","keys","token","encodeSegment","signPromise","all","_ref","signature","catch","err","segment","JSON","stringify","toWebSafeBase64","replace","CryptoSignerError","code","CryptoSignerErrorCode","SERVER_ERROR","cause","httpError","errorResponse","response","data","error","errorCode","status","description","errorMsg","message","fromServerError","INTERNAL_ERROR","mapToAuthClientErrorCode"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/auth/token-generator.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.handleCryptoSignerError = exports.FirebaseTokenGenerator = exports.EmulatedSigner = exports.BLACKLISTED_CLAIMS = void 0;\nconst error_1 = require(\"../utils/error\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\nconst validator = require(\"../utils/validator\");\nconst utils_1 = require(\"../utils\");\nconst ALGORITHM_NONE = 'none';\nconst ONE_HOUR_IN_SECONDS = 60 * 60;\n// List of blacklisted claims which cannot be provided when creating a custom token\nexports.BLACKLISTED_CLAIMS = [\n    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti',\n    'nbf', 'nonce',\n];\n// Audience to use for Firebase Auth Custom tokens\nconst FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\n/**\n * A CryptoSigner implementation that is used when communicating with the Auth emulator.\n * It produces unsigned tokens.\n */\nclass EmulatedSigner {\n    constructor() {\n        this.algorithm = ALGORITHM_NONE;\n    }\n    /**\n     * @inheritDoc\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    sign(buffer) {\n        return Promise.resolve(Buffer.from(''));\n    }\n    /**\n     * @inheritDoc\n     */\n    getAccountId() {\n        return Promise.resolve('firebase-auth-emulator@example.com');\n    }\n}\nexports.EmulatedSigner = EmulatedSigner;\n/**\n * Class for generating different types of Firebase Auth tokens (JWTs).\n *\n * @internal\n */\nclass FirebaseTokenGenerator {\n    /**\n     * @param tenantId - The tenant ID to use for the generated Firebase Auth\n     *     Custom token. If absent, then no tenant ID claim will be set in the\n     *     resulting JWT.\n     */\n    constructor(signer, tenantId) {\n        this.tenantId = tenantId;\n        if (!validator.isNonNullObject(signer)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, 'INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.');\n        }\n        if (typeof this.tenantId !== 'undefined' && !validator.isNonEmptyString(this.tenantId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`tenantId` argument must be a non-empty string.');\n        }\n        this.signer = signer;\n    }\n    /**\n     * Creates a new Firebase Auth Custom token.\n     *\n     * @param uid - The user ID to use for the generated Firebase Auth Custom token.\n     * @param developerClaims - Optional developer claims to include in the generated Firebase\n     *     Auth Custom token.\n     * @returns A Promise fulfilled with a Firebase Auth Custom token signed with a\n     *     service account key and containing the provided payload.\n     */\n    createCustomToken(uid, developerClaims) {\n        let errorMessage;\n        if (!validator.isNonEmptyString(uid)) {\n            errorMessage = '`uid` argument must be a non-empty string uid.';\n        }\n        else if (uid.length > 128) {\n            errorMessage = '`uid` argument must a uid with less than or equal to 128 characters.';\n        }\n        else if (!this.isDeveloperClaimsValid_(developerClaims)) {\n            errorMessage = '`developerClaims` argument must be a valid, non-null object containing the developer claims.';\n        }\n        if (errorMessage) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);\n        }\n        const claims = {};\n        if (typeof developerClaims !== 'undefined') {\n            for (const key in developerClaims) {\n                /* istanbul ignore else */\n                if (Object.prototype.hasOwnProperty.call(developerClaims, key)) {\n                    if (exports.BLACKLISTED_CLAIMS.indexOf(key) !== -1) {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Developer claim \"${key}\" is reserved and cannot be specified.`);\n                    }\n                    claims[key] = developerClaims[key];\n                }\n            }\n        }\n        return this.signer.getAccountId().then((account) => {\n            const header = {\n                alg: this.signer.algorithm,\n                typ: 'JWT',\n            };\n            const iat = Math.floor(Date.now() / 1000);\n            const body = {\n                aud: FIREBASE_AUDIENCE,\n                iat,\n                exp: iat + ONE_HOUR_IN_SECONDS,\n                iss: account,\n                sub: account,\n                uid,\n            };\n            if (this.tenantId) {\n                body.tenant_id = this.tenantId;\n            }\n            if (Object.keys(claims).length > 0) {\n                body.claims = claims;\n            }\n            const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;\n            const signPromise = this.signer.sign(Buffer.from(token));\n            return Promise.all([token, signPromise]);\n        }).then(([token, signature]) => {\n            return `${token}.${this.encodeSegment(signature)}`;\n        }).catch((err) => {\n            throw handleCryptoSignerError(err);\n        });\n    }\n    encodeSegment(segment) {\n        const buffer = (segment instanceof Buffer) ? segment : Buffer.from(JSON.stringify(segment));\n        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, '');\n    }\n    /**\n     * Returns whether or not the provided developer claims are valid.\n     *\n     * @param developerClaims - Optional developer claims to validate.\n     * @returns True if the provided claims are valid; otherwise, false.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    isDeveloperClaimsValid_(developerClaims) {\n        if (typeof developerClaims === 'undefined') {\n            return true;\n        }\n        return validator.isNonNullObject(developerClaims);\n    }\n}\nexports.FirebaseTokenGenerator = FirebaseTokenGenerator;\n/**\n * Creates a new FirebaseAuthError by extracting the error code, message and other relevant\n * details from a CryptoSignerError.\n *\n * @param err - The Error to convert into a FirebaseAuthError error\n * @returns A Firebase Auth error that can be returned to the user.\n */\nfunction handleCryptoSignerError(err) {\n    if (!(err instanceof crypto_signer_1.CryptoSignerError)) {\n        return err;\n    }\n    if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {\n        const httpError = err.cause;\n        const errorResponse = httpError.response.data;\n        if (validator.isNonNullObject(errorResponse) && errorResponse.error) {\n            const errorCode = errorResponse.error.status;\n            const description = 'Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens ' +\n                'for more details on how to use and troubleshoot this feature.';\n            const errorMsg = `${errorResponse.error.message}; ${description}`;\n            return error_1.FirebaseAuthError.fromServerError(errorCode, errorMsg, errorResponse);\n        }\n        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Error returned from server: ' + errorResponse + '. Additionally, an ' +\n            'internal error occurred while attempting to extract the ' +\n            'errorcode from the error.');\n    }\n    return new error_1.FirebaseAuthError(mapToAuthClientErrorCode(err.code), err.message);\n}\nexports.handleCryptoSignerError = handleCryptoSignerError;\nfunction mapToAuthClientErrorCode(code) {\n    switch (code) {\n        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:\n            return error_1.AuthClientErrorCode.INVALID_CREDENTIAL;\n        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:\n            return error_1.AuthClientErrorCode.INVALID_ARGUMENT;\n        default:\n            return error_1.AuthClientErrorCode.INTERNAL_ERROR;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}