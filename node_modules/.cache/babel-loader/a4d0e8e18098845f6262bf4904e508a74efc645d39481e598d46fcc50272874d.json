{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecurityRules = exports.Ruleset = exports.RulesetMetadataList = void 0;\nconst validator = require(\"../utils/validator\");\nconst security_rules_api_client_internal_1 = require(\"./security-rules-api-client-internal\");\nconst security_rules_internal_1 = require(\"./security-rules-internal\");\n/**\n * A page of ruleset metadata.\n */\nclass RulesetMetadataList {\n  /**\n   * @internal\n   */\n  constructor(response) {\n    if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid ListRulesets response: ${JSON.stringify(response)}`);\n    }\n    this.rulesets = response.rulesets.map(rs => {\n      return {\n        name: stripProjectIdPrefix(rs.name),\n        createTime: new Date(rs.createTime).toUTCString()\n      };\n    });\n    if (response.nextPageToken) {\n      this.nextPageToken = response.nextPageToken;\n    }\n  }\n}\nexports.RulesetMetadataList = RulesetMetadataList;\n/**\n * A set of Firebase security rules.\n */\nclass Ruleset {\n  /**\n   * @internal\n   */\n  constructor(ruleset) {\n    if (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name) || !validator.isNonEmptyString(ruleset.createTime) || !validator.isNonNullObject(ruleset.source)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid Ruleset response: ${JSON.stringify(ruleset)}`);\n    }\n    this.name = stripProjectIdPrefix(ruleset.name);\n    this.createTime = new Date(ruleset.createTime).toUTCString();\n    this.source = ruleset.source.files || [];\n  }\n}\nexports.Ruleset = Ruleset;\n/**\n * The Firebase `SecurityRules` service interface.\n */\nclass SecurityRules {\n  /**\n   * @param app - The app for this SecurityRules service.\n   * @constructor\n   * @internal\n   */\n  constructor(app) {\n    this.app = app;\n    this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);\n  }\n  /**\n   * Gets the {@link Ruleset} identified by the given\n   * name. The input name should be the short name string without the project ID\n   * prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`,\n   * pass the short name \"my-ruleset\". Rejects with a `not-found` error if the\n   * specified `Ruleset` cannot be found.\n   *\n   * @param name - Name of the `Ruleset` to retrieve.\n   * @returns A promise that fulfills with the specified `Ruleset`.\n   */\n  getRuleset(name) {\n    return this.client.getRuleset(name).then(rulesetResponse => {\n      return new Ruleset(rulesetResponse);\n    });\n  }\n  /**\n   * Gets the {@link Ruleset} currently applied to\n   * Cloud Firestore. Rejects with a `not-found` error if no ruleset is applied\n   * on Firestore.\n   *\n   * @returns A promise that fulfills with the Firestore ruleset.\n   */\n  getFirestoreRuleset() {\n    return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);\n  }\n  /**\n   * Creates a new {@link Ruleset} from the given\n   * source, and applies it to Cloud Firestore.\n   *\n   * @param source - Rules source to apply.\n   * @returns A promise that fulfills when the ruleset is created and released.\n   */\n  releaseFirestoreRulesetFromSource(source) {\n    return Promise.resolve().then(() => {\n      const rulesFile = this.createRulesFileFromSource('firestore.rules', source);\n      return this.createRuleset(rulesFile);\n    }).then(ruleset => {\n      return this.releaseFirestoreRuleset(ruleset).then(() => {\n        return ruleset;\n      });\n    });\n  }\n  /**\n   * Applies the specified {@link Ruleset} ruleset\n   * to Cloud Firestore.\n   *\n   * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\n   *   containing the name.\n   * @returns A promise that fulfills when the ruleset is released.\n   */\n  releaseFirestoreRuleset(ruleset) {\n    return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);\n  }\n  /**\n   * Gets the {@link Ruleset} currently applied to a\n   * Cloud Storage bucket. Rejects with a `not-found` error if no ruleset is applied\n   * on the bucket.\n   *\n   * @param bucket - Optional name of the Cloud Storage bucket to be retrieved. If not\n   *   specified, retrieves the ruleset applied on the default bucket configured via\n   *   `AppOptions`.\n   * @returns A promise that fulfills with the Cloud Storage ruleset.\n   */\n  getStorageRuleset(bucket) {\n    return Promise.resolve().then(() => {\n      return this.getBucketName(bucket);\n    }).then(bucketName => {\n      return this.getRulesetForRelease(`${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\n    });\n  }\n  /**\n   * Creates a new {@link Ruleset} from the given\n   * source, and applies it to a Cloud Storage bucket.\n   *\n   * @param source - Rules source to apply.\n   * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\n   *   not specified, applies the ruleset on the default bucket configured via\n   *   {@link firebase-admin.app#AppOptions}.\n   * @returns A promise that fulfills when the ruleset is created and released.\n   */\n  releaseStorageRulesetFromSource(source, bucket) {\n    return Promise.resolve().then(() => {\n      // Bucket name is not required until the last step. But since there's a createRuleset step\n      // before then, make sure to run this check and fail early if the bucket name is invalid.\n      this.getBucketName(bucket);\n      const rulesFile = this.createRulesFileFromSource('storage.rules', source);\n      return this.createRuleset(rulesFile);\n    }).then(ruleset => {\n      return this.releaseStorageRuleset(ruleset, bucket).then(() => {\n        return ruleset;\n      });\n    });\n  }\n  /**\n   * Applies the specified {@link Ruleset} ruleset\n   * to a Cloud Storage bucket.\n   *\n   * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\n   *   containing the name.\n   * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\n   *   not specified, applies the ruleset on the default bucket configured via\n   *   {@link firebase-admin.app#AppOptions}.\n   * @returns A promise that fulfills when the ruleset is released.\n   */\n  releaseStorageRuleset(ruleset, bucket) {\n    return Promise.resolve().then(() => {\n      return this.getBucketName(bucket);\n    }).then(bucketName => {\n      return this.releaseRuleset(ruleset, `${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\n    });\n  }\n  /**\n   * Creates a {@link RulesFile} with the given name\n   * and source. Throws an error if any of the arguments are invalid. This is a local\n   * operation, and does not involve any network API calls.\n   *\n   * @example\n   * ```javascript\n   * const source = '// Some rules source';\n   * const rulesFile = admin.securityRules().createRulesFileFromSource(\n   *   'firestore.rules', source);\n   * ```\n   *\n   * @param name - Name to assign to the rules file. This is usually a short file name that\n   *   helps identify the file in a ruleset.\n   * @param source - Contents of the rules file.\n   * @returns A new rules file instance.\n   */\n  createRulesFileFromSource(name, source) {\n    if (!validator.isNonEmptyString(name)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');\n    }\n    let content;\n    if (validator.isNonEmptyString(source)) {\n      content = source;\n    } else if (validator.isBuffer(source)) {\n      content = source.toString('utf-8');\n    } else {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');\n    }\n    return {\n      name,\n      content\n    };\n  }\n  /**\n   * Creates a new {@link Ruleset} from the given {@link RulesFile}.\n   *\n   * @param file - Rules file to include in the new `Ruleset`.\n   * @returns A promise that fulfills with the newly created `Ruleset`.\n   */\n  createRuleset(file) {\n    const ruleset = {\n      source: {\n        files: [file]\n      }\n    };\n    return this.client.createRuleset(ruleset).then(rulesetResponse => {\n      return new Ruleset(rulesetResponse);\n    });\n  }\n  /**\n   * Deletes the {@link Ruleset} identified by the given\n   * name. The input name should be the short name string without the project ID\n   * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,\n   * pass the  short name \"my-ruleset\". Rejects with a `not-found` error if the\n   * specified `Ruleset` cannot be found.\n   *\n   * @param name - Name of the `Ruleset` to delete.\n   * @returns A promise that fulfills when the `Ruleset` is deleted.\n   */\n  deleteRuleset(name) {\n    return this.client.deleteRuleset(name);\n  }\n  /**\n   * Retrieves a page of ruleset metadata.\n   *\n   * @param pageSize - The page size, 100 if undefined. This is also the maximum allowed\n   *   limit.\n   * @param nextPageToken - The next page token. If not specified, returns rulesets\n   *   starting without any offset.\n   * @returns A promise that fulfills with a page of rulesets.\n   */\n  listRulesetMetadata() {\n    let pageSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    let nextPageToken = arguments.length > 1 ? arguments[1] : undefined;\n    return this.client.listRulesets(pageSize, nextPageToken).then(response => {\n      return new RulesetMetadataList(response);\n    });\n  }\n  getRulesetForRelease(releaseName) {\n    return this.client.getRelease(releaseName).then(release => {\n      const rulesetName = release.rulesetName;\n      if (!validator.isNonEmptyString(rulesetName)) {\n        throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', `Ruleset name not found for ${releaseName}.`);\n      }\n      return this.getRuleset(stripProjectIdPrefix(rulesetName));\n    });\n  }\n  releaseRuleset(ruleset, releaseName) {\n    if (!validator.isNonEmptyString(ruleset) && (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {\n      const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');\n      return Promise.reject(err);\n    }\n    const rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;\n    return this.client.updateOrCreateRelease(releaseName, rulesetName).then(() => {\n      return;\n    });\n  }\n  getBucketName(bucket) {\n    const bucketName = typeof bucket !== 'undefined' ? bucket : this.app.options.storageBucket;\n    if (!validator.isNonEmptyString(bucketName)) {\n      throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' + 'storageBucket option when initializing the app, or specify the bucket name ' + 'explicitly when calling the rules API.');\n    }\n    return bucketName;\n  }\n}\nexports.SecurityRules = SecurityRules;\nSecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';\nSecurityRules.FIREBASE_STORAGE = 'firebase.storage';\nfunction stripProjectIdPrefix(name) {\n  return name.split('/').pop();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","SecurityRules","Ruleset","RulesetMetadataList","validator","require","security_rules_api_client_internal_1","security_rules_internal_1","constructor","response","isNonNullObject","isArray","rulesets","FirebaseSecurityRulesError","JSON","stringify","map","rs","name","stripProjectIdPrefix","createTime","Date","toUTCString","nextPageToken","ruleset","isNonEmptyString","source","files","app","client","SecurityRulesApiClient","getRuleset","then","rulesetResponse","getFirestoreRuleset","getRulesetForRelease","CLOUD_FIRESTORE","releaseFirestoreRulesetFromSource","Promise","resolve","rulesFile","createRulesFileFromSource","createRuleset","releaseFirestoreRuleset","releaseRuleset","getStorageRuleset","bucket","getBucketName","bucketName","FIREBASE_STORAGE","releaseStorageRulesetFromSource","releaseStorageRuleset","content","isBuffer","toString","file","deleteRuleset","listRulesetMetadata","pageSize","arguments","length","undefined","listRulesets","releaseName","getRelease","release","rulesetName","err","reject","isString","updateOrCreateRelease","options","storageBucket","split","pop"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/security-rules/security-rules.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SecurityRules = exports.Ruleset = exports.RulesetMetadataList = void 0;\nconst validator = require(\"../utils/validator\");\nconst security_rules_api_client_internal_1 = require(\"./security-rules-api-client-internal\");\nconst security_rules_internal_1 = require(\"./security-rules-internal\");\n/**\n * A page of ruleset metadata.\n */\nclass RulesetMetadataList {\n    /**\n     * @internal\n     */\n    constructor(response) {\n        if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) {\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid ListRulesets response: ${JSON.stringify(response)}`);\n        }\n        this.rulesets = response.rulesets.map((rs) => {\n            return {\n                name: stripProjectIdPrefix(rs.name),\n                createTime: new Date(rs.createTime).toUTCString(),\n            };\n        });\n        if (response.nextPageToken) {\n            this.nextPageToken = response.nextPageToken;\n        }\n    }\n}\nexports.RulesetMetadataList = RulesetMetadataList;\n/**\n * A set of Firebase security rules.\n */\nclass Ruleset {\n    /**\n     * @internal\n     */\n    constructor(ruleset) {\n        if (!validator.isNonNullObject(ruleset) ||\n            !validator.isNonEmptyString(ruleset.name) ||\n            !validator.isNonEmptyString(ruleset.createTime) ||\n            !validator.isNonNullObject(ruleset.source)) {\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid Ruleset response: ${JSON.stringify(ruleset)}`);\n        }\n        this.name = stripProjectIdPrefix(ruleset.name);\n        this.createTime = new Date(ruleset.createTime).toUTCString();\n        this.source = ruleset.source.files || [];\n    }\n}\nexports.Ruleset = Ruleset;\n/**\n * The Firebase `SecurityRules` service interface.\n */\nclass SecurityRules {\n    /**\n     * @param app - The app for this SecurityRules service.\n     * @constructor\n     * @internal\n     */\n    constructor(app) {\n        this.app = app;\n        this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);\n    }\n    /**\n     * Gets the {@link Ruleset} identified by the given\n     * name. The input name should be the short name string without the project ID\n     * prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`,\n     * pass the short name \"my-ruleset\". Rejects with a `not-found` error if the\n     * specified `Ruleset` cannot be found.\n     *\n     * @param name - Name of the `Ruleset` to retrieve.\n     * @returns A promise that fulfills with the specified `Ruleset`.\n     */\n    getRuleset(name) {\n        return this.client.getRuleset(name)\n            .then((rulesetResponse) => {\n            return new Ruleset(rulesetResponse);\n        });\n    }\n    /**\n     * Gets the {@link Ruleset} currently applied to\n     * Cloud Firestore. Rejects with a `not-found` error if no ruleset is applied\n     * on Firestore.\n     *\n     * @returns A promise that fulfills with the Firestore ruleset.\n     */\n    getFirestoreRuleset() {\n        return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);\n    }\n    /**\n     * Creates a new {@link Ruleset} from the given\n     * source, and applies it to Cloud Firestore.\n     *\n     * @param source - Rules source to apply.\n     * @returns A promise that fulfills when the ruleset is created and released.\n     */\n    releaseFirestoreRulesetFromSource(source) {\n        return Promise.resolve()\n            .then(() => {\n            const rulesFile = this.createRulesFileFromSource('firestore.rules', source);\n            return this.createRuleset(rulesFile);\n        })\n            .then((ruleset) => {\n            return this.releaseFirestoreRuleset(ruleset)\n                .then(() => {\n                return ruleset;\n            });\n        });\n    }\n    /**\n     * Applies the specified {@link Ruleset} ruleset\n     * to Cloud Firestore.\n     *\n     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\n     *   containing the name.\n     * @returns A promise that fulfills when the ruleset is released.\n     */\n    releaseFirestoreRuleset(ruleset) {\n        return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);\n    }\n    /**\n     * Gets the {@link Ruleset} currently applied to a\n     * Cloud Storage bucket. Rejects with a `not-found` error if no ruleset is applied\n     * on the bucket.\n     *\n     * @param bucket - Optional name of the Cloud Storage bucket to be retrieved. If not\n     *   specified, retrieves the ruleset applied on the default bucket configured via\n     *   `AppOptions`.\n     * @returns A promise that fulfills with the Cloud Storage ruleset.\n     */\n    getStorageRuleset(bucket) {\n        return Promise.resolve()\n            .then(() => {\n            return this.getBucketName(bucket);\n        })\n            .then((bucketName) => {\n            return this.getRulesetForRelease(`${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\n        });\n    }\n    /**\n     * Creates a new {@link Ruleset} from the given\n     * source, and applies it to a Cloud Storage bucket.\n     *\n     * @param source - Rules source to apply.\n     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\n     *   not specified, applies the ruleset on the default bucket configured via\n     *   {@link firebase-admin.app#AppOptions}.\n     * @returns A promise that fulfills when the ruleset is created and released.\n     */\n    releaseStorageRulesetFromSource(source, bucket) {\n        return Promise.resolve()\n            .then(() => {\n            // Bucket name is not required until the last step. But since there's a createRuleset step\n            // before then, make sure to run this check and fail early if the bucket name is invalid.\n            this.getBucketName(bucket);\n            const rulesFile = this.createRulesFileFromSource('storage.rules', source);\n            return this.createRuleset(rulesFile);\n        })\n            .then((ruleset) => {\n            return this.releaseStorageRuleset(ruleset, bucket)\n                .then(() => {\n                return ruleset;\n            });\n        });\n    }\n    /**\n     * Applies the specified {@link Ruleset} ruleset\n     * to a Cloud Storage bucket.\n     *\n     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object\n     *   containing the name.\n     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If\n     *   not specified, applies the ruleset on the default bucket configured via\n     *   {@link firebase-admin.app#AppOptions}.\n     * @returns A promise that fulfills when the ruleset is released.\n     */\n    releaseStorageRuleset(ruleset, bucket) {\n        return Promise.resolve()\n            .then(() => {\n            return this.getBucketName(bucket);\n        })\n            .then((bucketName) => {\n            return this.releaseRuleset(ruleset, `${SecurityRules.FIREBASE_STORAGE}/${bucketName}`);\n        });\n    }\n    /**\n     * Creates a {@link RulesFile} with the given name\n     * and source. Throws an error if any of the arguments are invalid. This is a local\n     * operation, and does not involve any network API calls.\n     *\n     * @example\n     * ```javascript\n     * const source = '// Some rules source';\n     * const rulesFile = admin.securityRules().createRulesFileFromSource(\n     *   'firestore.rules', source);\n     * ```\n     *\n     * @param name - Name to assign to the rules file. This is usually a short file name that\n     *   helps identify the file in a ruleset.\n     * @param source - Contents of the rules file.\n     * @returns A new rules file instance.\n     */\n    createRulesFileFromSource(name, source) {\n        if (!validator.isNonEmptyString(name)) {\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');\n        }\n        let content;\n        if (validator.isNonEmptyString(source)) {\n            content = source;\n        }\n        else if (validator.isBuffer(source)) {\n            content = source.toString('utf-8');\n        }\n        else {\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');\n        }\n        return {\n            name,\n            content,\n        };\n    }\n    /**\n     * Creates a new {@link Ruleset} from the given {@link RulesFile}.\n     *\n     * @param file - Rules file to include in the new `Ruleset`.\n     * @returns A promise that fulfills with the newly created `Ruleset`.\n     */\n    createRuleset(file) {\n        const ruleset = {\n            source: {\n                files: [file],\n            },\n        };\n        return this.client.createRuleset(ruleset)\n            .then((rulesetResponse) => {\n            return new Ruleset(rulesetResponse);\n        });\n    }\n    /**\n     * Deletes the {@link Ruleset} identified by the given\n     * name. The input name should be the short name string without the project ID\n     * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,\n     * pass the  short name \"my-ruleset\". Rejects with a `not-found` error if the\n     * specified `Ruleset` cannot be found.\n     *\n     * @param name - Name of the `Ruleset` to delete.\n     * @returns A promise that fulfills when the `Ruleset` is deleted.\n     */\n    deleteRuleset(name) {\n        return this.client.deleteRuleset(name);\n    }\n    /**\n     * Retrieves a page of ruleset metadata.\n     *\n     * @param pageSize - The page size, 100 if undefined. This is also the maximum allowed\n     *   limit.\n     * @param nextPageToken - The next page token. If not specified, returns rulesets\n     *   starting without any offset.\n     * @returns A promise that fulfills with a page of rulesets.\n     */\n    listRulesetMetadata(pageSize = 100, nextPageToken) {\n        return this.client.listRulesets(pageSize, nextPageToken)\n            .then((response) => {\n            return new RulesetMetadataList(response);\n        });\n    }\n    getRulesetForRelease(releaseName) {\n        return this.client.getRelease(releaseName)\n            .then((release) => {\n            const rulesetName = release.rulesetName;\n            if (!validator.isNonEmptyString(rulesetName)) {\n                throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', `Ruleset name not found for ${releaseName}.`);\n            }\n            return this.getRuleset(stripProjectIdPrefix(rulesetName));\n        });\n    }\n    releaseRuleset(ruleset, releaseName) {\n        if (!validator.isNonEmptyString(ruleset) &&\n            (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) {\n            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');\n            return Promise.reject(err);\n        }\n        const rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;\n        return this.client.updateOrCreateRelease(releaseName, rulesetName)\n            .then(() => {\n            return;\n        });\n    }\n    getBucketName(bucket) {\n        const bucketName = (typeof bucket !== 'undefined') ? bucket : this.app.options.storageBucket;\n        if (!validator.isNonEmptyString(bucketName)) {\n            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' +\n                'storageBucket option when initializing the app, or specify the bucket name ' +\n                'explicitly when calling the rules API.');\n        }\n        return bucketName;\n    }\n}\nexports.SecurityRules = SecurityRules;\nSecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';\nSecurityRules.FIREBASE_STORAGE = 'firebase.storage';\nfunction stripProjectIdPrefix(name) {\n    return name.split('/').pop();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}