{"ast":null,"code":"import { inRange, decoderError, encoderError, isASCIICodePoint, end_of_stream, finished, floor } from '../utils';\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes';\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @implements {Decoder}\n */\nexport class ISO2022JPDecoder {\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n    /** @enum */\n    this.states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    this.iso2022jp_decoder_state = this.states.ASCII;\n    this.iso2022jp_decoder_output_state = this.states.ASCII, this.iso2022jp_lead = 0x00;\n    this.iso2022jp_output_flag = false;\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // switching on iso-2022-jp decoder state:\n    switch (this.iso2022jp_decoder_state) {\n      default:\n      case this.states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          this.iso2022jp_decoder_state = this.states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          this.iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        this.iso2022jp_output_flag = false;\n        return decoderError(this.fatal);\n      case this.states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          this.iso2022jp_decoder_state = this.states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5C) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          this.iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n\n        // 0x7E\n        if (bite === 0x7E) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          this.iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          this.iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        this.iso2022jp_output_flag = false;\n        return decoderError(this.fatal);\n      case this.states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          this.iso2022jp_decoder_state = this.states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5F)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          this.iso2022jp_output_flag = false;\n          return 0xFF61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        this.iso2022jp_output_flag = false;\n        return decoderError(this.fatal);\n      case this.states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          this.iso2022jp_decoder_state = this.states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          this.iso2022jp_output_flag = false;\n          this.iso2022jp_lead = bite;\n          this.iso2022jp_decoder_state = this.states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        this.iso2022jp_output_flag = false;\n        return decoderError(this.fatal);\n      case this.states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          this.iso2022jp_decoder_state = this.states.EscapeStart;\n          return decoderError(this.fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          this.iso2022jp_decoder_state = this.states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          const pointer = (this.iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          const code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null) return decoderError(this.fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          this.iso2022jp_decoder_state = this.states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(this.fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        this.iso2022jp_decoder_state = this.states.LeadByte;\n        return decoderError(this.fatal);\n      case this.states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          this.iso2022jp_lead = bite;\n          this.iso2022jp_decoder_state = this.states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        this.iso2022jp_output_flag = false;\n        this.iso2022jp_decoder_state = this.iso2022jp_decoder_output_state;\n        return decoderError(this.fatal);\n      case this.states.Escape:\n        {\n          // Escape\n\n          // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n          // 0x00.\n          const lead = this.iso2022jp_lead;\n          this.iso2022jp_lead = 0x00;\n\n          // 2. Let state be null.\n          let state = null;\n\n          // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n          if (lead === 0x28 && bite === 0x42) state = this.states.ASCII;\n\n          // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n          if (lead === 0x28 && bite === 0x4A) state = this.states.Roman;\n\n          // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n          if (lead === 0x28 && bite === 0x49) state = this.states.Katakana;\n\n          // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n          // state to lead byte.\n          if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = this.states.LeadByte;\n\n          // 7. If state is non-null, run these substeps:\n          if (state !== null) {\n            // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n            // output state to this.states.\n            this.iso2022jp_decoder_state = this.iso2022jp_decoder_state = state;\n\n            // 2. Let output flag be the iso-2022-jp output flag.\n            const output_flag = this.iso2022jp_output_flag;\n\n            // 3. Set the iso-2022-jp output flag.\n            this.iso2022jp_output_flag = true;\n\n            // 4. Return continue, if output flag is unset, and error\n            // otherwise.\n            return !output_flag ? null : decoderError(this.fatal);\n          }\n\n          // 8. Prepend lead and byte to stream.\n          stream.prepend([lead, bite]);\n\n          // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state and\n          // return error.\n          this.iso2022jp_output_flag = false;\n          this.iso2022jp_decoder_state = this.iso2022jp_decoder_output_state;\n          return decoderError(this.fatal);\n        }\n    }\n  }\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @implements {Encoder}\n */\nexport class ISO2022JPEncoder {\n  constructor() {\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    this.states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    this.iso2022jp_state = this.states.ASCII;\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream and iso-2022-jp encoder\n    // state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream && this.iso2022jp_state !== this.states.ASCII) {\n      stream.prepend(code_point);\n      this.iso2022jp_state = this.states.ASCII;\n      return [0x1B, 0x28, 0x42];\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && this.iso2022jp_state === this.states.ASCII) return finished;\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if ((this.iso2022jp_state === this.states.ASCII || this.iso2022jp_state === this.states.Roman) && (code_point === 0x000E || code_point === 0x000F || code_point === 0x001B)) {\n      return encoderError(0xFFFD);\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (this.iso2022jp_state === this.states.ASCII && isASCIICodePoint(code_point)) return code_point;\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (this.iso2022jp_state === this.states.Roman && (isASCIICodePoint(code_point) && code_point !== 0x005C && code_point !== 0x007E || code_point == 0x00A5 || code_point == 0x203E)) {\n      // 1. If code point is an ASCII code point, return a byte\n      // whose value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5) return 0x5C;\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E) return 0x7E;\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) && this.iso2022jp_state !== this.states.ASCII) {\n      stream.prepend(code_point);\n      this.iso2022jp_state = this.states.ASCII;\n      return [0x1B, 0x28, 0x42];\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00A5 || code_point === 0x203E) && this.iso2022jp_state !== this.states.Roman) {\n      stream.prepend(code_point);\n      this.iso2022jp_state = this.states.Roman;\n      return [0x1B, 0x28, 0x4A];\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xFF0D;\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    const pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (this.iso2022jp_state !== this.states.jis0208) {\n      stream.prepend(code_point);\n      this.iso2022jp_state = this.states.jis0208;\n      return [0x1B, 0x24, 0x42];\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    const lead = floor(pointer / 94) + 0x21;\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    const trail = pointer % 94 + 0x21;\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  }\n}","map":{"version":3,"names":["inRange","decoderError","encoderError","isASCIICodePoint","end_of_stream","finished","floor","index","indexCodePointFor","indexPointerFor","ISO2022JPDecoder","constructor","options","fatal","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","handler","stream","bite","pointer","code_point","prepend","lead","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","trail"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/iso-2022-jp.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, floor } from '../utils'\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes'\n\n// 13.2 iso-2022-jp\n\n// 13.2.1 iso-2022-jp decoder\n/**\n * @implements {Decoder}\n */\nexport class ISO2022JPDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    /** @enum */\n    this.states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6,\n    }\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    this.iso2022jp_decoder_state = this.states.ASCII\n    this.iso2022jp_decoder_output_state = this.states.ASCII,\n    this.iso2022jp_lead = 0x00\n    this.iso2022jp_output_flag = false\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // switching on iso-2022-jp decoder state:\n    switch (this.iso2022jp_decoder_state) {\n    default:\n    case this.states.ASCII:\n    // ASCII\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n      if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n        && bite !== 0x0F && bite !== 0x1B) {\n      // Unset the iso-2022-jp output flag and return a code point\n      // whose value is byte.\n        this.iso2022jp_output_flag = false\n        return bite\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.Roman:\n    // Roman\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x5C\n      if (bite === 0x5C) {\n      // Unset the iso-2022-jp output flag and return code point\n      // U+00A5.\n        this.iso2022jp_output_flag = false\n        return 0x00A5\n      }\n\n      // 0x7E\n      if (bite === 0x7E) {\n      // Unset the iso-2022-jp output flag and return code point\n      // U+203E.\n        this.iso2022jp_output_flag = false\n        return 0x203E\n      }\n\n      // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n      if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n        && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n      // Unset the iso-2022-jp output flag and return a code point\n      // whose value is byte.\n        this.iso2022jp_output_flag = false\n        return bite\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.Katakana:\n    // Katakana\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x21 to 0x5F\n      if (inRange(bite, 0x21, 0x5F)) {\n      // Unset the iso-2022-jp output flag and return a code point\n      // whose value is 0xFF61 − 0x21 + byte.\n        this.iso2022jp_output_flag = false\n        return 0xFF61 - 0x21 + bite\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.LeadByte:\n    // Lead byte\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return null\n      }\n\n      // 0x21 to 0x7E\n      if (inRange(bite, 0x21, 0x7E)) {\n      // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n      // to byte, iso-2022-jp decoder state to trail byte, and\n      // return continue.\n        this.iso2022jp_output_flag = false\n        this.iso2022jp_lead = bite\n        this.iso2022jp_decoder_state = this.states.TrailByte\n        return null\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Return finished.\n        return finished\n      }\n\n      // Otherwise\n      // Unset the iso-2022-jp output flag and return error.\n      this.iso2022jp_output_flag = false\n      return decoderError(this.fatal)\n\n    case this.states.TrailByte:\n    // Trail byte\n    // Based on byte:\n\n      // 0x1B\n      if (bite === 0x1B) {\n      // Set iso-2022-jp decoder state to escape start and return\n      // continue.\n        this.iso2022jp_decoder_state = this.states.EscapeStart\n        return decoderError(this.fatal)\n      }\n\n      // 0x21 to 0x7E\n      if (inRange(bite, 0x21, 0x7E)) {\n      // 1. Set the iso-2022-jp decoder state to lead byte.\n        this.iso2022jp_decoder_state = this.states.LeadByte\n\n        // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n        const pointer = (this.iso2022jp_lead - 0x21) * 94 + bite - 0x21\n\n        // 3. Let code point be the index code point for pointer in\n        // index jis0208.\n        const code_point = indexCodePointFor(pointer, index('jis0208'))\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(this.fatal)\n\n        // 5. Return a code point whose value is code point.\n        return code_point\n      }\n\n      // end-of-stream\n      if (bite === end_of_stream) {\n      // Set the iso-2022-jp decoder state to lead byte, prepend\n      // byte to stream, and return error.\n        this.iso2022jp_decoder_state = this.states.LeadByte\n        stream.prepend(bite)\n        return decoderError(this.fatal)\n      }\n\n      // Otherwise\n      // Set iso-2022-jp decoder state to lead byte and return\n      // error.\n      this.iso2022jp_decoder_state = this.states.LeadByte\n      return decoderError(this.fatal)\n\n    case this.states.EscapeStart:\n    // Escape start\n\n      // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n      // byte, iso-2022-jp decoder state to escape, and return\n      // continue.\n      if (bite === 0x24 || bite === 0x28) {\n        this.iso2022jp_lead = bite\n        this.iso2022jp_decoder_state = this.states.Escape\n        return null\n      }\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite)\n\n      // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n      // decoder state to iso-2022-jp decoder output state, and\n      // return error.\n      this.iso2022jp_output_flag = false\n      this.iso2022jp_decoder_state = this.iso2022jp_decoder_output_state\n      return decoderError(this.fatal)\n\n    case this.states.Escape: {\n    // Escape\n\n      // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n      // 0x00.\n      const lead = this.iso2022jp_lead\n      this.iso2022jp_lead = 0x00\n\n      // 2. Let state be null.\n      let state = null\n\n      // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n      if (lead === 0x28 && bite === 0x42)\n        state = this.states.ASCII\n\n      // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n      if (lead === 0x28 && bite === 0x4A)\n        state = this.states.Roman\n\n      // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n      if (lead === 0x28 && bite === 0x49)\n        state = this.states.Katakana\n\n      // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n      // state to lead byte.\n      if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n        state = this.states.LeadByte\n\n      // 7. If state is non-null, run these substeps:\n      if (state !== null) {\n      // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n      // output state to this.states.\n        this.iso2022jp_decoder_state = this.iso2022jp_decoder_state = state\n\n        // 2. Let output flag be the iso-2022-jp output flag.\n        const output_flag = this.iso2022jp_output_flag\n\n        // 3. Set the iso-2022-jp output flag.\n        this.iso2022jp_output_flag = true\n\n        // 4. Return continue, if output flag is unset, and error\n        // otherwise.\n        return !output_flag ? null : decoderError(this.fatal)\n      }\n\n      // 8. Prepend lead and byte to stream.\n      stream.prepend([lead, bite])\n\n      // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n      // decoder state to iso-2022-jp decoder output state and\n      // return error.\n      this.iso2022jp_output_flag = false\n      this.iso2022jp_decoder_state = this.iso2022jp_decoder_output_state\n      return decoderError(this.fatal)\n    }\n    }\n  }\n}\n\n// 13.2.2 iso-2022-jp encoder\n/**\n * @implements {Encoder}\n */\nexport class ISO2022JPEncoder {\n  constructor() {\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    this.states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2,\n    }\n    this.iso2022jp_state = this.states.ASCII\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream and iso-2022-jp encoder\n  // state is not ASCII, prepend code point to stream, set\n  // iso-2022-jp encoder state to ASCII, and return three bytes\n  // 0x1B 0x28 0x42.\n    if (code_point === end_of_stream &&\n      this.iso2022jp_state !== this.states.ASCII) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.ASCII\n      return [0x1B, 0x28, 0x42]\n    }\n\n    // 2. If code point is end-of-stream and iso-2022-jp encoder\n    // state is ASCII, return finished.\n    if (code_point === end_of_stream && this.iso2022jp_state === this.states.ASCII)\n      return finished\n\n    // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n    // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n    if ((this.iso2022jp_state === this.states.ASCII ||\n        this.iso2022jp_state === this.states.Roman) &&\n      (code_point === 0x000E || code_point === 0x000F ||\n        code_point === 0x001B)) {\n      return encoderError(0xFFFD)\n    }\n\n    // 4. If iso-2022-jp encoder state is ASCII and code point is an\n    // ASCII code point, return a byte whose value is code point.\n    if (this.iso2022jp_state === this.states.ASCII &&\n      isASCIICodePoint(code_point))\n      return code_point\n\n    // 5. If iso-2022-jp encoder state is Roman and code point is an\n    // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n    // or U+203E, run these substeps:\n    if (this.iso2022jp_state === this.states.Roman &&\n      ((isASCIICodePoint(code_point) &&\n        code_point !== 0x005C && code_point !== 0x007E) ||\n      (code_point == 0x00A5 || code_point == 0x203E))) {\n    // 1. If code point is an ASCII code point, return a byte\n    // whose value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point\n\n      // 2. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C\n\n      // 3. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E\n    }\n\n    // 6. If code point is an ASCII code point, and iso-2022-jp\n    // encoder state is not ASCII, prepend code point to stream, set\n    // iso-2022-jp encoder state to ASCII, and return three bytes\n    // 0x1B 0x28 0x42.\n    if (isASCIICodePoint(code_point) &&\n      this.iso2022jp_state !== this.states.ASCII) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.ASCII\n      return [0x1B, 0x28, 0x42]\n    }\n\n    // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n    // encoder state is not Roman, prepend code point to stream, set\n    // iso-2022-jp encoder state to Roman, and return three bytes\n    // 0x1B 0x28 0x4A.\n    if ((code_point === 0x00A5 || code_point === 0x203E) &&\n      this.iso2022jp_state !== this.states.Roman) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.Roman\n      return [0x1B, 0x28, 0x4A]\n    }\n\n    // 8. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212)\n      code_point = 0xFF0D\n\n    // 9. Let pointer be the index pointer for code point in index\n    // jis0208.\n    const pointer = indexPointerFor(code_point, index('jis0208'))\n\n    // 10. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n    // point to stream, set iso-2022-jp encoder state to jis0208,\n    // and return three bytes 0x1B 0x24 0x42.\n    if (this.iso2022jp_state !== this.states.jis0208) {\n      stream.prepend(code_point)\n      this.iso2022jp_state = this.states.jis0208\n      return [0x1B, 0x24, 0x42]\n    }\n\n    // 12. Let lead be floor(pointer / 94) + 0x21.\n    const lead = floor(pointer / 94) + 0x21\n\n    // 13. Let trail be pointer % 94 + 0x21.\n    const trail = pointer % 94 + 0x21\n\n    // 14. Return two bytes whose values are lead and trail.\n    return [lead, trail]\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}