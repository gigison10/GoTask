{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DatabaseService = void 0;\nconst url_1 = require(\"url\");\nconst path = require(\"path\");\nconst error_1 = require(\"../utils/error\");\nconst validator = require(\"../utils/validator\");\nconst api_request_1 = require(\"../utils/api-request\");\nconst index_1 = require(\"../utils/index\");\nconst TOKEN_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;\nclass DatabaseService {\n  constructor(app) {\n    this.databases = {};\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new error_1.FirebaseDatabaseError({\n        code: 'invalid-argument',\n        message: 'First argument passed to admin.database() must be a valid Firebase app instance.'\n      });\n    }\n    this.appInternal = app;\n  }\n  get firebaseApp() {\n    return this.app;\n  }\n  /**\n   * @internal\n   */\n  delete() {\n    if (this.tokenListener) {\n      this.firebaseApp.INTERNAL.removeAuthTokenListener(this.tokenListener);\n      clearTimeout(this.tokenRefreshTimeout);\n    }\n    const promises = [];\n    for (const dbUrl of Object.keys(this.databases)) {\n      const db = this.databases[dbUrl];\n      promises.push(db.INTERNAL.delete());\n    }\n    return Promise.all(promises).then(() => {\n      this.databases = {};\n    });\n  }\n  /**\n   * Returns the app associated with this DatabaseService instance.\n   *\n   * @returns The app associated with this DatabaseService instance.\n   */\n  get app() {\n    return this.appInternal;\n  }\n  getDatabase(url) {\n    const dbUrl = this.ensureUrl(url);\n    if (!validator.isNonEmptyString(dbUrl)) {\n      throw new error_1.FirebaseDatabaseError({\n        code: 'invalid-argument',\n        message: 'Database URL must be a valid, non-empty URL string.'\n      });\n    }\n    let db = this.databases[dbUrl];\n    if (typeof db === 'undefined') {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const rtdb = require('@firebase/database-compat/standalone');\n      db = rtdb.initStandalone(this.appInternal, dbUrl, (0, index_1.getSdkVersion)()).instance;\n      const rulesClient = new DatabaseRulesClient(this.app, dbUrl);\n      db.getRules = () => {\n        return rulesClient.getRules();\n      };\n      db.getRulesJSON = () => {\n        return rulesClient.getRulesJSON();\n      };\n      db.setRules = source => {\n        return rulesClient.setRules(source);\n      };\n      this.databases[dbUrl] = db;\n    }\n    if (!this.tokenListener) {\n      this.tokenListener = this.onTokenChange.bind(this);\n      this.firebaseApp.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n    return db;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onTokenChange(_) {\n    const token = this.firebaseApp.INTERNAL.getCachedToken();\n    if (token) {\n      const delayMillis = token.expirationTime - TOKEN_REFRESH_THRESHOLD_MILLIS - Date.now();\n      // If the new token is set to expire soon (unlikely), do nothing. Somebody will eventually\n      // notice and refresh the token, at which point this callback will fire again.\n      if (delayMillis > 0) {\n        this.scheduleTokenRefresh(delayMillis);\n      }\n    }\n  }\n  scheduleTokenRefresh(delayMillis) {\n    clearTimeout(this.tokenRefreshTimeout);\n    this.tokenRefreshTimeout = setTimeout(() => {\n      this.firebaseApp.INTERNAL.getToken( /*forceRefresh=*/true).catch(() => {\n        // Ignore the error since this might just be an intermittent failure. If we really cannot\n        // refresh the token, an error will be logged once the existing token expires and we try\n        // to fetch a fresh one.\n      });\n    }, delayMillis);\n  }\n  ensureUrl(url) {\n    if (typeof url !== 'undefined') {\n      return url;\n    } else if (typeof this.appInternal.options.databaseURL !== 'undefined') {\n      return this.appInternal.options.databaseURL;\n    }\n    throw new error_1.FirebaseDatabaseError({\n      code: 'invalid-argument',\n      message: 'Can\\'t determine Firebase Database URL.'\n    });\n  }\n}\nexports.DatabaseService = DatabaseService;\nconst RULES_URL_PATH = '.settings/rules.json';\n/**\n * A helper client for managing RTDB security rules.\n */\nclass DatabaseRulesClient {\n  constructor(app, dbUrl) {\n    let parsedUrl = new url_1.URL(dbUrl);\n    const emulatorHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;\n    if (emulatorHost) {\n      const namespace = extractNamespace(parsedUrl);\n      parsedUrl = new url_1.URL(`http://${emulatorHost}?ns=${namespace}`);\n    }\n    parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);\n    this.dbUrl = parsedUrl.toString();\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n  /**\n   * Gets the currently applied security rules as a string. The return value consists of\n   * the rules source including comments.\n   *\n   * @returns A promise fulfilled with the rules as a raw string.\n   */\n  getRules() {\n    const req = {\n      method: 'GET',\n      url: this.dbUrl\n    };\n    return this.httpClient.send(req).then(resp => {\n      if (!resp.text) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n      }\n      return resp.text;\n    }).catch(err => {\n      throw this.handleError(err);\n    });\n  }\n  /**\n   * Gets the currently applied security rules as a parsed JSON object. Any comments in\n   * the original source are stripped away.\n   *\n   * @returns {Promise<object>} A promise fulfilled with the parsed rules source.\n   */\n  getRulesJSON() {\n    const req = {\n      method: 'GET',\n      url: this.dbUrl,\n      data: {\n        format: 'strict'\n      }\n    };\n    return this.httpClient.send(req).then(resp => {\n      return resp.data;\n    }).catch(err => {\n      throw this.handleError(err);\n    });\n  }\n  /**\n   * Sets the specified rules on the Firebase Database instance. If the rules source is\n   * specified as a string or a Buffer, it may include comments.\n   *\n   * @param {string|Buffer|object} source Source of the rules to apply. Must not be `null`\n   *  or empty.\n   * @returns {Promise<void>} Resolves when the rules are set on the Database.\n   */\n  setRules(source) {\n    if (!validator.isNonEmptyString(source) && !validator.isBuffer(source) && !validator.isNonNullObject(source)) {\n      const error = new error_1.FirebaseDatabaseError({\n        code: 'invalid-argument',\n        message: 'Source must be a non-empty string, Buffer or an object.'\n      });\n      return Promise.reject(error);\n    }\n    const req = {\n      method: 'PUT',\n      url: this.dbUrl,\n      data: source,\n      headers: {\n        'content-type': 'application/json; charset=utf-8'\n      }\n    };\n    return this.httpClient.send(req).then(() => {\n      return;\n    }).catch(err => {\n      throw this.handleError(err);\n    });\n  }\n  handleError(err) {\n    if (err instanceof api_request_1.HttpError) {\n      return new error_1.FirebaseDatabaseError({\n        code: error_1.AppErrorCodes.INTERNAL_ERROR,\n        message: this.getErrorMessage(err)\n      });\n    }\n    return err;\n  }\n  getErrorMessage(err) {\n    const intro = 'Error while accessing security rules';\n    try {\n      const body = err.response.data;\n      if (body && body.error) {\n        return `${intro}: ${body.error.trim()}`;\n      }\n    } catch {\n      // Ignore parsing errors\n    }\n    return `${intro}: ${err.response.text}`;\n  }\n}\nfunction extractNamespace(parsedUrl) {\n  const ns = parsedUrl.searchParams.get('ns');\n  if (ns) {\n    return ns;\n  }\n  const hostname = parsedUrl.hostname;\n  const dotIndex = hostname.indexOf('.');\n  return hostname.substring(0, dotIndex).toLowerCase();\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","DatabaseService","url_1","require","path","error_1","validator","api_request_1","index_1","TOKEN_REFRESH_THRESHOLD_MILLIS","constructor","app","databases","isNonNullObject","FirebaseDatabaseError","code","message","appInternal","firebaseApp","delete","tokenListener","INTERNAL","removeAuthTokenListener","clearTimeout","tokenRefreshTimeout","promises","dbUrl","keys","db","push","Promise","all","then","getDatabase","url","ensureUrl","isNonEmptyString","rtdb","initStandalone","getSdkVersion","instance","rulesClient","DatabaseRulesClient","getRules","getRulesJSON","setRules","source","onTokenChange","bind","addAuthTokenListener","_","token","getCachedToken","delayMillis","expirationTime","Date","now","scheduleTokenRefresh","setTimeout","getToken","catch","options","databaseURL","RULES_URL_PATH","parsedUrl","URL","emulatorHost","process","env","FIREBASE_DATABASE_EMULATOR_HOST","namespace","extractNamespace","pathname","join","toString","httpClient","AuthorizedHttpClient","req","method","send","resp","text","FirebaseAppError","AppErrorCodes","INTERNAL_ERROR","err","handleError","data","format","isBuffer","error","reject","headers","HttpError","getErrorMessage","intro","body","response","trim","ns","searchParams","get","hostname","dotIndex","indexOf","substring","toLowerCase"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/database/database.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DatabaseService = void 0;\nconst url_1 = require(\"url\");\nconst path = require(\"path\");\nconst error_1 = require(\"../utils/error\");\nconst validator = require(\"../utils/validator\");\nconst api_request_1 = require(\"../utils/api-request\");\nconst index_1 = require(\"../utils/index\");\nconst TOKEN_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;\nclass DatabaseService {\n    constructor(app) {\n        this.databases = {};\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseDatabaseError({\n                code: 'invalid-argument',\n                message: 'First argument passed to admin.database() must be a valid Firebase app instance.',\n            });\n        }\n        this.appInternal = app;\n    }\n    get firebaseApp() {\n        return this.app;\n    }\n    /**\n     * @internal\n     */\n    delete() {\n        if (this.tokenListener) {\n            this.firebaseApp.INTERNAL.removeAuthTokenListener(this.tokenListener);\n            clearTimeout(this.tokenRefreshTimeout);\n        }\n        const promises = [];\n        for (const dbUrl of Object.keys(this.databases)) {\n            const db = this.databases[dbUrl];\n            promises.push(db.INTERNAL.delete());\n        }\n        return Promise.all(promises).then(() => {\n            this.databases = {};\n        });\n    }\n    /**\n     * Returns the app associated with this DatabaseService instance.\n     *\n     * @returns The app associated with this DatabaseService instance.\n     */\n    get app() {\n        return this.appInternal;\n    }\n    getDatabase(url) {\n        const dbUrl = this.ensureUrl(url);\n        if (!validator.isNonEmptyString(dbUrl)) {\n            throw new error_1.FirebaseDatabaseError({\n                code: 'invalid-argument',\n                message: 'Database URL must be a valid, non-empty URL string.',\n            });\n        }\n        let db = this.databases[dbUrl];\n        if (typeof db === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const rtdb = require('@firebase/database-compat/standalone');\n            db = rtdb.initStandalone(this.appInternal, dbUrl, (0, index_1.getSdkVersion)()).instance;\n            const rulesClient = new DatabaseRulesClient(this.app, dbUrl);\n            db.getRules = () => {\n                return rulesClient.getRules();\n            };\n            db.getRulesJSON = () => {\n                return rulesClient.getRulesJSON();\n            };\n            db.setRules = (source) => {\n                return rulesClient.setRules(source);\n            };\n            this.databases[dbUrl] = db;\n        }\n        if (!this.tokenListener) {\n            this.tokenListener = this.onTokenChange.bind(this);\n            this.firebaseApp.INTERNAL.addAuthTokenListener(this.tokenListener);\n        }\n        return db;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTokenChange(_) {\n        const token = this.firebaseApp.INTERNAL.getCachedToken();\n        if (token) {\n            const delayMillis = token.expirationTime - TOKEN_REFRESH_THRESHOLD_MILLIS - Date.now();\n            // If the new token is set to expire soon (unlikely), do nothing. Somebody will eventually\n            // notice and refresh the token, at which point this callback will fire again.\n            if (delayMillis > 0) {\n                this.scheduleTokenRefresh(delayMillis);\n            }\n        }\n    }\n    scheduleTokenRefresh(delayMillis) {\n        clearTimeout(this.tokenRefreshTimeout);\n        this.tokenRefreshTimeout = setTimeout(() => {\n            this.firebaseApp.INTERNAL.getToken(/*forceRefresh=*/ true)\n                .catch(() => {\n                // Ignore the error since this might just be an intermittent failure. If we really cannot\n                // refresh the token, an error will be logged once the existing token expires and we try\n                // to fetch a fresh one.\n            });\n        }, delayMillis);\n    }\n    ensureUrl(url) {\n        if (typeof url !== 'undefined') {\n            return url;\n        }\n        else if (typeof this.appInternal.options.databaseURL !== 'undefined') {\n            return this.appInternal.options.databaseURL;\n        }\n        throw new error_1.FirebaseDatabaseError({\n            code: 'invalid-argument',\n            message: 'Can\\'t determine Firebase Database URL.',\n        });\n    }\n}\nexports.DatabaseService = DatabaseService;\nconst RULES_URL_PATH = '.settings/rules.json';\n/**\n * A helper client for managing RTDB security rules.\n */\nclass DatabaseRulesClient {\n    constructor(app, dbUrl) {\n        let parsedUrl = new url_1.URL(dbUrl);\n        const emulatorHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;\n        if (emulatorHost) {\n            const namespace = extractNamespace(parsedUrl);\n            parsedUrl = new url_1.URL(`http://${emulatorHost}?ns=${namespace}`);\n        }\n        parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);\n        this.dbUrl = parsedUrl.toString();\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    /**\n     * Gets the currently applied security rules as a string. The return value consists of\n     * the rules source including comments.\n     *\n     * @returns A promise fulfilled with the rules as a raw string.\n     */\n    getRules() {\n        const req = {\n            method: 'GET',\n            url: this.dbUrl,\n        };\n        return this.httpClient.send(req)\n            .then((resp) => {\n            if (!resp.text) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n            }\n            return resp.text;\n        })\n            .catch((err) => {\n            throw this.handleError(err);\n        });\n    }\n    /**\n     * Gets the currently applied security rules as a parsed JSON object. Any comments in\n     * the original source are stripped away.\n     *\n     * @returns {Promise<object>} A promise fulfilled with the parsed rules source.\n     */\n    getRulesJSON() {\n        const req = {\n            method: 'GET',\n            url: this.dbUrl,\n            data: { format: 'strict' },\n        };\n        return this.httpClient.send(req)\n            .then((resp) => {\n            return resp.data;\n        })\n            .catch((err) => {\n            throw this.handleError(err);\n        });\n    }\n    /**\n     * Sets the specified rules on the Firebase Database instance. If the rules source is\n     * specified as a string or a Buffer, it may include comments.\n     *\n     * @param {string|Buffer|object} source Source of the rules to apply. Must not be `null`\n     *  or empty.\n     * @returns {Promise<void>} Resolves when the rules are set on the Database.\n     */\n    setRules(source) {\n        if (!validator.isNonEmptyString(source) &&\n            !validator.isBuffer(source) &&\n            !validator.isNonNullObject(source)) {\n            const error = new error_1.FirebaseDatabaseError({\n                code: 'invalid-argument',\n                message: 'Source must be a non-empty string, Buffer or an object.',\n            });\n            return Promise.reject(error);\n        }\n        const req = {\n            method: 'PUT',\n            url: this.dbUrl,\n            data: source,\n            headers: {\n                'content-type': 'application/json; charset=utf-8',\n            },\n        };\n        return this.httpClient.send(req)\n            .then(() => {\n            return;\n        })\n            .catch((err) => {\n            throw this.handleError(err);\n        });\n    }\n    handleError(err) {\n        if (err instanceof api_request_1.HttpError) {\n            return new error_1.FirebaseDatabaseError({\n                code: error_1.AppErrorCodes.INTERNAL_ERROR,\n                message: this.getErrorMessage(err),\n            });\n        }\n        return err;\n    }\n    getErrorMessage(err) {\n        const intro = 'Error while accessing security rules';\n        try {\n            const body = err.response.data;\n            if (body && body.error) {\n                return `${intro}: ${body.error.trim()}`;\n            }\n        }\n        catch {\n            // Ignore parsing errors\n        }\n        return `${intro}: ${err.response.text}`;\n    }\n}\nfunction extractNamespace(parsedUrl) {\n    const ns = parsedUrl.searchParams.get('ns');\n    if (ns) {\n        return ns;\n    }\n    const hostname = parsedUrl.hostname;\n    const dotIndex = hostname.indexOf('.');\n    return hostname.substring(0, dotIndex).toLowerCase();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}