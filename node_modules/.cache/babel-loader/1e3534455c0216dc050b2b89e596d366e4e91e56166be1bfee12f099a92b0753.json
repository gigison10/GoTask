{"ast":null,"code":"import { end_of_stream } from '../utils';\nimport { label_to_encoding } from '../table';\nexport default class Stream {\n  /**\n   * A stream represents an ordered sequence of tokens.\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  constructor(tokens) {\n    this.tokens = [...tokens];\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n  /**\n   * @returns True if end-of-stream has been hit.\n   */\n  endOfStream() {\n    return !this.tokens.length;\n  }\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return Get the next token from the stream, or end_of_stream.\n   */\n  read() {\n    if (!this.tokens.length) return end_of_stream;\n    return this.tokens.pop();\n  }\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/token;\n      while (tokens.length) this.tokens.push(tokens.pop());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push(token) {\n    if (Array.isArray(token)) {\n      const tokens = /**@type {!Array.<number>}*/token;\n      while (tokens.length) this.tokens.unshift(tokens.shift());\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n}\nexport const DEFAULT_ENCODING = 'utf-8';\n\n/**\n * Returns the encoding for the label.\n * @param {string} label The encoding label.\n */\nexport function getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label).trim().toLowerCase();\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label];\n  }\n  return null;\n}\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n// /** @interface */\n// function Decoder() {}\n// Decoder.prototype = {\n//   /**\n//    * @param {Stream} stream The stream of bytes being decoded.\n//    * @param {number} bite The next byte read from the stream.\n//    * @return {?(number|!Array.<number>)} The next code point(s)\n//    *     decoded, or null if not enough data exists in the input\n//    *     stream to decode a complete code point, or |finished|.\n//    */\n//   handler: function(stream, bite) {},\n// }\n\n// /** @interface */\n// function Encoder() {}\n// Encoder.prototype = {\n//   /**\n//    * @param {Stream} stream The stream of code points being encoded.\n//    * @param {number} code_point Next code point read from the stream.\n//    * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n//    */\n//   handler: function(stream, code_point) {},\n// }","map":{"version":3,"names":["end_of_stream","label_to_encoding","Stream","constructor","tokens","reverse","endOfStream","length","read","pop","prepend","token","Array","isArray","push","unshift","shift","DEFAULT_ENCODING","getEncoding","label","String","trim","toLowerCase","Object","prototype","hasOwnProperty","call"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/lib/index.js"],"sourcesContent":["import { end_of_stream } from '../utils'\nimport { label_to_encoding } from '../table'\n\nexport default class Stream {\n  /**\n   * A stream represents an ordered sequence of tokens.\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  constructor(tokens) {\n    this.tokens = [...tokens]\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse()\n  }\n  /**\n   * @returns True if end-of-stream has been hit.\n   */\n  endOfStream() {\n    return !this.tokens.length\n  }\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return Get the next token from the stream, or end_of_stream.\n   */\n  read() {\n    if (!this.tokens.length)\n      return end_of_stream\n    return this.tokens.pop()\n  }\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n   * stream.\n   */\n  prepend(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token)\n      while (tokens.length)\n        this.tokens.push(tokens.pop())\n    } else {\n      this.tokens.push(token)\n    }\n  }\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n   * stream.\n   */\n  push(token) {\n    if (Array.isArray(token)) {\n      const tokens = /**@type {!Array.<number>}*/(token)\n      while (tokens.length)\n        this.tokens.unshift(tokens.shift())\n    } else {\n      this.tokens.unshift(token)\n    }\n  }\n}\n\nexport const DEFAULT_ENCODING = 'utf-8'\n\n\n/**\n * Returns the encoding for the label.\n * @param {string} label The encoding label.\n */\nexport function getEncoding(label) {\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  label = String(label).trim().toLowerCase()\n\n  // 2. If label is an ASCII case-insensitive match for any of the\n  // labels listed in the table below, return the corresponding\n  // encoding, and failure otherwise.\n  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n    return label_to_encoding[label]\n  }\n  return null\n}\n\n\n//\n// 5. Encodings\n//\n\n// 5.1 Encoders and decoders\n\n// /** @interface */\n// function Decoder() {}\n// Decoder.prototype = {\n//   /**\n//    * @param {Stream} stream The stream of bytes being decoded.\n//    * @param {number} bite The next byte read from the stream.\n//    * @return {?(number|!Array.<number>)} The next code point(s)\n//    *     decoded, or null if not enough data exists in the input\n//    *     stream to decode a complete code point, or |finished|.\n//    */\n//   handler: function(stream, bite) {},\n// }\n\n// /** @interface */\n// function Encoder() {}\n// Encoder.prototype = {\n//   /**\n//    * @param {Stream} stream The stream of code points being encoded.\n//    * @param {number} code_point Next code point read from the stream.\n//    * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n//    */\n//   handler: function(stream, code_point) {},\n// }"],"mappings":"AAAA,SAASA,aAAa,QAAQ,UAAU;AACxC,SAASC,iBAAiB,QAAQ,UAAU;AAE5C,eAAe,MAAMC,MAAM,CAAC;EAC1B;AACF;AACA;AACA;AACA;EACEC,WAAWA,CAACC,MAAM,EAAE;IAClB,IAAI,CAACA,MAAM,GAAG,CAAC,GAAGA,MAAM,CAAC;IACzB;IACA,IAAI,CAACA,MAAM,CAACC,OAAO,CAAC,CAAC;EACvB;EACA;AACF;AACA;EACEC,WAAWA,CAAA,EAAG;IACZ,OAAO,CAAC,IAAI,CAACF,MAAM,CAACG,MAAM;EAC5B;EACA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,IAAIA,CAAA,EAAG;IACL,IAAI,CAAC,IAAI,CAACJ,MAAM,CAACG,MAAM,EACrB,OAAOP,aAAa;IACtB,OAAO,IAAI,CAACI,MAAM,CAACK,GAAG,CAAC,CAAC;EAC1B;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAACC,KAAK,EAAE;IACb,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACxB,IAAIP,MAAM,GAAG,4BAA6BO,KAAM;MAChD,OAAOP,MAAM,CAACG,MAAM,EAClB,IAAI,CAACH,MAAM,CAACU,IAAI,CAACV,MAAM,CAACK,GAAG,CAAC,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,IAAI,CAACL,MAAM,CAACU,IAAI,CAACH,KAAK,CAAC;IACzB;EACF;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEG,IAAIA,CAACH,KAAK,EAAE;IACV,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACxB,MAAMP,MAAM,GAAG,4BAA6BO,KAAM;MAClD,OAAOP,MAAM,CAACG,MAAM,EAClB,IAAI,CAACH,MAAM,CAACW,OAAO,CAACX,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC;IACvC,CAAC,MAAM;MACL,IAAI,CAACZ,MAAM,CAACW,OAAO,CAACJ,KAAK,CAAC;IAC5B;EACF;AACF;AAEA,OAAO,MAAMM,gBAAgB,GAAG,OAAO;;AAGvC;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EACjC;EACAA,KAAK,GAAGC,MAAM,CAACD,KAAK,CAAC,CAACE,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;;EAE1C;EACA;EACA;EACA,IAAIC,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACzB,iBAAiB,EAAEkB,KAAK,CAAC,EAAE;IAClE,OAAOlB,iBAAiB,CAACkB,KAAK,CAAC;EACjC;EACA,OAAO,IAAI;AACb;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}