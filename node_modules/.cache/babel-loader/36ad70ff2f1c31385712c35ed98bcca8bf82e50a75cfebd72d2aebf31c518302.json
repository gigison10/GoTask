{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FIREBASE_CONFIG_VAR = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = exports.defaultAppStore = exports.AppStore = void 0;\nconst fs = require(\"fs\");\nconst validator = require(\"../utils/validator\");\nconst error_1 = require(\"../utils/error\");\nconst credential_internal_1 = require(\"./credential-internal\");\nconst firebase_app_1 = require(\"./firebase-app\");\nconst DEFAULT_APP_NAME = '[DEFAULT]';\nclass AppStore {\n  constructor() {\n    this.appStore = new Map();\n  }\n  initializeApp(options) {\n    let appName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_APP_NAME;\n    if (typeof options === 'undefined') {\n      options = loadOptionsFromEnvVar();\n      options.credential = (0, credential_internal_1.getApplicationDefault)();\n    }\n    if (typeof appName !== 'string' || appName === '') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name \"${appName}\" provided. App name must be a non-empty string.`);\n    } else if (this.appStore.has(appName)) {\n      if (appName === DEFAULT_APP_NAME) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, 'The default Firebase app already exists. This means you called initializeApp() ' + 'more than once without providing an app name as the second argument. In most cases ' + 'you only need to call initializeApp() once. But if you do want to initialize ' + 'multiple apps, pass a second argument to initializeApp() to give each app a unique ' + 'name.');\n      } else {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `Firebase app named \"${appName}\" already exists. This means you called initializeApp() ` + 'more than once with the same app name as the second argument. Make sure you provide a ' + 'unique name every time you call initializeApp().');\n      }\n    }\n    const app = new firebase_app_1.FirebaseApp(options, appName, this);\n    this.appStore.set(app.name, app);\n    return app;\n  }\n  getApp() {\n    let appName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_APP_NAME;\n    if (typeof appName !== 'string' || appName === '') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name \"${appName}\" provided. App name must be a non-empty string.`);\n    } else if (!this.appStore.has(appName)) {\n      let errorMessage = appName === DEFAULT_APP_NAME ? 'The default Firebase app does not exist. ' : `Firebase app named \"${appName}\" does not exist. `;\n      errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);\n    }\n    return this.appStore.get(appName);\n  }\n  getApps() {\n    // Return a copy so the caller cannot mutate the array\n    return Array.from(this.appStore.values());\n  }\n  deleteApp(app) {\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');\n    }\n    // Make sure the given app already exists.\n    const existingApp = getApp(app.name);\n    // Delegate delete operation to the App instance itself. That will also remove the App\n    // instance from the AppStore.\n    return existingApp.delete();\n  }\n  clearAllApps() {\n    const promises = [];\n    this.getApps().forEach(app => {\n      promises.push(this.deleteApp(app));\n    });\n    return Promise.all(promises).then();\n  }\n  /**\n   * Removes the specified App instance from the store. This is currently called by the\n   * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled\n   * entirely by the {@link deleteApp} top-level function.\n   */\n  removeApp(appName) {\n    this.appStore.delete(appName);\n  }\n}\nexports.AppStore = AppStore;\nexports.defaultAppStore = new AppStore();\nfunction initializeApp(options) {\n  let appName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_APP_NAME;\n  return exports.defaultAppStore.initializeApp(options, appName);\n}\nexports.initializeApp = initializeApp;\nfunction getApp() {\n  let appName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_APP_NAME;\n  return exports.defaultAppStore.getApp(appName);\n}\nexports.getApp = getApp;\nfunction getApps() {\n  return exports.defaultAppStore.getApps();\n}\nexports.getApps = getApps;\n/**\n * Renders this given `App` unusable and frees the resources of\n * all associated services (though it does *not* clean up any backend\n * resources). When running the SDK locally, this method\n * must be called to ensure graceful termination of the process.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n */\nfunction deleteApp(app) {\n  return exports.defaultAppStore.deleteApp(app);\n}\nexports.deleteApp = deleteApp;\n/**\n * Constant holding the environment variable name with the default config.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nexports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';\n/**\n * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.\n * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nfunction loadOptionsFromEnvVar() {\n  const config = process.env[exports.FIREBASE_CONFIG_VAR];\n  if (!validator.isNonEmptyString(config)) {\n    return {};\n  }\n  try {\n    const contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');\n    return JSON.parse(contents);\n  } catch (error) {\n    // Throw a nicely formed error message if the file contents cannot be parsed\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","FIREBASE_CONFIG_VAR","deleteApp","getApps","getApp","initializeApp","defaultAppStore","AppStore","fs","require","validator","error_1","credential_internal_1","firebase_app_1","DEFAULT_APP_NAME","constructor","appStore","Map","options","appName","arguments","length","undefined","loadOptionsFromEnvVar","credential","getApplicationDefault","FirebaseAppError","AppErrorCodes","INVALID_APP_NAME","has","DUPLICATE_APP","app","FirebaseApp","set","name","errorMessage","NO_APP","get","Array","from","values","INVALID_ARGUMENT","existingApp","delete","clearAllApps","promises","forEach","push","Promise","all","then","removeApp","config","process","env","isNonEmptyString","contents","startsWith","readFileSync","JSON","parse","error","INVALID_APP_OPTIONS"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/app/lifecycle.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FIREBASE_CONFIG_VAR = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = exports.defaultAppStore = exports.AppStore = void 0;\nconst fs = require(\"fs\");\nconst validator = require(\"../utils/validator\");\nconst error_1 = require(\"../utils/error\");\nconst credential_internal_1 = require(\"./credential-internal\");\nconst firebase_app_1 = require(\"./firebase-app\");\nconst DEFAULT_APP_NAME = '[DEFAULT]';\nclass AppStore {\n    constructor() {\n        this.appStore = new Map();\n    }\n    initializeApp(options, appName = DEFAULT_APP_NAME) {\n        if (typeof options === 'undefined') {\n            options = loadOptionsFromEnvVar();\n            options.credential = (0, credential_internal_1.getApplicationDefault)();\n        }\n        if (typeof appName !== 'string' || appName === '') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name \"${appName}\" provided. App name must be a non-empty string.`);\n        }\n        else if (this.appStore.has(appName)) {\n            if (appName === DEFAULT_APP_NAME) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, 'The default Firebase app already exists. This means you called initializeApp() ' +\n                    'more than once without providing an app name as the second argument. In most cases ' +\n                    'you only need to call initializeApp() once. But if you do want to initialize ' +\n                    'multiple apps, pass a second argument to initializeApp() to give each app a unique ' +\n                    'name.');\n            }\n            else {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `Firebase app named \"${appName}\" already exists. This means you called initializeApp() ` +\n                    'more than once with the same app name as the second argument. Make sure you provide a ' +\n                    'unique name every time you call initializeApp().');\n            }\n        }\n        const app = new firebase_app_1.FirebaseApp(options, appName, this);\n        this.appStore.set(app.name, app);\n        return app;\n    }\n    getApp(appName = DEFAULT_APP_NAME) {\n        if (typeof appName !== 'string' || appName === '') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name \"${appName}\" provided. App name must be a non-empty string.`);\n        }\n        else if (!this.appStore.has(appName)) {\n            let errorMessage = (appName === DEFAULT_APP_NAME)\n                ? 'The default Firebase app does not exist. ' : `Firebase app named \"${appName}\" does not exist. `;\n            errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);\n        }\n        return this.appStore.get(appName);\n    }\n    getApps() {\n        // Return a copy so the caller cannot mutate the array\n        return Array.from(this.appStore.values());\n    }\n    deleteApp(app) {\n        if (typeof app !== 'object' || app === null || !('options' in app)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');\n        }\n        // Make sure the given app already exists.\n        const existingApp = getApp(app.name);\n        // Delegate delete operation to the App instance itself. That will also remove the App\n        // instance from the AppStore.\n        return existingApp.delete();\n    }\n    clearAllApps() {\n        const promises = [];\n        this.getApps().forEach((app) => {\n            promises.push(this.deleteApp(app));\n        });\n        return Promise.all(promises).then();\n    }\n    /**\n     * Removes the specified App instance from the store. This is currently called by the\n     * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled\n     * entirely by the {@link deleteApp} top-level function.\n     */\n    removeApp(appName) {\n        this.appStore.delete(appName);\n    }\n}\nexports.AppStore = AppStore;\nexports.defaultAppStore = new AppStore();\nfunction initializeApp(options, appName = DEFAULT_APP_NAME) {\n    return exports.defaultAppStore.initializeApp(options, appName);\n}\nexports.initializeApp = initializeApp;\nfunction getApp(appName = DEFAULT_APP_NAME) {\n    return exports.defaultAppStore.getApp(appName);\n}\nexports.getApp = getApp;\nfunction getApps() {\n    return exports.defaultAppStore.getApps();\n}\nexports.getApps = getApps;\n/**\n * Renders this given `App` unusable and frees the resources of\n * all associated services (though it does *not* clean up any backend\n * resources). When running the SDK locally, this method\n * must be called to ensure graceful termination of the process.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n */\nfunction deleteApp(app) {\n    return exports.defaultAppStore.deleteApp(app);\n}\nexports.deleteApp = deleteApp;\n/**\n * Constant holding the environment variable name with the default config.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nexports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';\n/**\n * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.\n * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\nfunction loadOptionsFromEnvVar() {\n    const config = process.env[exports.FIREBASE_CONFIG_VAR];\n    if (!validator.isNonEmptyString(config)) {\n        return {};\n    }\n    try {\n        const contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');\n        return JSON.parse(contents);\n    }\n    catch (error) {\n        // Throw a nicely formed error message if the file contents cannot be parsed\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}