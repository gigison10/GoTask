{"ast":null,"code":"import { inRange, decoderError, isASCIICodePoint, end_of_stream, finished } from '../utils';\n\n/**\n * @implements {Decoder}\n */\nexport class UTF8Decoder {\n  /**\n   * @param {{fatal: boolean}} options\n   */\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    let /** @type {number} */utf8_code_point = 0,\n      /** @type {number} */utf8_bytes_seen = 0,\n      /** @type {number} */utf8_bytes_needed = 0,\n      /** @type {number} */utf8_lower_boundary = 0x80,\n      /** @type {number} */utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1;\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0) utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED) utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2;\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0) utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4) utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3;\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Return continue.\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = utf8_code_point << 6 | bite & 0x3F;\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1;\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed) return null;\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 11. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n}\n\n// 9.1.2 utf-8 encoder\n\n/**\n * @implements {Encoder}\n */\nexport class UTF8Encoder {\n  constructor() {\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> 6 * count) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> 6 * (count - 1);\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | temp & 0x3F);\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n}","map":{"version":3,"names":["inRange","decoderError","isASCIICodePoint","end_of_stream","finished","UTF8Decoder","constructor","options","fatal","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","handler","stream","bite","prepend","code_point","UTF8Encoder","count","offset","bytes","temp","push"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/utf8.js"],"sourcesContent":["import { inRange, decoderError, isASCIICodePoint,\n  end_of_stream, finished } from '../utils'\n\n/**\n * @implements {Decoder}\n */\nexport class UTF8Decoder {\n  /**\n   * @param {{fatal: boolean}} options\n   */\n  constructor(options) {\n    const { fatal } = options\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    let /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0\n        return decoderError(fatal)\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal)\n        }\n\n        // Return continue.\n        return null\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0\n        utf8_lower_boundary = 0x80\n        utf8_upper_boundary = 0xBF\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite)\n\n        // 3. Return error.\n        return decoderError(fatal)\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80\n      utf8_upper_boundary = 0xBF\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F)\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0\n\n      // 11. Return a code point whose value is code point.\n      return code_point\n    }\n  }\n}\n\n// 9.1.2 utf-8 encoder\n\n/**\n * @implements {Encoder}\n */\nexport class UTF8Encoder {\n  constructor() {\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1\n        offset = 0xC0\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2\n        offset = 0xE0\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3\n        offset = 0xF0\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset]\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> (6 * (count - 1))\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F))\n\n        // 3. Decrease count by one.\n        count -= 1\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}