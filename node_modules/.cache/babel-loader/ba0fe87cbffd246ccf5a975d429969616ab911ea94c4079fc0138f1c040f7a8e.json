{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAuth = exports.createFirebaseTokenGenerator = void 0;\nconst error_1 = require(\"../utils/error\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst validator = require(\"../utils/validator\");\nconst auth_api_request_1 = require(\"./auth-api-request\");\nconst token_generator_1 = require(\"./token-generator\");\nconst token_verifier_1 = require(\"./token-verifier\");\nconst auth_config_1 = require(\"./auth-config\");\nconst user_record_1 = require(\"./user-record\");\nconst identifier_1 = require(\"./identifier\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\n * @internal\n */\nfunction createFirebaseTokenGenerator(app, tenantId) {\n  try {\n    const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);\n    return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n  } catch (err) {\n    throw (0, token_generator_1.handleCryptoSignerError)(err);\n  }\n}\nexports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;\n/**\n * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.\n */\nclass BaseAuth {\n  /**\n   * The BaseAuth class constructor.\n   *\n   * @param app - The FirebaseApp to associate with this Auth instance.\n   * @param authRequestHandler - The RPC request handler for this instance.\n   * @param tokenGenerator - Optional token generator. If not specified, a\n   *     (non-tenant-aware) instance will be created. Use this paramter to\n   *     specify a tenant-aware tokenGenerator.\n   * @constructor\n   * @internal\n   */\n  constructor(app, /** @internal */authRequestHandler, tokenGenerator) {\n    this.authRequestHandler = authRequestHandler;\n    if (tokenGenerator) {\n      this.tokenGenerator = tokenGenerator;\n    } else {\n      this.tokenGenerator = createFirebaseTokenGenerator(app);\n    }\n    this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);\n    this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);\n    this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);\n  }\n  /**\n   * Creates a new Firebase custom token (JWT) that can be sent back to a client\n   * device to use to sign in with the client SDKs' `signInWithCustomToken()`\n   * methods. (Tenant-aware instances will also embed the tenant ID in the\n   * token.)\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` to use as the custom token's subject.\n   * @param developerClaims - Optional additional claims to include\n   *   in the custom token's payload.\n   *\n   * @returns A promise fulfilled with a custom token for the\n   *   provided `uid` and payload.\n   */\n  createCustomToken(uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  }\n  /**\n   * Verifies a Firebase ID token (JWT). If the token is valid, the promise is\n   * fulfilled with the token's decoded claims; otherwise, the promise is\n   * rejected.\n   *\n   * If `checkRevoked` is set to true, first verifies whether the corresponding\n   * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,\n   * verifies if the session corresponding to the ID token was revoked. If the\n   * corresponding user's session was invalidated, an `auth/id-token-revoked`\n   * error is thrown. If not specified the check is not applied.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}\n   * for code samples and detailed documentation.\n   *\n   * @param idToken - The ID token to verify.\n   * @param checkRevoked - Whether to check if the ID token was revoked.\n   *   This requires an extra request to the Firebase Auth backend to check\n   *   the `tokensValidAfterTime` time for the corresponding user.\n   *   When not specified, this additional check is not applied.\n   *\n   * @returns A promise fulfilled with the\n   *   token's decoded claims if the ID token is valid; otherwise, a rejected\n   *   promise.\n   */\n  verifyIdToken(idToken) {\n    let checkRevoked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const isEmulator = (0, auth_api_request_1.useEmulator)();\n    return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then(decodedIdToken => {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n      }\n      return decodedIdToken;\n    });\n  }\n  /**\n   * Gets the user data for the user corresponding to a given `uid`.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` corresponding to the user whose data to fetch.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the provided `uid`.\n   */\n  getUser(uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\n   * Gets the user data for the user corresponding to a given email.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param email - The email corresponding to the user whose data to\n   *   fetch.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the provided email.\n   */\n  getUserByEmail(email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\n   * Gets the user data for the user corresponding to a given phone number. The\n   * phone number has to conform to the E.164 specification.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param phoneNumber - The phone number corresponding to the user whose\n   *   data to fetch.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the provided phone number.\n   */\n  getUserByPhoneNumber(phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\n   * Gets the user data for the user corresponding to a given provider id.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n   * for code samples and detailed documentation.\n   *\n   * @param providerId - The provider ID, for example, \"google.com\" for the\n   *   Google provider.\n   * @param uid - The user identifier for the given provider.\n   *\n   * @returns A promise fulfilled with the user data corresponding to the\n   *   given provider id.\n   */\n  getUserByProviderUid(providerId, uid) {\n    // Although we don't really advertise it, we want to also handle\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // reroute this request appropriately.\n    if (providerId === 'phone') {\n      return this.getUserByPhoneNumber(uid);\n    } else if (providerId === 'email') {\n      return this.getUserByEmail(uid);\n    }\n    return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then(response => {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  }\n  /**\n   * Gets the user data corresponding to the specified identifiers.\n   *\n   * There are no ordering guarantees; in particular, the nth entry in the result list is not\n   * guaranteed to correspond to the nth entry in the input parameters list.\n   *\n   * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\n   * this method throws a FirebaseAuthError.\n   *\n   * @param identifiers - The identifiers used to indicate which user records should be returned.\n   *     Must not have more than 100 entries.\n   * @returns A promise that resolves to the corresponding user records.\n   * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\n   *     identifiers are specified.\n   */\n  getUsers(identifiers) {\n    if (!validator.isArray(identifiers)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n    }\n    return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then(response => {\n      /**\n       * Checks if the specified identifier is within the list of\n       * UserRecords.\n       */\n      const isUserFound = (id, userRecords) => {\n        return !!userRecords.find(userRecord => {\n          if ((0, identifier_1.isUidIdentifier)(id)) {\n            return id.uid === userRecord.uid;\n          } else if ((0, identifier_1.isEmailIdentifier)(id)) {\n            return id.email === userRecord.email;\n          } else if ((0, identifier_1.isPhoneIdentifier)(id)) {\n            return id.phoneNumber === userRecord.phoneNumber;\n          } else if ((0, identifier_1.isProviderIdentifier)(id)) {\n            const matchingUserInfo = userRecord.providerData.find(userInfo => {\n              return id.providerId === userInfo.providerId;\n            });\n            return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n          } else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n          }\n        });\n      };\n      const users = response.users ? response.users.map(user => new user_record_1.UserRecord(user)) : [];\n      const notFound = identifiers.filter(id => !isUserFound(id, users));\n      return {\n        users,\n        notFound\n      };\n    });\n  }\n  /**\n   * Retrieves a list of users (single batch only) with a size of `maxResults`\n   * starting from the offset as specified by `pageToken`. This is used to\n   * retrieve all the users of a specified project in batches.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}\n   * for code samples and detailed documentation.\n   *\n   * @param maxResults - The page size, 1000 if undefined. This is also\n   *   the maximum allowed limit.\n   * @param pageToken - The next page token. If not specified, returns\n   *   users starting without any offset.\n   * @returns A promise that resolves with\n   *   the current batch of downloaded users and the next page token.\n   */\n  listUsers(maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(response => {\n      // List of users to return.\n      const users = [];\n      // Convert each user response to a UserRecord.\n      response.users.forEach(userResponse => {\n        users.push(new user_record_1.UserRecord(userResponse));\n      });\n      // Return list of user records and the next page token if available.\n      const result = {\n        users,\n        pageToken: response.nextPageToken\n      };\n      // Delete result.pageToken if undefined.\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n      return result;\n    });\n  }\n  /**\n   * Creates a new user.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}\n   * for code samples and detailed documentation.\n   *\n   * @param properties - The properties to set on the\n   *   new user record to be created.\n   *\n   * @returns A promise fulfilled with the user\n   *   data corresponding to the newly created user.\n   */\n  createUser(properties) {\n    return this.authRequestHandler.createNewAccount(properties).then(uid => {\n      // Return the corresponding user record.\n      return this.getUser(uid);\n    }).catch(error => {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n      throw error;\n    });\n  }\n  /**\n   * Deletes an existing user.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` corresponding to the user to delete.\n   *\n   * @returns An empty promise fulfilled once the user has been\n   *   deleted.\n   */\n  deleteUser(uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(() => {\n      // Return nothing on success.\n    });\n  }\n  /**\n   * Deletes the users specified by the given uids.\n   *\n   * Deleting a non-existing user won't generate an error (i.e. this method\n   * is idempotent.) Non-existing users are considered to be successfully\n   * deleted, and are therefore counted in the\n   * `DeleteUsersResult.successCount` value.\n   *\n   * Only a maximum of 1000 identifiers may be supplied. If more than 1000\n   * identifiers are supplied, this method throws a FirebaseAuthError.\n   *\n   * This API is currently rate limited at the server to 1 QPS. If you exceed\n   * this, you may get a quota exceeded error. Therefore, if you want to\n   * delete more than 1000 users, you may need to add a delay to ensure you\n   * don't go over this limit.\n   *\n   * @param uids - The `uids` corresponding to the users to delete.\n   *\n   * @returns A Promise that resolves to the total number of successful/failed\n   *     deletions, as well as the array of errors that corresponds to the\n   *     failed deletions.\n   */\n  deleteUsers(uids) {\n    if (!validator.isArray(uids)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n    }\n    return this.authRequestHandler.deleteAccounts(uids, /*force=*/true).then(batchDeleteAccountsResponse => {\n      const result = {\n        failureCount: 0,\n        successCount: uids.length,\n        errors: []\n      };\n      if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n        return result;\n      }\n      result.failureCount = batchDeleteAccountsResponse.errors.length;\n      result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n      result.errors = batchDeleteAccountsResponse.errors.map(batchDeleteErrorInfo => {\n        if (batchDeleteErrorInfo.index === undefined) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n        }\n        const errMsgToError = msg => {\n          // We unconditionally set force=true, so the 'NOT_DISABLED' error\n          // should not be possible.\n          const code = msg && msg.startsWith('NOT_DISABLED') ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n          return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n        };\n        return {\n          index: batchDeleteErrorInfo.index,\n          error: errMsgToError(batchDeleteErrorInfo.message)\n        };\n      });\n      return result;\n    });\n  }\n  /**\n   * Updates an existing user.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` corresponding to the user to update.\n   * @param properties - The properties to update on\n   *   the provided user.\n   *\n   * @returns A promise fulfilled with the\n   *   updated user data.\n   */\n  updateUser(uid, properties) {\n    // Although we don't really advertise it, we want to also handle linking of\n    // non-federated idps with this call. So if we detect one of them, we'll\n    // adjust the properties parameter appropriately. This *does* imply that a\n    // conflict could arise, e.g. if the user provides a phoneNumber property,\n    // but also provides a providerToLink with a 'phone' provider id. In that\n    // case, we'll throw an error.\n    properties = (0, deep_copy_1.deepCopy)(properties);\n    if (properties?.providerToLink) {\n      if (properties.providerToLink.providerId === 'email') {\n        if (typeof properties.email !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \" + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n        }\n        properties.email = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      } else if (properties.providerToLink.providerId === 'phone') {\n        if (typeof properties.phoneNumber !== 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \" + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n        }\n        properties.phoneNumber = properties.providerToLink.uid;\n        delete properties.providerToLink;\n      }\n    }\n    if (properties?.providersToUnlink) {\n      if (properties.providersToUnlink.indexOf('phone') !== -1) {\n        // If we've been told to unlink the phone provider both via setting\n        // phoneNumber to null *and* by setting providersToUnlink to include\n        // 'phone', then we'll reject that. Though it might also be reasonable\n        // to relax this restriction and just unlink it.\n        if (properties.phoneNumber === null) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \" + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n        }\n      }\n    }\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(existingUid => {\n      // Return the corresponding user record.\n      return this.getUser(existingUid);\n    });\n  }\n  /**\n   * Sets additional developer claims on an existing user identified by the\n   * provided `uid`, typically used to define user roles and levels of\n   * access. These claims should propagate to all devices where the user is\n   * already signed in (after token expiration or when token refresh is forced)\n   * and the next time the user signs in. If a reserved OIDC claim name\n   * is used (sub, iat, iss, etc), an error is thrown. They are set on the\n   * authenticated user's ID token JWT.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |\n   * Defining user roles and access levels}\n   * for code samples and detailed documentation.\n   *\n   * @param uid - The `uid` of the user to edit.\n   * @param customUserClaims - The developer claims to set. If null is\n   *   passed, existing custom claims are deleted. Passing a custom claims payload\n   *   larger than 1000 bytes will throw an error. Custom claims are added to the\n   *   user's ID token which is transmitted on every authenticated request.\n   *   For profile non-access related user attributes, use database or other\n   *   separate storage systems.\n   * @returns A promise that resolves when the operation completes\n   *   successfully.\n   */\n  setCustomUserClaims(uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(() => {\n      // Return nothing on success.\n    });\n  }\n  /**\n   * Revokes all refresh tokens for an existing user.\n   *\n   * This API will update the user's {@link UserRecord.tokensValidAfterTime} to\n   * the current UTC. It is important that the server on which this is called has\n   * its clock set correctly and synchronized.\n   *\n   * While this will revoke all sessions for a specified user and disable any\n   * new ID tokens for existing sessions from getting minted, existing ID tokens\n   * may remain active until their natural expiration (one hour). To verify that\n   * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}\n   * where `checkRevoked` is set to true.\n   *\n   * @param uid - The `uid` corresponding to the user whose refresh tokens\n   *   are to be revoked.\n   *\n   * @returns An empty promise fulfilled once the user's refresh\n   *   tokens have been revoked.\n   */\n  revokeRefreshTokens(uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(() => {\n      // Return nothing on success.\n    });\n  }\n  /**\n   * Imports the provided list of users into Firebase Auth.\n   * A maximum of 1000 users are allowed to be imported one at a time.\n   * When importing users with passwords,\n   * {@link UserImportOptions} are required to be\n   * specified.\n   * This operation is optimized for bulk imports and will ignore checks on `uid`,\n   * `email` and other identifier uniqueness which could result in duplications.\n   *\n   * @param users - The list of user records to import to Firebase Auth.\n   * @param options - The user import options, required when the users provided include\n   *   password credentials.\n   * @returns A promise that resolves when\n   *   the operation completes with the result of the import. This includes the\n   *   number of successful imports, the number of failed imports and their\n   *   corresponding errors.\n  */\n  importUsers(users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  }\n  /**\n   * Creates a new Firebase session cookie with the specified options. The created\n   * JWT string can be set as a server-side session cookie with a custom cookie\n   * policy, and be used for session management. The session cookie JWT will have\n   * the same payload claims as the provided ID token.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}\n   * for code samples and detailed documentation.\n   *\n   * @param idToken - The Firebase ID token to exchange for a session\n   *   cookie.\n   * @param sessionCookieOptions - The session\n   *   cookie options which includes custom session duration.\n   *\n   * @returns A promise that resolves on success with the\n   *   created session cookie.\n   */\n  createSessionCookie(idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  }\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.\n   * Rejects the promise if the cookie could not be verified.\n   *\n   * If `checkRevoked` is set to true, first verifies whether the corresponding\n   * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,\n   * verifies if the session corresponding to the session cookie was revoked.\n   * If the corresponding user's session was invalidated, an\n   * `auth/session-cookie-revoked` error is thrown. If not specified the check\n   * is not performed.\n   *\n   * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |\n   * Verify Session Cookies}\n   * for code samples and detailed documentation\n   *\n   * @param sessionCookie - The session cookie to verify.\n   * @param checkForRevocation -  Whether to check if the session cookie was\n   *   revoked. This requires an extra request to the Firebase Auth backend to\n   *   check the `tokensValidAfterTime` time for the corresponding user.\n   *   When not specified, this additional check is not performed.\n   *\n   * @returns A promise fulfilled with the\n   *   session cookie's decoded claims if the session cookie is valid; otherwise,\n   *   a rejected promise.\n   */\n  verifySessionCookie(sessionCookie) {\n    let checkRevoked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const isEmulator = (0, auth_api_request_1.useEmulator)();\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then(decodedIdToken => {\n      // Whether to check if the token was revoked.\n      if (checkRevoked || isEmulator) {\n        return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n      }\n      return decodedIdToken;\n    });\n  }\n  /**\n   * Generates the out of band email action link to reset a user's password.\n   * The link is generated for the user with the specified email address. The\n   * optional  {@link ActionCodeSettings} object\n   * defines whether the link is to be handled by a mobile app or browser and the\n   * additional state information to be passed in the deep link, etc.\n   *\n   * @example\n   * ```javascript\n   * var actionCodeSettings = {\n   *   url: 'https://www.example.com/?email=user@example.com',\n   *   iOS: {\n   *     bundleId: 'com.example.ios'\n   *   },\n   *   android: {\n   *     packageName: 'com.example.android',\n   *     installApp: true,\n   *     minimumVersion: '12'\n   *   },\n   *   handleCodeInApp: true,\n   *   dynamicLinkDomain: 'custom.page.link'\n   * };\n   * admin.auth()\n   *     .generatePasswordResetLink('user@example.com', actionCodeSettings)\n   *     .then(function(link) {\n   *       // The link was successfully generated.\n   *     })\n   *     .catch(function(error) {\n   *       // Some error occurred, you can inspect the code: error.code\n   *     });\n   * ```\n   *\n   * @param email - The email address of the user whose password is to be\n   *   reset.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the password reset link. The default password\n   *     reset landing page will use this to display a link to go back to the app\n   *     if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is whitelisted by the\n   *     developer in the console. Otherwise an error is thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n  generatePasswordResetLink(email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  }\n  /**\n   * Generates the out of band email action link to verify the user's ownership\n   * of the specified email. The {@link ActionCodeSettings} object provided\n   * as an argument to this method defines whether the link is to be handled by a\n   * mobile app or browser along with additional state information to be passed in\n   * the deep link, etc.\n   *\n   * @example\n   * ```javascript\n   * var actionCodeSettings = {\n   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n   *   iOS: {\n   *     bundleId: 'com.example.ios'\n   *   },\n   *   android: {\n   *     packageName: 'com.example.android',\n   *     installApp: true,\n   *     minimumVersion: '12'\n   *   },\n   *   handleCodeInApp: true,\n   *   dynamicLinkDomain: 'custom.page.link'\n   * };\n   * admin.auth()\n   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n   *     .then(function(link) {\n   *       // The link was successfully generated.\n   *     })\n   *     .catch(function(error) {\n   *       // Some error occurred, you can inspect the code: error.code\n   *     });\n   * ```\n   *\n   * @param email - The email account to verify.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the email verification link. The default email\n   *     verification landing page will use this to display a link to go back to\n   *     the app if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is whitelisted by the\n   *     developer in the console. Otherwise an error is thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n  generateEmailVerificationLink(email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  }\n  /**\n   * Generates an out-of-band email action link to verify the user's ownership\n   * of the specified email. The {@link ActionCodeSettings} object provided\n   * as an argument to this method defines whether the link is to be handled by a\n   * mobile app or browser along with additional state information to be passed in\n   * the deep link, etc.\n   *\n   * @param email - The current email account.\n   * @param newEmail - The email address the account is being updated to.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the email verification link. The default email\n   *     verification landing page will use this to display a link to go back to\n   *     the app if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is authorized\n   *     in the console, or an error will be thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n  generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_AND_CHANGE_EMAIL', email, actionCodeSettings, newEmail);\n  }\n  /**\n   * Generates the out of band email action link to verify the user's ownership\n   * of the specified email. The {@link ActionCodeSettings} object provided\n   * as an argument to this method defines whether the link is to be handled by a\n   * mobile app or browser along with additional state information to be passed in\n   * the deep link, etc.\n   *\n   * @example\n   * ```javascript\n   * var actionCodeSettings = {\n   *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n   *   iOS: {\n   *     bundleId: 'com.example.ios'\n   *   },\n   *   android: {\n   *     packageName: 'com.example.android',\n   *     installApp: true,\n   *     minimumVersion: '12'\n   *   },\n   *   handleCodeInApp: true,\n   *   dynamicLinkDomain: 'custom.page.link'\n   * };\n   * admin.auth()\n   *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n   *     .then(function(link) {\n   *       // The link was successfully generated.\n   *     })\n   *     .catch(function(error) {\n   *       // Some error occurred, you can inspect the code: error.code\n   *     });\n   * ```\n   *\n   * @param email - The email account to verify.\n   * @param actionCodeSettings - The action\n   *     code settings. If specified, the state/continue URL is set as the\n   *     \"continueUrl\" parameter in the email verification link. The default email\n   *     verification landing page will use this to display a link to go back to\n   *     the app if it is installed.\n   *     If the actionCodeSettings is not specified, no URL is appended to the\n   *     action URL.\n   *     The state URL provided must belong to a domain that is whitelisted by the\n   *     developer in the console. Otherwise an error is thrown.\n   *     Mobile app redirects are only applicable if the developer configures\n   *     and accepts the Firebase Dynamic Links terms of service.\n   *     The Android package name and iOS bundle ID are respected only if they\n   *     are configured in the same Firebase Auth project.\n   * @returns A promise that resolves with the generated link.\n   */\n  generateSignInWithEmailLink(email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  }\n  /**\n   * Returns the list of existing provider configurations matching the filter\n   * provided. At most, 100 provider configs can be listed at a time.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param options - The provider config filter to apply.\n   * @returns A promise that resolves with the list of provider configs meeting the\n   *   filter requirements.\n   */\n  listProviderConfigs(options) {\n    const processResponse = (response, providerConfigs) => {\n      // Return list of provider configuration and the next page token if available.\n      const result = {\n        providerConfigs\n      };\n      // Delete result.pageToken if undefined.\n      if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n        result.pageToken = response.nextPageToken;\n      }\n      return result;\n    };\n    if (options && options.type === 'oidc') {\n      return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then(response => {\n        // List of provider configurations to return.\n        const providerConfigs = [];\n        // Convert each provider config response to a OIDCConfig.\n        response.oauthIdpConfigs.forEach(configResponse => {\n          providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n        });\n        // Return list of provider configuration and the next page token if available.\n        return processResponse(response, providerConfigs);\n      });\n    } else if (options && options.type === 'saml') {\n      return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then(response => {\n        // List of provider configurations to return.\n        const providerConfigs = [];\n        // Convert each provider config response to a SAMLConfig.\n        response.inboundSamlConfigs.forEach(configResponse => {\n          providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n        });\n        // Return list of provider configuration and the next page token if available.\n        return processResponse(response, providerConfigs);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n  }\n  /**\n   * Looks up an Auth provider configuration by the provided ID.\n   * Returns a promise that resolves with the provider configuration\n   * corresponding to the provider ID specified. If the specified ID does not\n   * exist, an `auth/configuration-not-found` error is thrown.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param providerId - The provider ID corresponding to the provider\n   *     config to return.\n   * @returns A promise that resolves\n   *     with the configuration corresponding to the provided ID.\n   */\n  getProviderConfig(providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getOAuthIdpConfig(providerId).then(response => {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getInboundSamlConfig(providerId).then(response => {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /**\n   * Deletes the provider configuration corresponding to the provider ID passed.\n   * If the specified ID does not exist, an `auth/configuration-not-found` error\n   * is thrown.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param providerId - The provider ID corresponding to the provider\n   *     config to delete.\n   * @returns A promise that resolves on completion.\n   */\n  deleteProviderConfig(providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /**\n   * Returns a promise that resolves with the updated `AuthProviderConfig`\n   * corresponding to the provider ID specified.\n   * If the specified ID does not exist, an `auth/configuration-not-found` error\n   * is thrown.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param providerId - The provider ID corresponding to the provider\n   *     config to update.\n   * @param updatedConfig - The updated configuration.\n   * @returns A promise that resolves with the updated provider configuration.\n   */\n  updateProviderConfig(providerId, updatedConfig) {\n    if (!validator.isNonNullObject(updatedConfig)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n    }\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then(response => {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then(response => {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /**\n   * Returns a promise that resolves with the newly created `AuthProviderConfig`\n   * when the new provider configuration is created.\n   *\n   * SAML and OIDC provider support requires Google Cloud's Identity Platform\n   * (GCIP). To learn more about GCIP, including pricing and features,\n   * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n   *\n   * @param config - The provider configuration to create.\n   * @returns A promise that resolves with the created provider configuration.\n   */\n  createProviderConfig(config) {\n    if (!validator.isNonNullObject(config)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n    }\n    if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createOAuthIdpConfig(config).then(response => {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createInboundSamlConfig(config).then(response => {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  }\n  /** @alpha */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  _verifyAuthBlockingToken(token, audience) {\n    const isEmulator = (0, auth_api_request_1.useEmulator)();\n    return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience).then(decodedAuthBlockingToken => {\n      return decodedAuthBlockingToken;\n    });\n  }\n  /**\n   * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that\n   * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked\n   * or user disabled.\n   *\n   * @param decodedIdToken - The JWT's decoded claims.\n   * @param revocationErrorInfo - The revocation error info to throw on revocation\n   *     detection.\n   * @returns A promise that will be fulfilled after a successful verification.\n   */\n  verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(user => {\n      if (user.disabled) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');\n      }\n      // If no tokens valid after time available, token is not revoked.\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        const authTimeUtc = decodedIdToken.auth_time * 1000;\n        // Get user tokens valid after time in milliseconds UTC.\n        const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\n        // Check if authentication time is older than valid since time.\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      }\n      // All checks above passed. Return the decoded token.\n      return decodedIdToken;\n    });\n  }\n}\nexports.BaseAuth = BaseAuth;","map":{"version":3,"names":["Object","defineProperty","exports","value","BaseAuth","createFirebaseTokenGenerator","error_1","require","deep_copy_1","validator","auth_api_request_1","token_generator_1","token_verifier_1","auth_config_1","user_record_1","identifier_1","crypto_signer_1","app","tenantId","signer","useEmulator","EmulatedSigner","cryptoSignerFromApp","FirebaseTokenGenerator","err","handleCryptoSignerError","constructor","authRequestHandler","tokenGenerator","sessionCookieVerifier","createSessionCookieVerifier","idTokenVerifier","createIdTokenVerifier","authBlockingTokenVerifier","createAuthBlockingTokenVerifier","createCustomToken","uid","developerClaims","verifyIdToken","idToken","checkRevoked","arguments","length","undefined","isEmulator","verifyJWT","then","decodedIdToken","verifyDecodedJWTNotRevokedOrDisabled","AuthClientErrorCode","ID_TOKEN_REVOKED","getUser","getAccountInfoByUid","response","UserRecord","users","getUserByEmail","email","getAccountInfoByEmail","getUserByPhoneNumber","phoneNumber","getAccountInfoByPhoneNumber","getUserByProviderUid","providerId","getAccountInfoByFederatedUid","getUsers","identifiers","isArray","FirebaseAuthError","INVALID_ARGUMENT","getAccountInfoByIdentifiers","isUserFound","id","userRecords","find","userRecord","isUidIdentifier","isEmailIdentifier","isPhoneIdentifier","isProviderIdentifier","matchingUserInfo","providerData","userInfo","providerUid","INTERNAL_ERROR","map","user","notFound","filter","listUsers","maxResults","pageToken","downloadAccount","forEach","userResponse","push","result","nextPageToken","createUser","properties","createNewAccount","catch","error","code","deleteUser","deleteAccount","deleteUsers","uids","deleteAccounts","batchDeleteAccountsResponse","failureCount","successCount","errors","isNonEmptyArray","batchDeleteErrorInfo","index","errMsgToError","msg","startsWith","USER_NOT_DISABLED","message","updateUser","deepCopy","providerToLink","providersToUnlink","indexOf","updateExistingAccount","existingUid","setCustomUserClaims","customUserClaims","revokeRefreshTokens","importUsers","options","uploadAccount","createSessionCookie","sessionCookieOptions","isNonNullObject","isNumber","expiresIn","Promise","reject","INVALID_SESSION_COOKIE_DURATION","verifySessionCookie","sessionCookie","SESSION_COOKIE_REVOKED","generatePasswordResetLink","actionCodeSettings","getEmailActionLink","generateEmailVerificationLink","generateVerifyAndChangeEmailLink","newEmail","generateSignInWithEmailLink","listProviderConfigs","processResponse","providerConfigs","prototype","hasOwnProperty","call","type","listOAuthIdpConfigs","oauthIdpConfigs","configResponse","OIDCConfig","listInboundSamlConfigs","inboundSamlConfigs","SAMLConfig","getProviderConfig","isProviderId","getOAuthIdpConfig","getInboundSamlConfig","INVALID_PROVIDER_ID","deleteProviderConfig","deleteOAuthIdpConfig","deleteInboundSamlConfig","updateProviderConfig","updatedConfig","INVALID_CONFIG","updateOAuthIdpConfig","updateInboundSamlConfig","createProviderConfig","config","createOAuthIdpConfig","createInboundSamlConfig","_verifyAuthBlockingToken","token","audience","decodedAuthBlockingToken","revocationErrorInfo","sub","disabled","USER_DISABLED","tokensValidAfterTime","authTimeUtc","auth_time","validSinceUtc","Date","getTime"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/auth/base-auth.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseAuth = exports.createFirebaseTokenGenerator = void 0;\nconst error_1 = require(\"../utils/error\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst validator = require(\"../utils/validator\");\nconst auth_api_request_1 = require(\"./auth-api-request\");\nconst token_generator_1 = require(\"./token-generator\");\nconst token_verifier_1 = require(\"./token-verifier\");\nconst auth_config_1 = require(\"./auth-config\");\nconst user_record_1 = require(\"./user-record\");\nconst identifier_1 = require(\"./identifier\");\nconst crypto_signer_1 = require(\"../utils/crypto-signer\");\n/**\n * @internal\n */\nfunction createFirebaseTokenGenerator(app, tenantId) {\n    try {\n        const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);\n        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);\n    }\n    catch (err) {\n        throw (0, token_generator_1.handleCryptoSignerError)(err);\n    }\n}\nexports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;\n/**\n * Common parent interface for both `Auth` and `TenantAwareAuth` APIs.\n */\nclass BaseAuth {\n    /**\n     * The BaseAuth class constructor.\n     *\n     * @param app - The FirebaseApp to associate with this Auth instance.\n     * @param authRequestHandler - The RPC request handler for this instance.\n     * @param tokenGenerator - Optional token generator. If not specified, a\n     *     (non-tenant-aware) instance will be created. Use this paramter to\n     *     specify a tenant-aware tokenGenerator.\n     * @constructor\n     * @internal\n     */\n    constructor(app, \n    /** @internal */ authRequestHandler, tokenGenerator) {\n        this.authRequestHandler = authRequestHandler;\n        if (tokenGenerator) {\n            this.tokenGenerator = tokenGenerator;\n        }\n        else {\n            this.tokenGenerator = createFirebaseTokenGenerator(app);\n        }\n        this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);\n        this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);\n        this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);\n    }\n    /**\n     * Creates a new Firebase custom token (JWT) that can be sent back to a client\n     * device to use to sign in with the client SDKs' `signInWithCustomToken()`\n     * methods. (Tenant-aware instances will also embed the tenant ID in the\n     * token.)\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` to use as the custom token's subject.\n     * @param developerClaims - Optional additional claims to include\n     *   in the custom token's payload.\n     *\n     * @returns A promise fulfilled with a custom token for the\n     *   provided `uid` and payload.\n     */\n    createCustomToken(uid, developerClaims) {\n        return this.tokenGenerator.createCustomToken(uid, developerClaims);\n    }\n    /**\n     * Verifies a Firebase ID token (JWT). If the token is valid, the promise is\n     * fulfilled with the token's decoded claims; otherwise, the promise is\n     * rejected.\n     *\n     * If `checkRevoked` is set to true, first verifies whether the corresponding\n     * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,\n     * verifies if the session corresponding to the ID token was revoked. If the\n     * corresponding user's session was invalidated, an `auth/id-token-revoked`\n     * error is thrown. If not specified the check is not applied.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}\n     * for code samples and detailed documentation.\n     *\n     * @param idToken - The ID token to verify.\n     * @param checkRevoked - Whether to check if the ID token was revoked.\n     *   This requires an extra request to the Firebase Auth backend to check\n     *   the `tokensValidAfterTime` time for the corresponding user.\n     *   When not specified, this additional check is not applied.\n     *\n     * @returns A promise fulfilled with the\n     *   token's decoded claims if the ID token is valid; otherwise, a rejected\n     *   promise.\n     */\n    verifyIdToken(idToken, checkRevoked = false) {\n        const isEmulator = (0, auth_api_request_1.useEmulator)();\n        return this.idTokenVerifier.verifyJWT(idToken, isEmulator)\n            .then((decodedIdToken) => {\n            // Whether to check if the token was revoked.\n            if (checkRevoked || isEmulator) {\n                return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n            }\n            return decodedIdToken;\n        });\n    }\n    /**\n     * Gets the user data for the user corresponding to a given `uid`.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` corresponding to the user whose data to fetch.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the provided `uid`.\n     */\n    getUser(uid) {\n        return this.authRequestHandler.getAccountInfoByUid(uid)\n            .then((response) => {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    }\n    /**\n     * Gets the user data for the user corresponding to a given email.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param email - The email corresponding to the user whose data to\n     *   fetch.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the provided email.\n     */\n    getUserByEmail(email) {\n        return this.authRequestHandler.getAccountInfoByEmail(email)\n            .then((response) => {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    }\n    /**\n     * Gets the user data for the user corresponding to a given phone number. The\n     * phone number has to conform to the E.164 specification.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param phoneNumber - The phone number corresponding to the user whose\n     *   data to fetch.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the provided phone number.\n     */\n    getUserByPhoneNumber(phoneNumber) {\n        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)\n            .then((response) => {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    }\n    /**\n     * Gets the user data for the user corresponding to a given provider id.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}\n     * for code samples and detailed documentation.\n     *\n     * @param providerId - The provider ID, for example, \"google.com\" for the\n     *   Google provider.\n     * @param uid - The user identifier for the given provider.\n     *\n     * @returns A promise fulfilled with the user data corresponding to the\n     *   given provider id.\n     */\n    getUserByProviderUid(providerId, uid) {\n        // Although we don't really advertise it, we want to also handle\n        // non-federated idps with this call. So if we detect one of them, we'll\n        // reroute this request appropriately.\n        if (providerId === 'phone') {\n            return this.getUserByPhoneNumber(uid);\n        }\n        else if (providerId === 'email') {\n            return this.getUserByEmail(uid);\n        }\n        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid)\n            .then((response) => {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    }\n    /**\n     * Gets the user data corresponding to the specified identifiers.\n     *\n     * There are no ordering guarantees; in particular, the nth entry in the result list is not\n     * guaranteed to correspond to the nth entry in the input parameters list.\n     *\n     * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,\n     * this method throws a FirebaseAuthError.\n     *\n     * @param identifiers - The identifiers used to indicate which user records should be returned.\n     *     Must not have more than 100 entries.\n     * @returns A promise that resolves to the corresponding user records.\n     * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100\n     *     identifiers are specified.\n     */\n    getUsers(identifiers) {\n        if (!validator.isArray(identifiers)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`identifiers` parameter must be an array');\n        }\n        return this.authRequestHandler\n            .getAccountInfoByIdentifiers(identifiers)\n            .then((response) => {\n            /**\n             * Checks if the specified identifier is within the list of\n             * UserRecords.\n             */\n            const isUserFound = ((id, userRecords) => {\n                return !!userRecords.find((userRecord) => {\n                    if ((0, identifier_1.isUidIdentifier)(id)) {\n                        return id.uid === userRecord.uid;\n                    }\n                    else if ((0, identifier_1.isEmailIdentifier)(id)) {\n                        return id.email === userRecord.email;\n                    }\n                    else if ((0, identifier_1.isPhoneIdentifier)(id)) {\n                        return id.phoneNumber === userRecord.phoneNumber;\n                    }\n                    else if ((0, identifier_1.isProviderIdentifier)(id)) {\n                        const matchingUserInfo = userRecord.providerData.find((userInfo) => {\n                            return id.providerId === userInfo.providerId;\n                        });\n                        return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;\n                    }\n                    else {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unhandled identifier type');\n                    }\n                });\n            });\n            const users = response.users ? response.users.map((user) => new user_record_1.UserRecord(user)) : [];\n            const notFound = identifiers.filter((id) => !isUserFound(id, users));\n            return { users, notFound };\n        });\n    }\n    /**\n     * Retrieves a list of users (single batch only) with a size of `maxResults`\n     * starting from the offset as specified by `pageToken`. This is used to\n     * retrieve all the users of a specified project in batches.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}\n     * for code samples and detailed documentation.\n     *\n     * @param maxResults - The page size, 1000 if undefined. This is also\n     *   the maximum allowed limit.\n     * @param pageToken - The next page token. If not specified, returns\n     *   users starting without any offset.\n     * @returns A promise that resolves with\n     *   the current batch of downloaded users and the next page token.\n     */\n    listUsers(maxResults, pageToken) {\n        return this.authRequestHandler.downloadAccount(maxResults, pageToken)\n            .then((response) => {\n            // List of users to return.\n            const users = [];\n            // Convert each user response to a UserRecord.\n            response.users.forEach((userResponse) => {\n                users.push(new user_record_1.UserRecord(userResponse));\n            });\n            // Return list of user records and the next page token if available.\n            const result = {\n                users,\n                pageToken: response.nextPageToken,\n            };\n            // Delete result.pageToken if undefined.\n            if (typeof result.pageToken === 'undefined') {\n                delete result.pageToken;\n            }\n            return result;\n        });\n    }\n    /**\n     * Creates a new user.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}\n     * for code samples and detailed documentation.\n     *\n     * @param properties - The properties to set on the\n     *   new user record to be created.\n     *\n     * @returns A promise fulfilled with the user\n     *   data corresponding to the newly created user.\n     */\n    createUser(properties) {\n        return this.authRequestHandler.createNewAccount(properties)\n            .then((uid) => {\n            // Return the corresponding user record.\n            return this.getUser(uid);\n        })\n            .catch((error) => {\n            if (error.code === 'auth/user-not-found') {\n                // Something must have happened after creating the user and then retrieving it.\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n            }\n            throw error;\n        });\n    }\n    /**\n     * Deletes an existing user.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` corresponding to the user to delete.\n     *\n     * @returns An empty promise fulfilled once the user has been\n     *   deleted.\n     */\n    deleteUser(uid) {\n        return this.authRequestHandler.deleteAccount(uid)\n            .then(() => {\n            // Return nothing on success.\n        });\n    }\n    /**\n     * Deletes the users specified by the given uids.\n     *\n     * Deleting a non-existing user won't generate an error (i.e. this method\n     * is idempotent.) Non-existing users are considered to be successfully\n     * deleted, and are therefore counted in the\n     * `DeleteUsersResult.successCount` value.\n     *\n     * Only a maximum of 1000 identifiers may be supplied. If more than 1000\n     * identifiers are supplied, this method throws a FirebaseAuthError.\n     *\n     * This API is currently rate limited at the server to 1 QPS. If you exceed\n     * this, you may get a quota exceeded error. Therefore, if you want to\n     * delete more than 1000 users, you may need to add a delay to ensure you\n     * don't go over this limit.\n     *\n     * @param uids - The `uids` corresponding to the users to delete.\n     *\n     * @returns A Promise that resolves to the total number of successful/failed\n     *     deletions, as well as the array of errors that corresponds to the\n     *     failed deletions.\n     */\n    deleteUsers(uids) {\n        if (!validator.isArray(uids)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '`uids` parameter must be an array');\n        }\n        return this.authRequestHandler.deleteAccounts(uids, /*force=*/ true)\n            .then((batchDeleteAccountsResponse) => {\n            const result = {\n                failureCount: 0,\n                successCount: uids.length,\n                errors: [],\n            };\n            if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {\n                return result;\n            }\n            result.failureCount = batchDeleteAccountsResponse.errors.length;\n            result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;\n            result.errors = batchDeleteAccountsResponse.errors.map((batchDeleteErrorInfo) => {\n                if (batchDeleteErrorInfo.index === undefined) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Corrupt BatchDeleteAccountsResponse detected');\n                }\n                const errMsgToError = (msg) => {\n                    // We unconditionally set force=true, so the 'NOT_DISABLED' error\n                    // should not be possible.\n                    const code = msg && msg.startsWith('NOT_DISABLED') ?\n                        error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;\n                    return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);\n                };\n                return {\n                    index: batchDeleteErrorInfo.index,\n                    error: errMsgToError(batchDeleteErrorInfo.message),\n                };\n            });\n            return result;\n        });\n    }\n    /**\n     * Updates an existing user.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` corresponding to the user to update.\n     * @param properties - The properties to update on\n     *   the provided user.\n     *\n     * @returns A promise fulfilled with the\n     *   updated user data.\n     */\n    updateUser(uid, properties) {\n        // Although we don't really advertise it, we want to also handle linking of\n        // non-federated idps with this call. So if we detect one of them, we'll\n        // adjust the properties parameter appropriately. This *does* imply that a\n        // conflict could arise, e.g. if the user provides a phoneNumber property,\n        // but also provides a providerToLink with a 'phone' provider id. In that\n        // case, we'll throw an error.\n        properties = (0, deep_copy_1.deepCopy)(properties);\n        if (properties?.providerToLink) {\n            if (properties.providerToLink.providerId === 'email') {\n                if (typeof properties.email !== 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To \"\n                        + 'link to the email/password provider, only specify the UpdateRequest.email field.');\n                }\n                properties.email = properties.providerToLink.uid;\n                delete properties.providerToLink;\n            }\n            else if (properties.providerToLink.providerId === 'phone') {\n                if (typeof properties.phoneNumber !== 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To \"\n                        + 'link to a phone provider, only specify the UpdateRequest.phoneNumber field.');\n                }\n                properties.phoneNumber = properties.providerToLink.uid;\n                delete properties.providerToLink;\n            }\n        }\n        if (properties?.providersToUnlink) {\n            if (properties.providersToUnlink.indexOf('phone') !== -1) {\n                // If we've been told to unlink the phone provider both via setting\n                // phoneNumber to null *and* by setting providersToUnlink to include\n                // 'phone', then we'll reject that. Though it might also be reasonable\n                // to relax this restriction and just unlink it.\n                if (properties.phoneNumber === null) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To \"\n                        + 'unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.');\n                }\n            }\n        }\n        return this.authRequestHandler.updateExistingAccount(uid, properties)\n            .then((existingUid) => {\n            // Return the corresponding user record.\n            return this.getUser(existingUid);\n        });\n    }\n    /**\n     * Sets additional developer claims on an existing user identified by the\n     * provided `uid`, typically used to define user roles and levels of\n     * access. These claims should propagate to all devices where the user is\n     * already signed in (after token expiration or when token refresh is forced)\n     * and the next time the user signs in. If a reserved OIDC claim name\n     * is used (sub, iat, iss, etc), an error is thrown. They are set on the\n     * authenticated user's ID token JWT.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |\n     * Defining user roles and access levels}\n     * for code samples and detailed documentation.\n     *\n     * @param uid - The `uid` of the user to edit.\n     * @param customUserClaims - The developer claims to set. If null is\n     *   passed, existing custom claims are deleted. Passing a custom claims payload\n     *   larger than 1000 bytes will throw an error. Custom claims are added to the\n     *   user's ID token which is transmitted on every authenticated request.\n     *   For profile non-access related user attributes, use database or other\n     *   separate storage systems.\n     * @returns A promise that resolves when the operation completes\n     *   successfully.\n     */\n    setCustomUserClaims(uid, customUserClaims) {\n        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)\n            .then(() => {\n            // Return nothing on success.\n        });\n    }\n    /**\n     * Revokes all refresh tokens for an existing user.\n     *\n     * This API will update the user's {@link UserRecord.tokensValidAfterTime} to\n     * the current UTC. It is important that the server on which this is called has\n     * its clock set correctly and synchronized.\n     *\n     * While this will revoke all sessions for a specified user and disable any\n     * new ID tokens for existing sessions from getting minted, existing ID tokens\n     * may remain active until their natural expiration (one hour). To verify that\n     * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}\n     * where `checkRevoked` is set to true.\n     *\n     * @param uid - The `uid` corresponding to the user whose refresh tokens\n     *   are to be revoked.\n     *\n     * @returns An empty promise fulfilled once the user's refresh\n     *   tokens have been revoked.\n     */\n    revokeRefreshTokens(uid) {\n        return this.authRequestHandler.revokeRefreshTokens(uid)\n            .then(() => {\n            // Return nothing on success.\n        });\n    }\n    /**\n     * Imports the provided list of users into Firebase Auth.\n     * A maximum of 1000 users are allowed to be imported one at a time.\n     * When importing users with passwords,\n     * {@link UserImportOptions} are required to be\n     * specified.\n     * This operation is optimized for bulk imports and will ignore checks on `uid`,\n     * `email` and other identifier uniqueness which could result in duplications.\n     *\n     * @param users - The list of user records to import to Firebase Auth.\n     * @param options - The user import options, required when the users provided include\n     *   password credentials.\n     * @returns A promise that resolves when\n     *   the operation completes with the result of the import. This includes the\n     *   number of successful imports, the number of failed imports and their\n     *   corresponding errors.\n    */\n    importUsers(users, options) {\n        return this.authRequestHandler.uploadAccount(users, options);\n    }\n    /**\n     * Creates a new Firebase session cookie with the specified options. The created\n     * JWT string can be set as a server-side session cookie with a custom cookie\n     * policy, and be used for session management. The session cookie JWT will have\n     * the same payload claims as the provided ID token.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}\n     * for code samples and detailed documentation.\n     *\n     * @param idToken - The Firebase ID token to exchange for a session\n     *   cookie.\n     * @param sessionCookieOptions - The session\n     *   cookie options which includes custom session duration.\n     *\n     * @returns A promise that resolves on success with the\n     *   created session cookie.\n     */\n    createSessionCookie(idToken, sessionCookieOptions) {\n        // Return rejected promise if expiresIn is not available.\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n    }\n    /**\n     * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.\n     * Rejects the promise if the cookie could not be verified.\n     *\n     * If `checkRevoked` is set to true, first verifies whether the corresponding\n     * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,\n     * verifies if the session corresponding to the session cookie was revoked.\n     * If the corresponding user's session was invalidated, an\n     * `auth/session-cookie-revoked` error is thrown. If not specified the check\n     * is not performed.\n     *\n     * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |\n     * Verify Session Cookies}\n     * for code samples and detailed documentation\n     *\n     * @param sessionCookie - The session cookie to verify.\n     * @param checkForRevocation -  Whether to check if the session cookie was\n     *   revoked. This requires an extra request to the Firebase Auth backend to\n     *   check the `tokensValidAfterTime` time for the corresponding user.\n     *   When not specified, this additional check is not performed.\n     *\n     * @returns A promise fulfilled with the\n     *   session cookie's decoded claims if the session cookie is valid; otherwise,\n     *   a rejected promise.\n     */\n    verifySessionCookie(sessionCookie, checkRevoked = false) {\n        const isEmulator = (0, auth_api_request_1.useEmulator)();\n        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator)\n            .then((decodedIdToken) => {\n            // Whether to check if the token was revoked.\n            if (checkRevoked || isEmulator) {\n                return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n            }\n            return decodedIdToken;\n        });\n    }\n    /**\n     * Generates the out of band email action link to reset a user's password.\n     * The link is generated for the user with the specified email address. The\n     * optional  {@link ActionCodeSettings} object\n     * defines whether the link is to be handled by a mobile app or browser and the\n     * additional state information to be passed in the deep link, etc.\n     *\n     * @example\n     * ```javascript\n     * var actionCodeSettings = {\n     *   url: 'https://www.example.com/?email=user@example.com',\n     *   iOS: {\n     *     bundleId: 'com.example.ios'\n     *   },\n     *   android: {\n     *     packageName: 'com.example.android',\n     *     installApp: true,\n     *     minimumVersion: '12'\n     *   },\n     *   handleCodeInApp: true,\n     *   dynamicLinkDomain: 'custom.page.link'\n     * };\n     * admin.auth()\n     *     .generatePasswordResetLink('user@example.com', actionCodeSettings)\n     *     .then(function(link) {\n     *       // The link was successfully generated.\n     *     })\n     *     .catch(function(error) {\n     *       // Some error occurred, you can inspect the code: error.code\n     *     });\n     * ```\n     *\n     * @param email - The email address of the user whose password is to be\n     *   reset.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the password reset link. The default password\n     *     reset landing page will use this to display a link to go back to the app\n     *     if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is whitelisted by the\n     *     developer in the console. Otherwise an error is thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    generatePasswordResetLink(email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n    }\n    /**\n     * Generates the out of band email action link to verify the user's ownership\n     * of the specified email. The {@link ActionCodeSettings} object provided\n     * as an argument to this method defines whether the link is to be handled by a\n     * mobile app or browser along with additional state information to be passed in\n     * the deep link, etc.\n     *\n     * @example\n     * ```javascript\n     * var actionCodeSettings = {\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n     *   iOS: {\n     *     bundleId: 'com.example.ios'\n     *   },\n     *   android: {\n     *     packageName: 'com.example.android',\n     *     installApp: true,\n     *     minimumVersion: '12'\n     *   },\n     *   handleCodeInApp: true,\n     *   dynamicLinkDomain: 'custom.page.link'\n     * };\n     * admin.auth()\n     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n     *     .then(function(link) {\n     *       // The link was successfully generated.\n     *     })\n     *     .catch(function(error) {\n     *       // Some error occurred, you can inspect the code: error.code\n     *     });\n     * ```\n     *\n     * @param email - The email account to verify.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the email verification link. The default email\n     *     verification landing page will use this to display a link to go back to\n     *     the app if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is whitelisted by the\n     *     developer in the console. Otherwise an error is thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    generateEmailVerificationLink(email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n    }\n    /**\n     * Generates an out-of-band email action link to verify the user's ownership\n     * of the specified email. The {@link ActionCodeSettings} object provided\n     * as an argument to this method defines whether the link is to be handled by a\n     * mobile app or browser along with additional state information to be passed in\n     * the deep link, etc.\n     *\n     * @param email - The current email account.\n     * @param newEmail - The email address the account is being updated to.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the email verification link. The default email\n     *     verification landing page will use this to display a link to go back to\n     *     the app if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is authorized\n     *     in the console, or an error will be thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('VERIFY_AND_CHANGE_EMAIL', email, actionCodeSettings, newEmail);\n    }\n    /**\n     * Generates the out of band email action link to verify the user's ownership\n     * of the specified email. The {@link ActionCodeSettings} object provided\n     * as an argument to this method defines whether the link is to be handled by a\n     * mobile app or browser along with additional state information to be passed in\n     * the deep link, etc.\n     *\n     * @example\n     * ```javascript\n     * var actionCodeSettings = {\n     *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',\n     *   iOS: {\n     *     bundleId: 'com.example.ios'\n     *   },\n     *   android: {\n     *     packageName: 'com.example.android',\n     *     installApp: true,\n     *     minimumVersion: '12'\n     *   },\n     *   handleCodeInApp: true,\n     *   dynamicLinkDomain: 'custom.page.link'\n     * };\n     * admin.auth()\n     *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)\n     *     .then(function(link) {\n     *       // The link was successfully generated.\n     *     })\n     *     .catch(function(error) {\n     *       // Some error occurred, you can inspect the code: error.code\n     *     });\n     * ```\n     *\n     * @param email - The email account to verify.\n     * @param actionCodeSettings - The action\n     *     code settings. If specified, the state/continue URL is set as the\n     *     \"continueUrl\" parameter in the email verification link. The default email\n     *     verification landing page will use this to display a link to go back to\n     *     the app if it is installed.\n     *     If the actionCodeSettings is not specified, no URL is appended to the\n     *     action URL.\n     *     The state URL provided must belong to a domain that is whitelisted by the\n     *     developer in the console. Otherwise an error is thrown.\n     *     Mobile app redirects are only applicable if the developer configures\n     *     and accepts the Firebase Dynamic Links terms of service.\n     *     The Android package name and iOS bundle ID are respected only if they\n     *     are configured in the same Firebase Auth project.\n     * @returns A promise that resolves with the generated link.\n     */\n    generateSignInWithEmailLink(email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n    }\n    /**\n     * Returns the list of existing provider configurations matching the filter\n     * provided. At most, 100 provider configs can be listed at a time.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param options - The provider config filter to apply.\n     * @returns A promise that resolves with the list of provider configs meeting the\n     *   filter requirements.\n     */\n    listProviderConfigs(options) {\n        const processResponse = (response, providerConfigs) => {\n            // Return list of provider configuration and the next page token if available.\n            const result = {\n                providerConfigs,\n            };\n            // Delete result.pageToken if undefined.\n            if (Object.prototype.hasOwnProperty.call(response, 'nextPageToken')) {\n                result.pageToken = response.nextPageToken;\n            }\n            return result;\n        };\n        if (options && options.type === 'oidc') {\n            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)\n                .then((response) => {\n                // List of provider configurations to return.\n                const providerConfigs = [];\n                // Convert each provider config response to a OIDCConfig.\n                response.oauthIdpConfigs.forEach((configResponse) => {\n                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        else if (options && options.type === 'saml') {\n            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)\n                .then((response) => {\n                // List of provider configurations to return.\n                const providerConfigs = [];\n                // Convert each provider config response to a SAMLConfig.\n                response.inboundSamlConfigs.forEach((configResponse) => {\n                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"AuthProviderConfigFilter.type\" must be either \"saml\" or \"oidc\"'));\n    }\n    /**\n     * Looks up an Auth provider configuration by the provided ID.\n     * Returns a promise that resolves with the provider configuration\n     * corresponding to the provider ID specified. If the specified ID does not\n     * exist, an `auth/configuration-not-found` error is thrown.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param providerId - The provider ID corresponding to the provider\n     *     config to return.\n     * @returns A promise that resolves\n     *     with the configuration corresponding to the provided ID.\n     */\n    getProviderConfig(providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getOAuthIdpConfig(providerId)\n                .then((response) => {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getInboundSamlConfig(providerId)\n                .then((response) => {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    /**\n     * Deletes the provider configuration corresponding to the provider ID passed.\n     * If the specified ID does not exist, an `auth/configuration-not-found` error\n     * is thrown.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param providerId - The provider ID corresponding to the provider\n     *     config to delete.\n     * @returns A promise that resolves on completion.\n     */\n    deleteProviderConfig(providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    /**\n     * Returns a promise that resolves with the updated `AuthProviderConfig`\n     * corresponding to the provider ID specified.\n     * If the specified ID does not exist, an `auth/configuration-not-found` error\n     * is thrown.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param providerId - The provider ID corresponding to the provider\n     *     config to update.\n     * @param updatedConfig - The updated configuration.\n     * @returns A promise that resolves with the updated provider configuration.\n     */\n    updateProviderConfig(providerId, updatedConfig) {\n        if (!validator.isNonNullObject(updatedConfig)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)\n                .then((response) => {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)\n                .then((response) => {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    /**\n     * Returns a promise that resolves with the newly created `AuthProviderConfig`\n     * when the new provider configuration is created.\n     *\n     * SAML and OIDC provider support requires Google Cloud's Identity Platform\n     * (GCIP). To learn more about GCIP, including pricing and features,\n     * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n     *\n     * @param config - The provider configuration to create.\n     * @returns A promise that resolves with the created provider configuration.\n     */\n    createProviderConfig(config) {\n        if (!validator.isNonNullObject(config)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createOAuthIdpConfig(config)\n                .then((response) => {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createInboundSamlConfig(config)\n                .then((response) => {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n    /** @alpha */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    _verifyAuthBlockingToken(token, audience) {\n        const isEmulator = (0, auth_api_request_1.useEmulator)();\n        return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience)\n            .then((decodedAuthBlockingToken) => {\n            return decodedAuthBlockingToken;\n        });\n    }\n    /**\n     * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that\n     * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked\n     * or user disabled.\n     *\n     * @param decodedIdToken - The JWT's decoded claims.\n     * @param revocationErrorInfo - The revocation error info to throw on revocation\n     *     detection.\n     * @returns A promise that will be fulfilled after a successful verification.\n     */\n    verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {\n        // Get tokens valid after time for the corresponding user.\n        return this.getUser(decodedIdToken.sub)\n            .then((user) => {\n            if (user.disabled) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, 'The user record is disabled.');\n            }\n            // If no tokens valid after time available, token is not revoked.\n            if (user.tokensValidAfterTime) {\n                // Get the ID token authentication time and convert to milliseconds UTC.\n                const authTimeUtc = decodedIdToken.auth_time * 1000;\n                // Get user tokens valid after time in milliseconds UTC.\n                const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\n                // Check if authentication time is older than valid since time.\n                if (authTimeUtc < validSinceUtc) {\n                    throw new error_1.FirebaseAuthError(revocationErrorInfo);\n                }\n            }\n            // All checks above passed. Return the decoded token.\n            return decodedIdToken;\n        });\n    }\n}\nexports.BaseAuth = BaseAuth;\n"],"mappings":"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ElC,kBAAkB,CAACU,WAAW,EAAE,CAAC;IACxD,OAAO,IAAI,CAACS,qBAAqB,CAACgB,SAAS,CAACkG,aAAa,EAAEnG,UAAU,CAAC,CACjEE,IAAI,CAAEC,cAAc,IAAK;MAC1B;MACA,IAAIP,YAAY,IAAII,UAAU,EAAE;QAC5B,OAAO,IAAI,CAACI,oCAAoC,CAACD,cAAc,EAAEzC,OAAO,CAAC2C,mBAAmB,CAAC+F,sBAAsB,CAAC;MACxH;MACA,OAAOjG,cAAc;IACzB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkG,yBAAyBA,CAACxF,KAAK,EAAEyF,kBAAkB,EAAE;IACjD,OAAO,IAAI,CAACvH,kBAAkB,CAACwH,kBAAkB,CAAC,gBAAgB,EAAE1F,KAAK,EAAEyF,kBAAkB,CAAC;EAClG;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,6BAA6BA,CAAC3F,KAAK,EAAEyF,kBAAkB,EAAE;IACrD,OAAO,IAAI,CAACvH,kBAAkB,CAACwH,kBAAkB,CAAC,cAAc,EAAE1F,KAAK,EAAEyF,kBAAkB,CAAC;EAChG;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,gCAAgCA,CAAC5F,KA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}