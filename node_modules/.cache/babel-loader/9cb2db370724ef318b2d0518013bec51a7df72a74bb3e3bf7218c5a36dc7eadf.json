{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nconst AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n  phone: 'PHONE_SMS'\n};\n/** Server Auth factor type to client auth factor type mapping. */\nconst AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce((res, key) => {\n  res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n  return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass MultiFactorAuthConfig {\n  /**\n   * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    MultiFactorAuthConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n      request.state = options.state;\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n      (options.factorIds || []).forEach(factorId => {\n        if (typeof request.enabledProviders === 'undefined') {\n          request.enabledProviders = [];\n        }\n        request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n      });\n      // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n      if (options.factorIds && options.factorIds.length === 0) {\n        request.enabledProviders = [];\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'providerConfigs')) {\n      request.providerConfigs = options.providerConfigs;\n    }\n    return request;\n  }\n  /**\n   * Validates the MultiFactorConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    const validKeys = {\n      state: true,\n      factorIds: true,\n      providerConfigs: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid MultiFactorConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.state !== 'undefined' && options.state !== 'ENABLED' && options.state !== 'DISABLED') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n    }\n    if (typeof options.factorIds !== 'undefined') {\n      if (!validator.isArray(options.factorIds)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n      }\n      // Validate content of array.\n      options.factorIds.forEach(factorId => {\n        if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${factorId}\" is not a valid \"AuthFactorType\".`);\n        }\n      });\n    }\n    if (typeof options.providerConfigs !== 'undefined') {\n      if (!validator.isArray(options.providerConfigs)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs\" must be an array of valid \"MultiFactorProviderConfig.\"');\n      }\n      //Validate content of array.\n      options.providerConfigs.forEach(multiFactorProviderConfig => {\n        if (typeof multiFactorProviderConfig === 'undefined' || !validator.isObject(multiFactorProviderConfig)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${multiFactorProviderConfig}\" is not a valid \"MultiFactorProviderConfig\" type.`);\n        }\n        const validProviderConfigKeys = {\n          state: true,\n          totpProviderConfig: true\n        };\n        for (const key in multiFactorProviderConfig) {\n          if (!(key in validProviderConfigKeys)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid ProviderConfig parameter.`);\n          }\n        }\n        if (typeof multiFactorProviderConfig.state === 'undefined' || multiFactorProviderConfig.state !== 'ENABLED' && multiFactorProviderConfig.state !== 'DISABLED') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.state\" must be either \"ENABLED\" or \"DISABLED\".');\n        }\n        // Since TOTP is the only provider config available right now, not defining it will lead into an error\n        if (typeof multiFactorProviderConfig.totpProviderConfig === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.totpProviderConfig\" must be defined.');\n        }\n        const validTotpProviderConfigKeys = {\n          adjacentIntervals: true\n        };\n        for (const key in multiFactorProviderConfig.totpProviderConfig) {\n          if (!(key in validTotpProviderConfigKeys)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid TotpProviderConfig parameter.`);\n          }\n        }\n        const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;\n        if (typeof adjIntervals !== 'undefined' && (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals\" must' + ' be a valid number between 0 and 10 (both inclusive).');\n        }\n      });\n    }\n  }\n  /**\n   * The MultiFactorAuthConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     MultiFactorAuthConfig object.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    if (typeof response.state === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n    }\n    this.state = response.state;\n    this.factorIds = [];\n    (response.enabledProviders || []).forEach(enabledProvider => {\n      // Ignore unsupported types. It is possible the current admin SDK version is\n      // not up to date and newer backend types are supported.\n      if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n        this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n      }\n    });\n    this.providerConfigs = [];\n    (response.providerConfigs || []).forEach(providerConfig => {\n      if (typeof providerConfig !== 'undefined') {\n        if (typeof providerConfig.state === 'undefined' || typeof providerConfig.totpProviderConfig === 'undefined' || typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'undefined' && typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'number') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n        }\n        this.providerConfigs.push(providerConfig);\n      }\n    });\n  }\n  /** Converts MultiFactorConfig to JSON object\n   * @returns The plain object representation of the multi-factor config instance. */\n  toJSON() {\n    return {\n      state: this.state,\n      factorIds: this.factorIds,\n      providerConfigs: this.providerConfigs\n    };\n  }\n}\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers - The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n  if (!validator.isObject(testPhoneNumbers)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n  }\n  if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n  }\n  for (const phoneNumber in testPhoneNumbers) {\n    // Validate phone number.\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${phoneNumber}\" is not a valid E.164 standard compliant phone number.`);\n    }\n    // Validate code.\n    if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${testPhoneNumbers[phoneNumber]}\" is not a valid 6 digit code string.`);\n    }\n  }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass EmailSignInConfig {\n  /**\n   * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    EmailSignInConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n      request.allowPasswordSignup = options.enabled;\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n      request.enableEmailLinkSignin = !options.passwordRequired;\n    }\n    return request;\n  }\n  /**\n   * Validates the EmailSignInConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    // TODO: Validate the request.\n    const validKeys = {\n      enabled: true,\n      passwordRequired: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${key}\" is not a valid EmailSignInConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.passwordRequired !== 'undefined' && !validator.isBoolean(options.passwordRequired)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n    }\n  }\n  /**\n   * The EmailSignInConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     EmailSignInConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (typeof response.allowPasswordSignup === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n    }\n    this.enabled = response.allowPasswordSignup;\n    this.passwordRequired = !response.enableEmailLinkSignin;\n  }\n  /** @returns The plain object representation of the email sign-in config. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      passwordRequired: this.passwordRequired\n    };\n  }\n}\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass SAMLConfig {\n  /**\n   * Converts a client side request to a SAMLConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a SAMLConfig request,\n   * returns null.\n   *\n   * @param options - The options object to convert to a server request.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   * @returns The resulting server request or null if not valid.\n   */\n  static buildServerRequest(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n    if (!makeRequest) {\n      return null;\n    }\n    const request = {};\n    // Validate options.\n    SAMLConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    // IdP config.\n    if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n      request.idpConfig = {\n        idpEntityId: options.idpEntityId,\n        ssoUrl: options.ssoURL,\n        signRequest: options.enableRequestSigning,\n        idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : []\n      };\n      if (options.x509Certificates) {\n        for (const cert of options.x509Certificates || []) {\n          request.idpConfig.idpCertificates.push({\n            x509Certificate: cert\n          });\n        }\n      }\n    }\n    // RP config.\n    if (options.callbackURL || options.rpEntityId) {\n      request.spConfig = {\n        spEntityId: options.rpEntityId,\n        callbackUri: options.callbackURL\n      };\n    }\n    return request;\n  }\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param resourceName - The server side resource name.\n   * @returns The provider ID corresponding to the resource, null otherwise.\n   */\n  static getProviderIdFromResourceName(resourceName) {\n    // name is of form projects/project1/inboundSamlConfigs/providerId1\n    const matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n    return matchProviderRes[1];\n  }\n  /**\n   * @param providerId - The provider ID to check.\n   * @returns Whether the provider ID corresponds to a SAML provider.\n   */\n  static isProviderId(providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n  }\n  /**\n   * Validates the SAMLConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   */\n  static validate(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      idpEntityId: true,\n      ssoURL: true,\n      x509Certificates: true,\n      rpEntityId: true,\n      callbackURL: true,\n      enableRequestSigning: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SAML config parameter.`);\n      }\n    }\n    // Required fields.\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('saml.') !== 0) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      // providerId is required and not provided correctly.\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n    }\n    if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') && !validator.isNonEmptyString(options.idpEntityId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') && !validator.isURL(options.ssoURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n    }\n    if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') && !validator.isNonEmptyString(options.rpEntityId)) {\n      throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') && !validator.isURL(options.callbackURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n    }\n    if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') && !validator.isArray(options.x509Certificates)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n    }\n    (options.x509Certificates || []).forEach(cert => {\n      if (!validator.isNonEmptyString(cert)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n      }\n    });\n    if (typeof options.enableRequestSigning !== 'undefined' && !validator.isBoolean(options.enableRequestSigning)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n    }\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  }\n  /**\n   * The SAMLConfig constructor.\n   *\n   * @param response - The server side response used to initialize the SAMLConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && SAMLConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    this.providerId = providerId;\n    // RP config.\n    this.rpEntityId = response.spConfig.spEntityId;\n    this.callbackURL = response.spConfig.callbackUri;\n    // IdP config.\n    this.idpEntityId = response.idpConfig.idpEntityId;\n    this.ssoURL = response.idpConfig.ssoUrl;\n    this.enableRequestSigning = !!response.idpConfig.signRequest;\n    const x509Certificates = [];\n    for (const cert of response.idpConfig.idpCertificates || []) {\n      if (cert.x509Certificate) {\n        x509Certificates.push(cert.x509Certificate);\n      }\n    }\n    this.x509Certificates = x509Certificates;\n    // When enabled is undefined, it takes its default value of false.\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n  }\n  /** @returns The plain object representation of the SAMLConfig. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      idpEntityId: this.idpEntityId,\n      ssoURL: this.ssoURL,\n      x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),\n      rpEntityId: this.rpEntityId,\n      callbackURL: this.callbackURL,\n      enableRequestSigning: this.enableRequestSigning\n    };\n  }\n}\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass OIDCConfig {\n  /**\n   * Converts a client side request to a OIDCConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a OIDCConfig request,\n   * returns null.\n   *\n   * @param options - The options object to convert to a server request.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   * @returns The resulting server request or null if not valid.\n   */\n  static buildServerRequest(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n    if (!makeRequest) {\n      return null;\n    }\n    const request = {};\n    // Validate options.\n    OIDCConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    request.issuer = options.issuer;\n    request.clientId = options.clientId;\n    if (typeof options.clientSecret !== 'undefined') {\n      request.clientSecret = options.clientSecret;\n    }\n    if (typeof options.responseType !== 'undefined') {\n      request.responseType = options.responseType;\n    }\n    return request;\n  }\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param resourceName - The server side resource name\n   * @returns The provider ID corresponding to the resource, null otherwise.\n   */\n  static getProviderIdFromResourceName(resourceName) {\n    // name is of form projects/project1/oauthIdpConfigs/providerId1\n    const matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n    return matchProviderRes[1];\n  }\n  /**\n   * @param providerId - The provider ID to check.\n   * @returns Whether the provider ID corresponds to an OIDC provider.\n   */\n  static isProviderId(providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n  }\n  /**\n   * Validates the OIDCConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   */\n  static validate(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      clientId: true,\n      issuer: true,\n      clientSecret: true,\n      responseType: true\n    };\n    const validResponseTypes = {\n      idToken: true,\n      code: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OIDC config parameter.`);\n      }\n    }\n    // Required fields.\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('oidc.') !== 0) {\n        throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n    }\n    if (!(ignoreMissingFields && typeof options.clientId === 'undefined') && !validator.isNonEmptyString(options.clientId)) {\n      throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.issuer === 'undefined') && !validator.isURL(options.issuer)) {\n      throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n    }\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n    }\n    if (typeof options.clientSecret !== 'undefined' && !validator.isNonEmptyString(options.clientSecret)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n    }\n    if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n      Object.keys(options.responseType).forEach(key => {\n        if (!(key in validResponseTypes)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OAuthResponseType parameter.`);\n        }\n      });\n      const idToken = options.responseType.idToken;\n      if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n      }\n      const code = options.responseType.code;\n      if (typeof code !== 'undefined') {\n        if (!validator.isBoolean(code)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n        }\n        // If code flow is enabled, client secret must be provided.\n        if (code && typeof options.clientSecret === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n        }\n      }\n      const allKeys = Object.keys(options.responseType).length;\n      const enabledCount = Object.values(options.responseType).filter(Boolean).length;\n      // Only one of OAuth response types can be set to true.\n      if (allKeys > 1 && enabledCount !== 1) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n      }\n    }\n  }\n  /**\n   * The OIDCConfig constructor.\n   *\n   * @param response - The server side response used to initialize the OIDCConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && OIDCConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n    }\n    const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    this.providerId = providerId;\n    this.clientId = response.clientId;\n    this.issuer = response.issuer;\n    // When enabled is undefined, it takes its default value of false.\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n    if (typeof response.clientSecret !== 'undefined') {\n      this.clientSecret = response.clientSecret;\n    }\n    if (typeof response.responseType !== 'undefined') {\n      this.responseType = response.responseType;\n    }\n  }\n  /** @returns The plain object representation of the OIDCConfig. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      issuer: this.issuer,\n      clientId: this.clientId,\n      clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),\n      responseType: (0, deep_copy_1.deepCopy)(this.responseType)\n    };\n  }\n}\nexports.OIDCConfig = OIDCConfig;\n/**\n * Defines the SMSRegionConfig class used for validation.\n *\n * @internal\n */\nclass SmsRegionsAuthConfig {\n  static validate(options) {\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig\" must be a non-null object.');\n    }\n    const validKeys = {\n      allowlistOnly: true,\n      allowByDefault: true\n    };\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig parameter.`);\n      }\n    }\n    // validate mutual exclusiveness of allowByDefault and allowlistOnly\n    if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both \"allowByDefault\" and \"allowlistOnly\" parameters.');\n    }\n    // validation for allowByDefault type\n    if (typeof options.allowByDefault !== 'undefined') {\n      const allowByDefaultValidKeys = {\n        disallowedRegions: true\n      };\n      for (const key in options.allowByDefault) {\n        if (!(key in allowByDefaultValidKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowByDefault parameter.`);\n        }\n      }\n      // disallowedRegion can be empty.\n      if (typeof options.allowByDefault.disallowedRegions !== 'undefined' && !validator.isArray(options.allowByDefault.disallowedRegions)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowByDefault.disallowedRegions\" must be a valid string array.');\n      }\n    }\n    if (typeof options.allowlistOnly !== 'undefined') {\n      const allowListOnlyValidKeys = {\n        allowedRegions: true\n      };\n      for (const key in options.allowlistOnly) {\n        if (!(key in allowListOnlyValidKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowlistOnly parameter.`);\n        }\n      }\n      // allowedRegions can be empty\n      if (typeof options.allowlistOnly.allowedRegions !== 'undefined' && !validator.isArray(options.allowlistOnly.allowedRegions)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowlistOnly.allowedRegions\" must be a valid string array.');\n      }\n    }\n  }\n}\nexports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;\nclass RecaptchaAuthConfig {\n  constructor(recaptchaConfig) {\n    this.emailPasswordEnforcementState = recaptchaConfig.emailPasswordEnforcementState;\n    this.managedRules = recaptchaConfig.managedRules;\n    this.recaptchaKeys = recaptchaConfig.recaptchaKeys;\n    this.useAccountDefender = recaptchaConfig.useAccountDefender;\n  }\n  /**\n   * Validates the RecaptchaConfig options object. Throws an error on failure.\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    const validKeys = {\n      emailPasswordEnforcementState: true,\n      managedRules: true,\n      recaptchaKeys: true,\n      useAccountDefender: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig\" must be a non-null object.');\n    }\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaConfig parameter.`);\n      }\n    }\n    // Validation\n    if (typeof options.emailPasswordEnforcementState !== undefined) {\n      if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be a valid non-empty string.');\n      }\n      if (options.emailPasswordEnforcementState !== 'OFF' && options.emailPasswordEnforcementState !== 'AUDIT' && options.emailPasswordEnforcementState !== 'ENFORCE') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be either \"OFF\", \"AUDIT\" or \"ENFORCE\".');\n      }\n    }\n    if (typeof options.managedRules !== 'undefined') {\n      // Validate array\n      if (!validator.isArray(options.managedRules)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.managedRules\" must be an array of valid \"RecaptchaManagedRule\".');\n      }\n      // Validate each rule of the array\n      options.managedRules.forEach(managedRule => {\n        RecaptchaAuthConfig.validateManagedRule(managedRule);\n      });\n    }\n    if (typeof options.useAccountDefender !== 'undefined') {\n      if (!validator.isBoolean(options.useAccountDefender)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useAccountDefender\" must be a boolean value\".');\n      }\n    }\n  }\n  /**\n   * Validate each element in ManagedRule array\n   * @param options - The options object to validate.\n   */\n  static validateManagedRule(options) {\n    const validKeys = {\n      endScore: true,\n      action: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaManagedRule parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.action !== 'undefined' && options.action !== 'BLOCK') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule.action\" must be \"BLOCK\".');\n    }\n  }\n  /**\n   * Returns a JSON-serializable representation of this object.\n   * @returns The JSON-serializable object representation of the ReCaptcha config instance\n   */\n  toJSON() {\n    const json = {\n      emailPasswordEnforcementState: this.emailPasswordEnforcementState,\n      managedRules: (0, deep_copy_1.deepCopy)(this.managedRules),\n      recaptchaKeys: (0, deep_copy_1.deepCopy)(this.recaptchaKeys),\n      useAccountDefender: this.useAccountDefender\n    };\n    if (typeof json.emailPasswordEnforcementState === 'undefined') {\n      delete json.emailPasswordEnforcementState;\n    }\n    if (typeof json.managedRules === 'undefined') {\n      delete json.managedRules;\n    }\n    if (typeof json.recaptchaKeys === 'undefined') {\n      delete json.recaptchaKeys;\n    }\n    if (typeof json.useAccountDefender === 'undefined') {\n      delete json.useAccountDefender;\n    }\n    return json;\n  }\n}\nexports.RecaptchaAuthConfig = RecaptchaAuthConfig;\n/**\n * Defines the password policy config class used to convert client side PasswordPolicyConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass PasswordPolicyAuthConfig {\n  /**\n   * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    PasswordPolicyAuthConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'enforcementState')) {\n      request.passwordPolicyEnforcementState = options.enforcementState;\n    }\n    request.forceUpgradeOnSignin = false;\n    if (Object.prototype.hasOwnProperty.call(options, 'forceUpgradeOnSignin')) {\n      request.forceUpgradeOnSignin = options.forceUpgradeOnSignin;\n    }\n    const constraintsRequest = {\n      containsUppercaseCharacter: false,\n      containsLowercaseCharacter: false,\n      containsNonAlphanumericCharacter: false,\n      containsNumericCharacter: false,\n      minPasswordLength: 6,\n      maxPasswordLength: 4096\n    };\n    request.passwordPolicyVersions = [];\n    if (Object.prototype.hasOwnProperty.call(options, 'constraints')) {\n      if (options) {\n        if (options.constraints?.requireUppercase !== undefined) {\n          constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;\n        }\n        if (options.constraints?.requireLowercase !== undefined) {\n          constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;\n        }\n        if (options.constraints?.requireNonAlphanumeric !== undefined) {\n          constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;\n        }\n        if (options.constraints?.requireNumeric !== undefined) {\n          constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;\n        }\n        if (options.constraints?.minLength !== undefined) {\n          constraintsRequest.minPasswordLength = options.constraints.minLength;\n        }\n        if (options.constraints?.maxLength !== undefined) {\n          constraintsRequest.maxPasswordLength = options.constraints.maxLength;\n        }\n      }\n    }\n    request.passwordPolicyVersions.push({\n      customStrengthOptions: constraintsRequest\n    });\n    return request;\n  }\n  /**\n   * Validates the PasswordPolicyConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @internal\n   */\n  static validate(options) {\n    const validKeys = {\n      enforcementState: true,\n      forceUpgradeOnSignin: true,\n      constraints: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.enforcementState === 'undefined' || !(options.enforcementState === 'ENFORCE' || options.enforcementState === 'OFF')) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.enforcementState\" must be either \"ENFORCE\" or \"OFF\".');\n    }\n    if (typeof options.forceUpgradeOnSignin !== 'undefined') {\n      if (!validator.isBoolean(options.forceUpgradeOnSignin)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.forceUpgradeOnSignin\" must be a boolean.');\n      }\n    }\n    if (typeof options.constraints !== 'undefined') {\n      if (options.enforcementState === 'ENFORCE' && !validator.isNonNullObject(options.constraints)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be a non-empty object.');\n      }\n      const validCharKeys = {\n        requireUppercase: true,\n        requireLowercase: true,\n        requireNumeric: true,\n        requireNonAlphanumeric: true,\n        minLength: true,\n        maxLength: true\n      };\n      // Check for unsupported  attributes.\n      for (const key in options.constraints) {\n        if (!(key in validCharKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig.constraints parameter.`);\n        }\n      }\n      if (typeof options.constraints.requireUppercase !== undefined && !validator.isBoolean(options.constraints.requireUppercase)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireUppercase\" must be a boolean.');\n      }\n      if (typeof options.constraints.requireLowercase !== undefined && !validator.isBoolean(options.constraints.requireLowercase)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireLowercase\" must be a boolean.');\n      }\n      if (typeof options.constraints.requireNonAlphanumeric !== undefined && !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNonAlphanumeric\"' + ' must be a boolean.');\n      }\n      if (typeof options.constraints.requireNumeric !== undefined && !validator.isBoolean(options.constraints.requireNumeric)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNumeric\" must be a boolean.');\n      }\n      if (!validator.isNumber(options.constraints.minLength)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\" must be a number.');\n      }\n      if (!validator.isNumber(options.constraints.maxLength)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\" must be a number.');\n      }\n      if (options.constraints.minLength === undefined) {\n        options.constraints.minLength = 6;\n      } else {\n        if (!(options.constraints.minLength >= 6 && options.constraints.minLength <= 30)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\"' + ' must be an integer between 6 and 30, inclusive.');\n        }\n      }\n      if (options.constraints.maxLength === undefined) {\n        options.constraints.maxLength = 4096;\n      } else {\n        if (!(options.constraints.maxLength >= options.constraints.minLength && options.constraints.maxLength <= 4096)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\"' + ' must be greater than or equal to minLength and at max 4096.');\n        }\n      }\n    } else {\n      if (options.enforcementState === 'ENFORCE') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be defined.');\n      }\n    }\n  }\n  /**\n   * The PasswordPolicyAuthConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     PasswordPolicyAuthConfig object.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    if (typeof response.passwordPolicyEnforcementState === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid password policy configuration response');\n    }\n    this.enforcementState = response.passwordPolicyEnforcementState;\n    let constraintsResponse = {};\n    if (typeof response.passwordPolicyVersions !== 'undefined') {\n      (response.passwordPolicyVersions || []).forEach(policyVersion => {\n        constraintsResponse = {\n          requireLowercase: policyVersion.customStrengthOptions?.containsLowercaseCharacter,\n          requireUppercase: policyVersion.customStrengthOptions?.containsUppercaseCharacter,\n          requireNonAlphanumeric: policyVersion.customStrengthOptions?.containsNonAlphanumericCharacter,\n          requireNumeric: policyVersion.customStrengthOptions?.containsNumericCharacter,\n          minLength: policyVersion.customStrengthOptions?.minPasswordLength,\n          maxLength: policyVersion.customStrengthOptions?.maxPasswordLength\n        };\n      });\n    }\n    this.constraints = constraintsResponse;\n    this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;\n  }\n}\nexports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;","map":{"version":3,"names":["Object","defineProperty","exports","value","PasswordPolicyAuthConfig","RecaptchaAuthConfig","SmsRegionsAuthConfig","OIDCConfig","SAMLConfig","EmailSignInConfig","validateTestPhoneNumbers","MultiFactorAuthConfig","MAXIMUM_TEST_PHONE_NUMBERS","validator","require","deep_copy_1","error_1","AUTH_FACTOR_CLIENT_TO_SERVER_TYPE","phone","AUTH_FACTOR_SERVER_TO_CLIENT_TYPE","keys","reduce","res","key","buildServerRequest","options","request","validate","prototype","hasOwnProperty","call","state","factorIds","forEach","factorId","enabledProviders","push","length","providerConfigs","validKeys","isNonNullObject","FirebaseAuthError","AuthClientErrorCode","INVALID_CONFIG","isArray","multiFactorProviderConfig","isObject","validProviderConfigKeys","totpProviderConfig","validTotpProviderConfigKeys","adjacentIntervals","adjIntervals","Number","isInteger","INVALID_ARGUMENT","constructor","response","INTERNAL_ERROR","enabledProvider","providerConfig","toJSON","testPhoneNumbers","MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED","phoneNumber","isPhoneNumber","INVALID_TESTING_PHONE_NUMBER","isString","test","allowPasswordSignup","enabled","enableEmailLinkSignin","passwordRequired","isBoolean","ignoreMissingFields","arguments","undefined","makeRequest","providerId","displayName","idpEntityId","ssoURL","x509Certificates","idpConfig","ssoUrl","signRequest","enableRequestSigning","idpCertificates","cert","x509Certificate","callbackURL","rpEntityId","spConfig","spEntityId","callbackUri","getProviderIdFromResourceName","resourceName","matchProviderRes","match","isProviderId","isNonEmptyString","indexOf","INVALID_PROVIDER_ID","MISSING_PROVIDER_ID","isURL","MISSING_SAML_RELYING_PARTY_CONFIG","name","deepCopy","issuer","clientId","clientSecret","responseType","validResponseTypes","idToken","code","MISSING_OAUTH_CLIENT_ID","INVALID_OAUTH_CLIENT_ID","MISSING_ISSUER","MISSING_OAUTH_CLIENT_SECRET","allKeys","enabledCount","values","filter","Boolean","INVALID_OAUTH_RESPONSETYPE","allowlistOnly","allowByDefault","allowByDefaultValidKeys","disallowedRegions","allowListOnlyValidKeys","allowedRegions","recaptchaConfig","emailPasswordEnforcementState","managedRules","recaptchaKeys","useAccountDefender","managedRule","validateManagedRule","endScore","action","json","passwordPolicyEnforcementState","enforcementState","forceUpgradeOnSignin","constraintsRequest","containsUppercaseCharacter","containsLowercaseCharacter","containsNonAlphanumericCharacter","containsNumericCharacter","minPasswordLength","maxPasswordLength","passwordPolicyVersions","constraints","requireUppercase","requireLowercase","requireNonAlphanumeric","requireNumeric","minLength","maxLength","customStrengthOptions","validCharKeys","isNumber","constraintsResponse","policyVersion"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/auth/auth-config.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nconst AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n    phone: 'PHONE_SMS',\n};\n/** Server Auth factor type to client auth factor type mapping. */\nconst AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE)\n    .reduce((res, key) => {\n    res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n    return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass MultiFactorAuthConfig {\n    /**\n     * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        MultiFactorAuthConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n            request.state = options.state;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n            (options.factorIds || []).forEach((factorId) => {\n                if (typeof request.enabledProviders === 'undefined') {\n                    request.enabledProviders = [];\n                }\n                request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n            });\n            // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n            if (options.factorIds && options.factorIds.length === 0) {\n                request.enabledProviders = [];\n            }\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'providerConfigs')) {\n            request.providerConfigs = options.providerConfigs;\n        }\n        return request;\n    }\n    /**\n     * Validates the MultiFactorConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        const validKeys = {\n            state: true,\n            factorIds: true,\n            providerConfigs: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid MultiFactorConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.state !== 'undefined' &&\n            options.state !== 'ENABLED' &&\n            options.state !== 'DISABLED') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n        }\n        if (typeof options.factorIds !== 'undefined') {\n            if (!validator.isArray(options.factorIds)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n            }\n            // Validate content of array.\n            options.factorIds.forEach((factorId) => {\n                if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${factorId}\" is not a valid \"AuthFactorType\".`);\n                }\n            });\n        }\n        if (typeof options.providerConfigs !== 'undefined') {\n            if (!validator.isArray(options.providerConfigs)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs\" must be an array of valid \"MultiFactorProviderConfig.\"');\n            }\n            //Validate content of array.\n            options.providerConfigs.forEach((multiFactorProviderConfig) => {\n                if (typeof multiFactorProviderConfig === 'undefined' || !validator.isObject(multiFactorProviderConfig)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${multiFactorProviderConfig}\" is not a valid \"MultiFactorProviderConfig\" type.`);\n                }\n                const validProviderConfigKeys = {\n                    state: true,\n                    totpProviderConfig: true,\n                };\n                for (const key in multiFactorProviderConfig) {\n                    if (!(key in validProviderConfigKeys)) {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid ProviderConfig parameter.`);\n                    }\n                }\n                if (typeof multiFactorProviderConfig.state === 'undefined' ||\n                    (multiFactorProviderConfig.state !== 'ENABLED' &&\n                        multiFactorProviderConfig.state !== 'DISABLED')) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.state\" must be either \"ENABLED\" or \"DISABLED\".');\n                }\n                // Since TOTP is the only provider config available right now, not defining it will lead into an error\n                if (typeof multiFactorProviderConfig.totpProviderConfig === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.totpProviderConfig\" must be defined.');\n                }\n                const validTotpProviderConfigKeys = {\n                    adjacentIntervals: true,\n                };\n                for (const key in multiFactorProviderConfig.totpProviderConfig) {\n                    if (!(key in validTotpProviderConfigKeys)) {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid TotpProviderConfig parameter.`);\n                    }\n                }\n                const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;\n                if (typeof adjIntervals !== 'undefined' &&\n                    (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals\" must' +\n                        ' be a valid number between 0 and 10 (both inclusive).');\n                }\n            });\n        }\n    }\n    /**\n     * The MultiFactorAuthConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     MultiFactorAuthConfig object.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        if (typeof response.state === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n        }\n        this.state = response.state;\n        this.factorIds = [];\n        (response.enabledProviders || []).forEach((enabledProvider) => {\n            // Ignore unsupported types. It is possible the current admin SDK version is\n            // not up to date and newer backend types are supported.\n            if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n                this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n            }\n        });\n        this.providerConfigs = [];\n        (response.providerConfigs || []).forEach((providerConfig) => {\n            if (typeof providerConfig !== 'undefined') {\n                if (typeof providerConfig.state === 'undefined' ||\n                    typeof providerConfig.totpProviderConfig === 'undefined' ||\n                    (typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'undefined' &&\n                        typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'number')) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n                }\n                this.providerConfigs.push(providerConfig);\n            }\n        });\n    }\n    /** Converts MultiFactorConfig to JSON object\n     * @returns The plain object representation of the multi-factor config instance. */\n    toJSON() {\n        return {\n            state: this.state,\n            factorIds: this.factorIds,\n            providerConfigs: this.providerConfigs,\n        };\n    }\n}\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers - The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n    if (!validator.isObject(testPhoneNumbers)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n    }\n    if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n    }\n    for (const phoneNumber in testPhoneNumbers) {\n        // Validate phone number.\n        if (!validator.isPhoneNumber(phoneNumber)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${phoneNumber}\" is not a valid E.164 standard compliant phone number.`);\n        }\n        // Validate code.\n        if (!validator.isString(testPhoneNumbers[phoneNumber]) ||\n            !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${testPhoneNumbers[phoneNumber]}\" is not a valid 6 digit code string.`);\n        }\n    }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass EmailSignInConfig {\n    /**\n     * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        EmailSignInConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n            request.allowPasswordSignup = options.enabled;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n            request.enableEmailLinkSignin = !options.passwordRequired;\n        }\n        return request;\n    }\n    /**\n     * Validates the EmailSignInConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        // TODO: Validate the request.\n        const validKeys = {\n            enabled: true,\n            passwordRequired: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${key}\" is not a valid EmailSignInConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.passwordRequired !== 'undefined' &&\n            !validator.isBoolean(options.passwordRequired)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n        }\n    }\n    /**\n     * The EmailSignInConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     EmailSignInConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (typeof response.allowPasswordSignup === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n        }\n        this.enabled = response.allowPasswordSignup;\n        this.passwordRequired = !response.enableEmailLinkSignin;\n    }\n    /** @returns The plain object representation of the email sign-in config. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            passwordRequired: this.passwordRequired,\n        };\n    }\n}\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass SAMLConfig {\n    /**\n     * Converts a client side request to a SAMLConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a SAMLConfig request,\n     * returns null.\n     *\n     * @param options - The options object to convert to a server request.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     * @returns The resulting server request or null if not valid.\n     */\n    static buildServerRequest(options, ignoreMissingFields = false) {\n        const makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        const request = {};\n        // Validate options.\n        SAMLConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        // IdP config.\n        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n            request.idpConfig = {\n                idpEntityId: options.idpEntityId,\n                ssoUrl: options.ssoURL,\n                signRequest: options.enableRequestSigning,\n                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],\n            };\n            if (options.x509Certificates) {\n                for (const cert of (options.x509Certificates || [])) {\n                    request.idpConfig.idpCertificates.push({ x509Certificate: cert });\n                }\n            }\n        }\n        // RP config.\n        if (options.callbackURL || options.rpEntityId) {\n            request.spConfig = {\n                spEntityId: options.rpEntityId,\n                callbackUri: options.callbackURL,\n            };\n        }\n        return request;\n    }\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param resourceName - The server side resource name.\n     * @returns The provider ID corresponding to the resource, null otherwise.\n     */\n    static getProviderIdFromResourceName(resourceName) {\n        // name is of form projects/project1/inboundSamlConfigs/providerId1\n        const matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    }\n    /**\n     * @param providerId - The provider ID to check.\n     * @returns Whether the provider ID corresponds to a SAML provider.\n     */\n    static isProviderId(providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n    }\n    /**\n     * Validates the SAMLConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     */\n    static validate(options, ignoreMissingFields = false) {\n        const validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            idpEntityId: true,\n            ssoURL: true,\n            x509Certificates: true,\n            rpEntityId: true,\n            callbackURL: true,\n            enableRequestSigning: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SAML config parameter.`);\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('saml.') !== 0) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            // providerId is required and not provided correctly.\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.idpEntityId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&\n            !validator.isURL(options.ssoURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.rpEntityId)) {\n            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :\n                error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&\n            !validator.isURL(options.callbackURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&\n            !validator.isArray(options.x509Certificates)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n        }\n        (options.x509Certificates || []).forEach((cert) => {\n            if (!validator.isNonEmptyString(cert)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n            }\n        });\n        if (typeof options.enableRequestSigning !== 'undefined' &&\n            !validator.isBoolean(options.enableRequestSigning)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    }\n    /**\n     * The SAMLConfig constructor.\n     *\n     * @param response - The server side response used to initialize the SAMLConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (!response ||\n            !response.idpConfig ||\n            !response.idpConfig.idpEntityId ||\n            !response.idpConfig.ssoUrl ||\n            !response.spConfig ||\n            !response.spConfig.spEntityId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                SAMLConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        // RP config.\n        this.rpEntityId = response.spConfig.spEntityId;\n        this.callbackURL = response.spConfig.callbackUri;\n        // IdP config.\n        this.idpEntityId = response.idpConfig.idpEntityId;\n        this.ssoURL = response.idpConfig.ssoUrl;\n        this.enableRequestSigning = !!response.idpConfig.signRequest;\n        const x509Certificates = [];\n        for (const cert of (response.idpConfig.idpCertificates || [])) {\n            if (cert.x509Certificate) {\n                x509Certificates.push(cert.x509Certificate);\n            }\n        }\n        this.x509Certificates = x509Certificates;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /** @returns The plain object representation of the SAMLConfig. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            idpEntityId: this.idpEntityId,\n            ssoURL: this.ssoURL,\n            x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),\n            rpEntityId: this.rpEntityId,\n            callbackURL: this.callbackURL,\n            enableRequestSigning: this.enableRequestSigning,\n        };\n    }\n}\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass OIDCConfig {\n    /**\n     * Converts a client side request to a OIDCConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a OIDCConfig request,\n     * returns null.\n     *\n     * @param options - The options object to convert to a server request.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     * @returns The resulting server request or null if not valid.\n     */\n    static buildServerRequest(options, ignoreMissingFields = false) {\n        const makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        const request = {};\n        // Validate options.\n        OIDCConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        request.issuer = options.issuer;\n        request.clientId = options.clientId;\n        if (typeof options.clientSecret !== 'undefined') {\n            request.clientSecret = options.clientSecret;\n        }\n        if (typeof options.responseType !== 'undefined') {\n            request.responseType = options.responseType;\n        }\n        return request;\n    }\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param resourceName - The server side resource name\n     * @returns The provider ID corresponding to the resource, null otherwise.\n     */\n    static getProviderIdFromResourceName(resourceName) {\n        // name is of form projects/project1/oauthIdpConfigs/providerId1\n        const matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    }\n    /**\n     * @param providerId - The provider ID to check.\n     * @returns Whether the provider ID corresponds to an OIDC provider.\n     */\n    static isProviderId(providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n    }\n    /**\n     * Validates the OIDCConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     */\n    static validate(options, ignoreMissingFields = false) {\n        const validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            clientId: true,\n            issuer: true,\n            clientSecret: true,\n            responseType: true,\n        };\n        const validResponseTypes = {\n            idToken: true,\n            code: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OIDC config parameter.`);\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('oidc.') !== 0) {\n                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&\n            !validator.isNonEmptyString(options.clientId)) {\n            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&\n            !validator.isURL(options.issuer)) {\n            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n        }\n        if (typeof options.clientSecret !== 'undefined' &&\n            !validator.isNonEmptyString(options.clientSecret)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n        }\n        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n            Object.keys(options.responseType).forEach((key) => {\n                if (!(key in validResponseTypes)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OAuthResponseType parameter.`);\n                }\n            });\n            const idToken = options.responseType.idToken;\n            if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n            }\n            const code = options.responseType.code;\n            if (typeof code !== 'undefined') {\n                if (!validator.isBoolean(code)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n                }\n                // If code flow is enabled, client secret must be provided.\n                if (code && typeof options.clientSecret === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n                }\n            }\n            const allKeys = Object.keys(options.responseType).length;\n            const enabledCount = Object.values(options.responseType).filter(Boolean).length;\n            // Only one of OAuth response types can be set to true.\n            if (allKeys > 1 && enabledCount !== 1) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n            }\n        }\n    }\n    /**\n     * The OIDCConfig constructor.\n     *\n     * @param response - The server side response used to initialize the OIDCConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (!response ||\n            !response.issuer ||\n            !response.clientId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                OIDCConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n        }\n        const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        this.clientId = response.clientId;\n        this.issuer = response.issuer;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n        if (typeof response.clientSecret !== 'undefined') {\n            this.clientSecret = response.clientSecret;\n        }\n        if (typeof response.responseType !== 'undefined') {\n            this.responseType = response.responseType;\n        }\n    }\n    /** @returns The plain object representation of the OIDCConfig. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            issuer: this.issuer,\n            clientId: this.clientId,\n            clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),\n            responseType: (0, deep_copy_1.deepCopy)(this.responseType),\n        };\n    }\n}\nexports.OIDCConfig = OIDCConfig;\n/**\n * Defines the SMSRegionConfig class used for validation.\n *\n * @internal\n */\nclass SmsRegionsAuthConfig {\n    static validate(options) {\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig\" must be a non-null object.');\n        }\n        const validKeys = {\n            allowlistOnly: true,\n            allowByDefault: true,\n        };\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig parameter.`);\n            }\n        }\n        // validate mutual exclusiveness of allowByDefault and allowlistOnly\n        if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both \"allowByDefault\" and \"allowlistOnly\" parameters.');\n        }\n        // validation for allowByDefault type\n        if (typeof options.allowByDefault !== 'undefined') {\n            const allowByDefaultValidKeys = {\n                disallowedRegions: true,\n            };\n            for (const key in options.allowByDefault) {\n                if (!(key in allowByDefaultValidKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowByDefault parameter.`);\n                }\n            }\n            // disallowedRegion can be empty.\n            if (typeof options.allowByDefault.disallowedRegions !== 'undefined'\n                && !validator.isArray(options.allowByDefault.disallowedRegions)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowByDefault.disallowedRegions\" must be a valid string array.');\n            }\n        }\n        if (typeof options.allowlistOnly !== 'undefined') {\n            const allowListOnlyValidKeys = {\n                allowedRegions: true,\n            };\n            for (const key in options.allowlistOnly) {\n                if (!(key in allowListOnlyValidKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowlistOnly parameter.`);\n                }\n            }\n            // allowedRegions can be empty\n            if (typeof options.allowlistOnly.allowedRegions !== 'undefined'\n                && !validator.isArray(options.allowlistOnly.allowedRegions)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowlistOnly.allowedRegions\" must be a valid string array.');\n            }\n        }\n    }\n}\nexports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;\nclass RecaptchaAuthConfig {\n    constructor(recaptchaConfig) {\n        this.emailPasswordEnforcementState = recaptchaConfig.emailPasswordEnforcementState;\n        this.managedRules = recaptchaConfig.managedRules;\n        this.recaptchaKeys = recaptchaConfig.recaptchaKeys;\n        this.useAccountDefender = recaptchaConfig.useAccountDefender;\n    }\n    /**\n     * Validates the RecaptchaConfig options object. Throws an error on failure.\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        const validKeys = {\n            emailPasswordEnforcementState: true,\n            managedRules: true,\n            recaptchaKeys: true,\n            useAccountDefender: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig\" must be a non-null object.');\n        }\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaConfig parameter.`);\n            }\n        }\n        // Validation\n        if (typeof options.emailPasswordEnforcementState !== undefined) {\n            if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be a valid non-empty string.');\n            }\n            if (options.emailPasswordEnforcementState !== 'OFF' &&\n                options.emailPasswordEnforcementState !== 'AUDIT' &&\n                options.emailPasswordEnforcementState !== 'ENFORCE') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be either \"OFF\", \"AUDIT\" or \"ENFORCE\".');\n            }\n        }\n        if (typeof options.managedRules !== 'undefined') {\n            // Validate array\n            if (!validator.isArray(options.managedRules)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.managedRules\" must be an array of valid \"RecaptchaManagedRule\".');\n            }\n            // Validate each rule of the array\n            options.managedRules.forEach((managedRule) => {\n                RecaptchaAuthConfig.validateManagedRule(managedRule);\n            });\n        }\n        if (typeof options.useAccountDefender !== 'undefined') {\n            if (!validator.isBoolean(options.useAccountDefender)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useAccountDefender\" must be a boolean value\".');\n            }\n        }\n    }\n    /**\n     * Validate each element in ManagedRule array\n     * @param options - The options object to validate.\n     */\n    static validateManagedRule(options) {\n        const validKeys = {\n            endScore: true,\n            action: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaManagedRule parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.action !== 'undefined' &&\n            options.action !== 'BLOCK') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule.action\" must be \"BLOCK\".');\n        }\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     * @returns The JSON-serializable object representation of the ReCaptcha config instance\n     */\n    toJSON() {\n        const json = {\n            emailPasswordEnforcementState: this.emailPasswordEnforcementState,\n            managedRules: (0, deep_copy_1.deepCopy)(this.managedRules),\n            recaptchaKeys: (0, deep_copy_1.deepCopy)(this.recaptchaKeys),\n            useAccountDefender: this.useAccountDefender,\n        };\n        if (typeof json.emailPasswordEnforcementState === 'undefined') {\n            delete json.emailPasswordEnforcementState;\n        }\n        if (typeof json.managedRules === 'undefined') {\n            delete json.managedRules;\n        }\n        if (typeof json.recaptchaKeys === 'undefined') {\n            delete json.recaptchaKeys;\n        }\n        if (typeof json.useAccountDefender === 'undefined') {\n            delete json.useAccountDefender;\n        }\n        return json;\n    }\n}\nexports.RecaptchaAuthConfig = RecaptchaAuthConfig;\n/**\n * Defines the password policy config class used to convert client side PasswordPolicyConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass PasswordPolicyAuthConfig {\n    /**\n     * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        PasswordPolicyAuthConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enforcementState')) {\n            request.passwordPolicyEnforcementState = options.enforcementState;\n        }\n        request.forceUpgradeOnSignin = false;\n        if (Object.prototype.hasOwnProperty.call(options, 'forceUpgradeOnSignin')) {\n            request.forceUpgradeOnSignin = options.forceUpgradeOnSignin;\n        }\n        const constraintsRequest = {\n            containsUppercaseCharacter: false,\n            containsLowercaseCharacter: false,\n            containsNonAlphanumericCharacter: false,\n            containsNumericCharacter: false,\n            minPasswordLength: 6,\n            maxPasswordLength: 4096,\n        };\n        request.passwordPolicyVersions = [];\n        if (Object.prototype.hasOwnProperty.call(options, 'constraints')) {\n            if (options) {\n                if (options.constraints?.requireUppercase !== undefined) {\n                    constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;\n                }\n                if (options.constraints?.requireLowercase !== undefined) {\n                    constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;\n                }\n                if (options.constraints?.requireNonAlphanumeric !== undefined) {\n                    constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;\n                }\n                if (options.constraints?.requireNumeric !== undefined) {\n                    constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;\n                }\n                if (options.constraints?.minLength !== undefined) {\n                    constraintsRequest.minPasswordLength = options.constraints.minLength;\n                }\n                if (options.constraints?.maxLength !== undefined) {\n                    constraintsRequest.maxPasswordLength = options.constraints.maxLength;\n                }\n            }\n        }\n        request.passwordPolicyVersions.push({ customStrengthOptions: constraintsRequest });\n        return request;\n    }\n    /**\n     * Validates the PasswordPolicyConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @internal\n     */\n    static validate(options) {\n        const validKeys = {\n            enforcementState: true,\n            forceUpgradeOnSignin: true,\n            constraints: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.enforcementState === 'undefined' ||\n            !(options.enforcementState === 'ENFORCE' ||\n                options.enforcementState === 'OFF')) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.enforcementState\" must be either \"ENFORCE\" or \"OFF\".');\n        }\n        if (typeof options.forceUpgradeOnSignin !== 'undefined') {\n            if (!validator.isBoolean(options.forceUpgradeOnSignin)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.forceUpgradeOnSignin\" must be a boolean.');\n            }\n        }\n        if (typeof options.constraints !== 'undefined') {\n            if (options.enforcementState === 'ENFORCE' && !validator.isNonNullObject(options.constraints)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be a non-empty object.');\n            }\n            const validCharKeys = {\n                requireUppercase: true,\n                requireLowercase: true,\n                requireNumeric: true,\n                requireNonAlphanumeric: true,\n                minLength: true,\n                maxLength: true,\n            };\n            // Check for unsupported  attributes.\n            for (const key in options.constraints) {\n                if (!(key in validCharKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig.constraints parameter.`);\n                }\n            }\n            if (typeof options.constraints.requireUppercase !== undefined &&\n                !validator.isBoolean(options.constraints.requireUppercase)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireUppercase\" must be a boolean.');\n            }\n            if (typeof options.constraints.requireLowercase !== undefined &&\n                !validator.isBoolean(options.constraints.requireLowercase)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireLowercase\" must be a boolean.');\n            }\n            if (typeof options.constraints.requireNonAlphanumeric !== undefined &&\n                !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNonAlphanumeric\"' +\n                    ' must be a boolean.');\n            }\n            if (typeof options.constraints.requireNumeric !== undefined &&\n                !validator.isBoolean(options.constraints.requireNumeric)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNumeric\" must be a boolean.');\n            }\n            if (!validator.isNumber(options.constraints.minLength)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\" must be a number.');\n            }\n            if (!validator.isNumber(options.constraints.maxLength)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\" must be a number.');\n            }\n            if (options.constraints.minLength === undefined) {\n                options.constraints.minLength = 6;\n            }\n            else {\n                if (!(options.constraints.minLength >= 6\n                    && options.constraints.minLength <= 30)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\"' +\n                        ' must be an integer between 6 and 30, inclusive.');\n                }\n            }\n            if (options.constraints.maxLength === undefined) {\n                options.constraints.maxLength = 4096;\n            }\n            else {\n                if (!(options.constraints.maxLength >= options.constraints.minLength &&\n                    options.constraints.maxLength <= 4096)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\"' +\n                        ' must be greater than or equal to minLength and at max 4096.');\n                }\n            }\n        }\n        else {\n            if (options.enforcementState === 'ENFORCE') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be defined.');\n            }\n        }\n    }\n    /**\n     * The PasswordPolicyAuthConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     PasswordPolicyAuthConfig object.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        if (typeof response.passwordPolicyEnforcementState === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid password policy configuration response');\n        }\n        this.enforcementState = response.passwordPolicyEnforcementState;\n        let constraintsResponse = {};\n        if (typeof response.passwordPolicyVersions !== 'undefined') {\n            (response.passwordPolicyVersions || []).forEach((policyVersion) => {\n                constraintsResponse = {\n                    requireLowercase: policyVersion.customStrengthOptions?.containsLowercaseCharacter,\n                    requireUppercase: policyVersion.customStrengthOptions?.containsUppercaseCharacter,\n                    requireNonAlphanumeric: policyVersion.customStrengthOptions?.containsNonAlphanumericCharacter,\n                    requireNumeric: policyVersion.customStrengthOptions?.containsNumericCharacter,\n                    minLength: policyVersion.customStrengthOptions?.minPasswordLength,\n                    maxLength: policyVersion.customStrengthOptions?.maxPasswordLength,\n                };\n            });\n        }\n        this.constraints = constraintsResponse;\n        this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;\n    }\n}\nexports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}