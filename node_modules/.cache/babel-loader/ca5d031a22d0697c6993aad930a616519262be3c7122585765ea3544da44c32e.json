{"ast":null,"code":"import { inRange, decoderError, encoderError, isASCIICodePoint, end_of_stream, finished, isASCIIByte, floor } from '../utils';\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes';\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @implements {Decoder}\n */\nexport class EUCJPDecoder {\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    this.eucjp_jis0212_flag = false;\n    this.eucjp_lead = 0x00;\n  }\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n    // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && this.eucjp_lead !== 0x00) {\n      this.eucjp_lead = 0x00;\n      return decoderError(this.fatal);\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.eucjp_lead === 0x00) return finished;\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61 − 0xA1 + byte.\n    if (this.eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n      this.eucjp_lead = 0x00;\n      return 0xFF61 - 0xA1 + bite;\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (this.eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n      this.eucjp_jis0212_flag = true;\n      this.eucjp_lead = bite;\n      return null;\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (this.eucjp_lead !== 0x00) {\n      const lead = this.eucjp_lead;\n      this.eucjp_lead = 0x00;\n\n      // 1. Let code point be null.\n      let code_point = null;\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n        code_point = indexCodePointFor((lead - 0xA1) * 94 + (bite - 0xA1), index(!this.eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      this.eucjp_jis0212_flag = false;\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xA1, 0xFE)) stream.prepend(bite);\n\n      // 5. If code point is null, return error.\n      if (code_point === null) return decoderError(this.fatal);\n\n      // 6. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n      this.eucjp_lead = bite;\n      return null;\n    }\n\n    // 8. Return error.\n    return decoderError(this.fatal);\n  }\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @implements {Encoder}\n */\nexport class EUCJPEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00A5) return 0x5C;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203E) return 0x7E;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point −\n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xFF61, 0xFF9F)) return [0x8E, code_point - 0xFF61 + 0xA1];\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xFF0D;\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    const pointer = indexPointerFor(code_point, index('jis0208'));\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    const lead = floor(pointer / 94) + 0xA1;\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    const trail = pointer % 94 + 0xA1;\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail];\n  }\n}","map":{"version":3,"names":["inRange","decoderError","encoderError","isASCIICodePoint","end_of_stream","finished","isASCIIByte","floor","index","indexCodePointFor","indexPointerFor","EUCJPDecoder","constructor","options","fatal","eucjp_jis0212_flag","eucjp_lead","handler","stream","bite","lead","code_point","prepend","EUCJPEncoder","pointer","trail"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/euc-jp.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, { indexCodePointFor, indexPointerFor } from '../indexes'\n\n//\n// 13. Legacy multi-byte Japanese encodings\n//\n\n// 13.1 euc-jp\n\n// 13.1.1 euc-jp decoder\n/**\n * @implements {Decoder}\n */\nexport class EUCJPDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    this.eucjp_jis0212_flag = false\n    this.eucjp_lead = 0x00\n  }\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n  // euc-jp lead to 0x00, and return error.\n    if (bite === end_of_stream && this.eucjp_lead !== 0x00) {\n      this.eucjp_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.eucjp_lead === 0x00)\n      return finished\n\n    // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n    // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n    // point whose value is 0xFF61 − 0xA1 + byte.\n    if (this.eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n      this.eucjp_lead = 0x00\n      return 0xFF61 - 0xA1 + bite\n    }\n\n    // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n    // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n    // to byte, and return continue.\n    if (this.eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n      this.eucjp_jis0212_flag = true\n      this.eucjp_lead = bite\n      return null\n    }\n\n    // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n    // euc-jp lead to 0x00, and run these substeps:\n    if (this.eucjp_lead !== 0x00) {\n      const lead = this.eucjp_lead\n      this.eucjp_lead = 0x00\n\n      // 1. Let code point be null.\n      let code_point = null\n\n      // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n      // inclusive, set code point to the index code point for (lead\n      // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n      // jis0212 flag is unset and in index jis0212 otherwise.\n      if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n        code_point = indexCodePointFor(\n          (lead - 0xA1) * 94 + (bite - 0xA1),\n          index(!this.eucjp_jis0212_flag ? 'jis0208' : 'jis0212'))\n      }\n\n      // 3. Unset the euc-jp jis0212 flag.\n      this.eucjp_jis0212_flag = false\n\n      // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n      // prepend byte to stream.\n      if (!inRange(bite, 0xA1, 0xFE))\n        stream.prepend(bite)\n\n      // 5. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 6. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 6. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n    // inclusive, set euc-jp lead to byte and return continue.\n    if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n      this.eucjp_lead = bite\n      return null\n    }\n\n    // 8. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 13.1.2 euc-jp encoder\n/**\n * @implements {Encoder}\n */\nexport class EUCJPEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00A5)\n      return 0x5C\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203E)\n      return 0x7E\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return two bytes whose values are 0x8E and code point −\n    // 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xFF61, 0xFF9F))\n      return [0x8E, code_point - 0xFF61 + 0xA1]\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212)\n      code_point = 0xFF0D\n\n    // 7. Let pointer be the index pointer for code point in index\n    // jis0208.\n    const pointer = indexPointerFor(code_point, index('jis0208'))\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 9. Let lead be floor(pointer / 94) + 0xA1.\n    const lead = floor(pointer / 94) + 0xA1\n\n    // 10. Let trail be pointer % 94 + 0xA1.\n    const trail = pointer % 94 + 0xA1\n\n    // 11. Return two bytes whose values are lead and trail.\n    return [lead, trail]\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}