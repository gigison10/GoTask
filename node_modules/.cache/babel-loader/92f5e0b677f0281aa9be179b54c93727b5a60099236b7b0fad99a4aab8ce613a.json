{"ast":null,"code":"import { end_of_stream, finished, isASCIIByte, decoderError, encoderError, isASCIICodePoint } from '../utils';\nimport { indexPointerFor } from '../indexes';\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @implements {Decoder}\n */\nexport class SingleByteDecoder {\n  /**\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  constructor(index, options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n    this.index = index;\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream) return finished;\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 3. Let code point be the index code point for byte − 0x80 in\n    // index single-byte.\n    var code_point = this.index[bite - 0x80];\n\n    // 4. If code point is null, return error.\n    if (code_point === null) return decoderError(this.fatal);\n\n    // 5. Return a code point whose value is code point.\n    return code_point;\n  }\n}\n\n// 10.2 single-byte encoder\n/**\n * @implements {Encoder}\n */\nexport class SingleByteEncoder {\n  /**\n   * @param {!Array.<?number>} index The encoding index.\n   */\n  constructor(index) {\n    this.index = index;\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point)) return code_point;\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    const pointer = indexPointerFor(code_point, this.index);\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null) encoderError(code_point);\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80;\n  }\n}","map":{"version":3,"names":["end_of_stream","finished","isASCIIByte","decoderError","encoderError","isASCIICodePoint","indexPointerFor","SingleByteDecoder","constructor","index","options","fatal","handler","stream","bite","code_point","SingleByteEncoder","pointer"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/single-byte.js"],"sourcesContent":["import { end_of_stream, finished, isASCIIByte, decoderError, encoderError, isASCIICodePoint } from '../utils'\nimport { indexPointerFor } from '../indexes'\n\n//\n// 10. Legacy single-byte encodings\n//\n\n// 10.1 single-byte decoder\n/**\n * @implements {Decoder}\n */\nexport class SingleByteDecoder {\n  /**\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  constructor(index, options) {\n    const { fatal } = options\n    this.fatal = fatal\n    this.index = index\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished\n\n    // 2. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 3. Let code point be the index code point for byte − 0x80 in\n    // index single-byte.\n    var code_point = this.index[bite - 0x80]\n\n    // 4. If code point is null, return error.\n    if (code_point === null)\n      return decoderError(this.fatal)\n\n    // 5. Return a code point whose value is code point.\n    return code_point\n  }\n}\n\n// 10.2 single-byte encoder\n/**\n * @implements {Encoder}\n */\nexport class SingleByteEncoder {\n  /**\n   * @param {!Array.<?number>} index The encoding index.\n   */\n  constructor(index) {\n    this.index = index\n  }\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point, return a byte whose\n    // value is code point.\n    if (isASCIICodePoint(code_point))\n      return code_point\n\n    // 3. Let pointer be the index pointer for code point in index\n    // single-byte.\n    const pointer = indexPointerFor(code_point, this.index)\n\n    // 4. If pointer is null, return error with code point.\n    if (pointer === null)\n      encoderError(code_point)\n\n    // 5. Return a byte whose value is pointer + 0x80.\n    return pointer + 0x80\n  }\n}"],"mappings":"AAAA,SAASA,aAAa,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,YAAY,EAAEC,YAAY,EAAEC,gBAAgB,QAAQ,UAAU;AAC7G,SAASC,eAAe,QAAQ,YAAY;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,CAAC;EAC7B;AACF;AACA;AACA;EACEC,WAAWA,CAACC,KAAK,EAAEC,OAAO,EAAE;IAC1B,MAAM;MAAEC;IAAM,CAAC,GAAGD,OAAO;IACzB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACF,KAAK,GAAGA,KAAK;EACpB;EACA;AACF;AACA;AACA;EACEG,OAAOA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACtB;IACE,IAAIA,IAAI,KAAKd,aAAa,EACxB,OAAOC,QAAQ;;IAEjB;IACA;IACA,IAAIC,WAAW,CAACY,IAAI,CAAC,EACnB,OAAOA,IAAI;;IAEb;IACA;IACA,IAAIC,UAAU,GAAG,IAAI,CAACN,KAAK,CAACK,IAAI,GAAG,IAAI,CAAC;;IAExC;IACA,IAAIC,UAAU,KAAK,IAAI,EACrB,OAAOZ,YAAY,CAAC,IAAI,CAACQ,KAAK,CAAC;;IAEjC;IACA,OAAOI,UAAU;EACnB;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,CAAC;EAC7B;AACF;AACA;EACER,WAAWA,CAACC,KAAK,EAAE;IACjB,IAAI,CAACA,KAAK,GAAGA,KAAK;EACpB;EACA;AACF;AACA;AACA;AACA;EACEG,OAAOA,CAACC,MAAM,EAAEE,UAAU,EAAE;IAC1B;IACA,IAAIA,UAAU,KAAKf,aAAa,EAC9B,OAAOC,QAAQ;;IAEjB;IACA;IACA,IAAII,gBAAgB,CAACU,UAAU,CAAC,EAC9B,OAAOA,UAAU;;IAEnB;IACA;IACA,MAAME,OAAO,GAAGX,eAAe,CAACS,UAAU,EAAE,IAAI,CAACN,KAAK,CAAC;;IAEvD;IACA,IAAIQ,OAAO,KAAK,IAAI,EAClBb,YAAY,CAACW,UAAU,CAAC;;IAE1B;IACA,OAAOE,OAAO,GAAG,IAAI;EACvB;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}