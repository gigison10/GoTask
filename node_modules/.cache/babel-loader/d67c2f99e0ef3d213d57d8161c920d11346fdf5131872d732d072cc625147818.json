{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst utils = require(\"../utils\");\nconst validator = require(\"../utils/validator\");\nconst error_1 = require(\"../utils/error\");\n/**\n * Converts a client format second factor object to server format.\n * @param multiFactorInfo - The client format second factor.\n * @returns The corresponding AuthFactorInfo server request format.\n */\nfunction convertMultiFactorInfoToServerFormat(multiFactorInfo) {\n  let enrolledAt;\n  if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {\n    if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {\n      // Convert from UTC date string (client side format) to ISO date string (server side format).\n      enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();\n    } else {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor \"enrollmentTime\" for \"${multiFactorInfo.uid}\" must be a valid ` + 'UTC date string.');\n    }\n  }\n  // Currently only phone second factors are supported.\n  if (isPhoneFactor(multiFactorInfo)) {\n    // If any required field is missing or invalid, validation will still fail later.\n    const authFactorInfo = {\n      mfaEnrollmentId: multiFactorInfo.uid,\n      displayName: multiFactorInfo.displayName,\n      // Required for all phone second factors.\n      phoneInfo: multiFactorInfo.phoneNumber,\n      enrolledAt\n    };\n    for (const objKey in authFactorInfo) {\n      if (typeof authFactorInfo[objKey] === 'undefined') {\n        delete authFactorInfo[objKey];\n      }\n    }\n    return authFactorInfo;\n  } else {\n    // Unsupported second factor.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor \"${JSON.stringify(multiFactorInfo)}\" provided.`);\n  }\n}\nexports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;\nfunction isPhoneFactor(multiFactorInfo) {\n  return multiFactorInfo.factorId === 'phone';\n}\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @returns {number} The corresponding number if available. Otherwise, NaN.\n */\nfunction getNumberField(obj, key) {\n  if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n    return parseInt(obj[key].toString(), 10);\n  }\n  return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @returns {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\nfunction populateUploadAccountUser(user, userValidator) {\n  const result = {\n    localId: user.uid,\n    email: user.email,\n    emailVerified: user.emailVerified,\n    displayName: user.displayName,\n    disabled: user.disabled,\n    photoUrl: user.photoURL,\n    phoneNumber: user.phoneNumber,\n    providerUserInfo: [],\n    mfaInfo: [],\n    tenantId: user.tenantId,\n    customAttributes: user.customClaims && JSON.stringify(user.customClaims)\n  };\n  if (typeof user.passwordHash !== 'undefined') {\n    if (!validator.isBuffer(user.passwordHash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n    result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n  }\n  if (typeof user.passwordSalt !== 'undefined') {\n    if (!validator.isBuffer(user.passwordSalt)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n    result.salt = utils.toWebSafeBase64(user.passwordSalt);\n  }\n  if (validator.isNonNullObject(user.metadata)) {\n    if (validator.isNonEmptyString(user.metadata.creationTime)) {\n      result.createdAt = new Date(user.metadata.creationTime).getTime();\n    }\n    if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n      result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n    }\n  }\n  if (validator.isArray(user.providerData)) {\n    user.providerData.forEach(providerData => {\n      result.providerUserInfo.push({\n        providerId: providerData.providerId,\n        rawId: providerData.uid,\n        email: providerData.email,\n        displayName: providerData.displayName,\n        photoUrl: providerData.photoURL\n      });\n    });\n  }\n  // Convert user.multiFactor.enrolledFactors to server format.\n  if (validator.isNonNullObject(user.multiFactor) && validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {\n    user.multiFactor.enrolledFactors.forEach(multiFactorInfo => {\n      result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));\n    });\n  }\n  // Remove blank fields.\n  let key;\n  for (key in result) {\n    if (typeof result[key] === 'undefined') {\n      delete result[key];\n    }\n  }\n  if (result.providerUserInfo.length === 0) {\n    delete result.providerUserInfo;\n  }\n  if (result.mfaInfo.length === 0) {\n    delete result.mfaInfo;\n  }\n  // Validate the constructured user individual request. This will throw if an error\n  // is detected.\n  if (typeof userValidator === 'function') {\n    userValidator(result);\n  }\n  return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\nclass UserImportBuilder {\n  /**\n   * @param {UserImportRecord[]} users The list of user records to import.\n   * @param {UserImportOptions=} options The import options which includes hashing\n   *     algorithm details.\n   * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n   * @constructor\n   */\n  constructor(users, options, userRequestValidator) {\n    this.requiresHashOptions = false;\n    this.validatedUsers = [];\n    this.userImportResultErrors = [];\n    this.indexMap = {};\n    this.validatedUsers = this.populateUsers(users, userRequestValidator);\n    this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n  }\n  /**\n   * Returns the corresponding constructed uploadAccount request.\n   * @returns {UploadAccountRequest} The constructed uploadAccount request.\n   */\n  buildRequest() {\n    const users = this.validatedUsers.map(user => {\n      return (0, deep_copy_1.deepCopy)(user);\n    });\n    return (0, deep_copy_1.deepExtend)({\n      users\n    }, (0, deep_copy_1.deepCopy)(this.validatedOptions));\n  }\n  /**\n   * Populates the UserImportResult using the client side detected errors and the server\n   * side returned errors.\n   * @returns {UserImportResult} The user import result based on the returned failed\n   *     uploadAccount response.\n   */\n  buildResponse(failedUploads) {\n    // Initialize user import result.\n    const importResult = {\n      successCount: this.validatedUsers.length,\n      failureCount: this.userImportResultErrors.length,\n      errors: (0, deep_copy_1.deepCopy)(this.userImportResultErrors)\n    };\n    importResult.failureCount += failedUploads.length;\n    importResult.successCount -= failedUploads.length;\n    failedUploads.forEach(failedUpload => {\n      importResult.errors.push({\n        // Map backend request index to original developer provided array index.\n        index: this.indexMap[failedUpload.index],\n        error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)\n      });\n    });\n    // Sort errors by index.\n    importResult.errors.sort((a, b) => {\n      return a.index - b.index;\n    });\n    // Return sorted result.\n    return importResult;\n  }\n  /**\n   * Validates and returns the hashing options of the uploadAccount request.\n   * Throws an error whenever an invalid or missing options is detected.\n   * @param {UserImportOptions} options The UserImportOptions.\n   * @param {boolean} requiresHashOptions Whether to require hash options.\n   * @returns {UploadAccountOptions} The populated UploadAccount options.\n   */\n  populateOptions(options, requiresHashOptions) {\n    let populatedOptions;\n    if (!requiresHashOptions) {\n      return {};\n    }\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n    }\n    if (!validator.isNonNullObject(options.hash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '\"hash.algorithm\" is missing from the provided \"UserImportOptions\".');\n    }\n    if (typeof options.hash.algorithm === 'undefined' || !validator.isNonEmptyString(options.hash.algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '\"hash.algorithm\" must be a string matching the list of supported algorithms.');\n    }\n    let rounds;\n    switch (options.hash.algorithm) {\n      case 'HMAC_SHA512':\n      case 'HMAC_SHA256':\n      case 'HMAC_SHA1':\n      case 'HMAC_MD5':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty \"hash.key\" byte buffer must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n        }\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key)\n        };\n        break;\n      case 'MD5':\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        {\n          // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n          rounds = getNumberField(options.hash, 'rounds');\n          const minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n          if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid \"hash.rounds\" number between ${minRounds} and 8192 must be provided for ` + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            rounds\n          };\n          break;\n        }\n      case 'PBKDF_SHA1':\n      case 'PBKDF2_SHA256':\n        rounds = getNumberField(options.hash, 'rounds');\n        if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 0 and 120000 must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n        }\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          rounds\n        };\n        break;\n      case 'SCRYPT':\n        {\n          if (!validator.isBuffer(options.hash.key)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A \"hash.key\" byte buffer must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          rounds = getNumberField(options.hash, 'rounds');\n          if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 1 and 8 must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          const memoryCost = getNumberField(options.hash, 'memoryCost');\n          if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number between 1 and 14 must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          if (typeof options.hash.saltSeparator !== 'undefined' && !validator.isBuffer(options.hash.saltSeparator)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '\"hash.saltSeparator\" must be a byte buffer.');\n          }\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            signerKey: utils.toWebSafeBase64(options.hash.key),\n            rounds,\n            memoryCost,\n            saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(''))\n          };\n          break;\n        }\n      case 'BCRYPT':\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm\n        };\n        break;\n      case 'STANDARD_SCRYPT':\n        {\n          const cpuMemCost = getNumberField(options.hash, 'memoryCost');\n          if (isNaN(cpuMemCost)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          const parallelization = getNumberField(options.hash, 'parallelization');\n          if (isNaN(parallelization)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid \"hash.parallelization\" number must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          const blockSize = getNumberField(options.hash, 'blockSize');\n          if (isNaN(blockSize)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid \"hash.blockSize\" number must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          const dkLen = getNumberField(options.hash, 'derivedKeyLength');\n          if (isNaN(dkLen)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid \"hash.derivedKeyLength\" number must be provided for ' + `hash algorithm ${options.hash.algorithm}.`);\n          }\n          populatedOptions = {\n            hashAlgorithm: options.hash.algorithm,\n            cpuMemCost,\n            parallelization,\n            blockSize,\n            dkLen\n          };\n          break;\n        }\n      default:\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider \"${options.hash.algorithm}\".`);\n    }\n    return populatedOptions;\n  }\n  /**\n   * Validates and returns the users list of the uploadAccount request.\n   * Whenever a user with an error is detected, the error is cached and will later be\n   * merged into the user import result. This allows the processing of valid users without\n   * failing early on the first error detected.\n   * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n   *     objects.\n   * @param {ValidatorFunction=} userValidator The user validator function.\n   * @returns {UploadAccountUser[]} The populated uploadAccount users.\n   */\n  populateUsers(users, userValidator) {\n    const populatedUsers = [];\n    users.forEach((user, index) => {\n      try {\n        const result = populateUploadAccountUser(user, userValidator);\n        if (typeof result.passwordHash !== 'undefined') {\n          this.requiresHashOptions = true;\n        }\n        // Only users that pass client screening will be passed to backend for processing.\n        populatedUsers.push(result);\n        // Map user's index (the one to be sent to backend) to original developer provided array.\n        this.indexMap[populatedUsers.length - 1] = index;\n      } catch (error) {\n        // Save the client side error with respect to the developer provided array.\n        this.userImportResultErrors.push({\n          index,\n          error\n        });\n      }\n    });\n    return populatedUsers;\n  }\n}\nexports.UserImportBuilder = UserImportBuilder;","map":{"version":3,"names":["Object","defineProperty","exports","value","UserImportBuilder","convertMultiFactorInfoToServerFormat","deep_copy_1","require","utils","validator","error_1","multiFactorInfo","enrolledAt","enrollmentTime","isUTCDateString","Date","toISOString","FirebaseAuthError","AuthClientErrorCode","INVALID_ENROLLMENT_TIME","uid","isPhoneFactor","authFactorInfo","mfaEnrollmentId","displayName","phoneInfo","phoneNumber","objKey","UNSUPPORTED_SECOND_FACTOR","JSON","stringify","factorId","getNumberField","obj","key","parseInt","toString","NaN","populateUploadAccountUser","user","userValidator","result","localId","email","emailVerified","disabled","photoUrl","photoURL","providerUserInfo","mfaInfo","tenantId","customAttributes","customClaims","passwordHash","isBuffer","INVALID_PASSWORD_HASH","toWebSafeBase64","passwordSalt","INVALID_PASSWORD_SALT","salt","isNonNullObject","metadata","isNonEmptyString","creationTime","createdAt","getTime","lastSignInTime","lastLoginAt","isArray","providerData","forEach","push","providerId","rawId","multiFactor","isNonEmptyArray","enrolledFactors","length","constructor","users","options","userRequestValidator","requiresHashOptions","validatedUsers","userImportResultErrors","indexMap","populateUsers","validatedOptions","populateOptions","buildRequest","map","deepCopy","deepExtend","buildResponse","failedUploads","importResult","successCount","failureCount","errors","failedUpload","index","error","INVALID_USER_IMPORT","message","sort","a","b","populatedOptions","INVALID_ARGUMENT","hash","MISSING_HASH_ALGORITHM","algorithm","INVALID_HASH_ALGORITHM","rounds","INVALID_HASH_KEY","hashAlgorithm","signerKey","minRounds","isNaN","INVALID_HASH_ROUNDS","memoryCost","INVALID_HASH_MEMORY_COST","saltSeparator","INVALID_HASH_SALT_SEPARATOR","Buffer","from","cpuMemCost","parallelization","INVALID_HASH_PARALLELIZATION","blockSize","INVALID_HASH_BLOCK_SIZE","dkLen","INVALID_HASH_DERIVED_KEY_LENGTH","populatedUsers"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/auth/user-import-builder.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst utils = require(\"../utils\");\nconst validator = require(\"../utils/validator\");\nconst error_1 = require(\"../utils/error\");\n/**\n * Converts a client format second factor object to server format.\n * @param multiFactorInfo - The client format second factor.\n * @returns The corresponding AuthFactorInfo server request format.\n */\nfunction convertMultiFactorInfoToServerFormat(multiFactorInfo) {\n    let enrolledAt;\n    if (typeof multiFactorInfo.enrollmentTime !== 'undefined') {\n        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {\n            // Convert from UTC date string (client side format) to ISO date string (server side format).\n            enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();\n        }\n        else {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor \"enrollmentTime\" for \"${multiFactorInfo.uid}\" must be a valid ` +\n                'UTC date string.');\n        }\n    }\n    // Currently only phone second factors are supported.\n    if (isPhoneFactor(multiFactorInfo)) {\n        // If any required field is missing or invalid, validation will still fail later.\n        const authFactorInfo = {\n            mfaEnrollmentId: multiFactorInfo.uid,\n            displayName: multiFactorInfo.displayName,\n            // Required for all phone second factors.\n            phoneInfo: multiFactorInfo.phoneNumber,\n            enrolledAt,\n        };\n        for (const objKey in authFactorInfo) {\n            if (typeof authFactorInfo[objKey] === 'undefined') {\n                delete authFactorInfo[objKey];\n            }\n        }\n        return authFactorInfo;\n    }\n    else {\n        // Unsupported second factor.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor \"${JSON.stringify(multiFactorInfo)}\" provided.`);\n    }\n}\nexports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;\nfunction isPhoneFactor(multiFactorInfo) {\n    return multiFactorInfo.factorId === 'phone';\n}\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @returns {number} The corresponding number if available. Otherwise, NaN.\n */\nfunction getNumberField(obj, key) {\n    if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n        return parseInt(obj[key].toString(), 10);\n    }\n    return NaN;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @returns {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\nfunction populateUploadAccountUser(user, userValidator) {\n    const result = {\n        localId: user.uid,\n        email: user.email,\n        emailVerified: user.emailVerified,\n        displayName: user.displayName,\n        disabled: user.disabled,\n        photoUrl: user.photoURL,\n        phoneNumber: user.phoneNumber,\n        providerUserInfo: [],\n        mfaInfo: [],\n        tenantId: user.tenantId,\n        customAttributes: user.customClaims && JSON.stringify(user.customClaims),\n    };\n    if (typeof user.passwordHash !== 'undefined') {\n        if (!validator.isBuffer(user.passwordHash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n        }\n        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n    }\n    if (typeof user.passwordSalt !== 'undefined') {\n        if (!validator.isBuffer(user.passwordSalt)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n        }\n        result.salt = utils.toWebSafeBase64(user.passwordSalt);\n    }\n    if (validator.isNonNullObject(user.metadata)) {\n        if (validator.isNonEmptyString(user.metadata.creationTime)) {\n            result.createdAt = new Date(user.metadata.creationTime).getTime();\n        }\n        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n            result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n        }\n    }\n    if (validator.isArray(user.providerData)) {\n        user.providerData.forEach((providerData) => {\n            result.providerUserInfo.push({\n                providerId: providerData.providerId,\n                rawId: providerData.uid,\n                email: providerData.email,\n                displayName: providerData.displayName,\n                photoUrl: providerData.photoURL,\n            });\n        });\n    }\n    // Convert user.multiFactor.enrolledFactors to server format.\n    if (validator.isNonNullObject(user.multiFactor) &&\n        validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {\n        user.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {\n            result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));\n        });\n    }\n    // Remove blank fields.\n    let key;\n    for (key in result) {\n        if (typeof result[key] === 'undefined') {\n            delete result[key];\n        }\n    }\n    if (result.providerUserInfo.length === 0) {\n        delete result.providerUserInfo;\n    }\n    if (result.mfaInfo.length === 0) {\n        delete result.mfaInfo;\n    }\n    // Validate the constructured user individual request. This will throw if an error\n    // is detected.\n    if (typeof userValidator === 'function') {\n        userValidator(result);\n    }\n    return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\nclass UserImportBuilder {\n    /**\n     * @param {UserImportRecord[]} users The list of user records to import.\n     * @param {UserImportOptions=} options The import options which includes hashing\n     *     algorithm details.\n     * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n     * @constructor\n     */\n    constructor(users, options, userRequestValidator) {\n        this.requiresHashOptions = false;\n        this.validatedUsers = [];\n        this.userImportResultErrors = [];\n        this.indexMap = {};\n        this.validatedUsers = this.populateUsers(users, userRequestValidator);\n        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);\n    }\n    /**\n     * Returns the corresponding constructed uploadAccount request.\n     * @returns {UploadAccountRequest} The constructed uploadAccount request.\n     */\n    buildRequest() {\n        const users = this.validatedUsers.map((user) => {\n            return (0, deep_copy_1.deepCopy)(user);\n        });\n        return (0, deep_copy_1.deepExtend)({ users }, (0, deep_copy_1.deepCopy)(this.validatedOptions));\n    }\n    /**\n     * Populates the UserImportResult using the client side detected errors and the server\n     * side returned errors.\n     * @returns {UserImportResult} The user import result based on the returned failed\n     *     uploadAccount response.\n     */\n    buildResponse(failedUploads) {\n        // Initialize user import result.\n        const importResult = {\n            successCount: this.validatedUsers.length,\n            failureCount: this.userImportResultErrors.length,\n            errors: (0, deep_copy_1.deepCopy)(this.userImportResultErrors),\n        };\n        importResult.failureCount += failedUploads.length;\n        importResult.successCount -= failedUploads.length;\n        failedUploads.forEach((failedUpload) => {\n            importResult.errors.push({\n                // Map backend request index to original developer provided array index.\n                index: this.indexMap[failedUpload.index],\n                error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message),\n            });\n        });\n        // Sort errors by index.\n        importResult.errors.sort((a, b) => {\n            return a.index - b.index;\n        });\n        // Return sorted result.\n        return importResult;\n    }\n    /**\n     * Validates and returns the hashing options of the uploadAccount request.\n     * Throws an error whenever an invalid or missing options is detected.\n     * @param {UserImportOptions} options The UserImportOptions.\n     * @param {boolean} requiresHashOptions Whether to require hash options.\n     * @returns {UploadAccountOptions} The populated UploadAccount options.\n     */\n    populateOptions(options, requiresHashOptions) {\n        let populatedOptions;\n        if (!requiresHashOptions) {\n            return {};\n        }\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"UserImportOptions\" are required when importing users with passwords.');\n        }\n        if (!validator.isNonNullObject(options.hash)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '\"hash.algorithm\" is missing from the provided \"UserImportOptions\".');\n        }\n        if (typeof options.hash.algorithm === 'undefined' ||\n            !validator.isNonEmptyString(options.hash.algorithm)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '\"hash.algorithm\" must be a string matching the list of supported algorithms.');\n        }\n        let rounds;\n        switch (options.hash.algorithm) {\n            case 'HMAC_SHA512':\n            case 'HMAC_SHA256':\n            case 'HMAC_SHA1':\n            case 'HMAC_MD5':\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty \"hash.key\" byte buffer must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                };\n                break;\n            case 'MD5':\n            case 'SHA1':\n            case 'SHA256':\n            case 'SHA512': {\n                // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]\n                rounds = getNumberField(options.hash, 'rounds');\n                const minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;\n                if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid \"hash.rounds\" number between ${minRounds} and 8192 must be provided for ` +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds,\n                };\n                break;\n            }\n            case 'PBKDF_SHA1':\n            case 'PBKDF2_SHA256':\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 0 and 120000 must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    rounds,\n                };\n                break;\n            case 'SCRYPT': {\n                if (!validator.isBuffer(options.hash.key)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A \"hash.key\" byte buffer must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                rounds = getNumberField(options.hash, 'rounds');\n                if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid \"hash.rounds\" number between 1 and 8 must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                const memoryCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number between 1 and 14 must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                if (typeof options.hash.saltSeparator !== 'undefined' &&\n                    !validator.isBuffer(options.hash.saltSeparator)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '\"hash.saltSeparator\" must be a byte buffer.');\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    signerKey: utils.toWebSafeBase64(options.hash.key),\n                    rounds,\n                    memoryCost,\n                    saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from('')),\n                };\n                break;\n            }\n            case 'BCRYPT':\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                };\n                break;\n            case 'STANDARD_SCRYPT': {\n                const cpuMemCost = getNumberField(options.hash, 'memoryCost');\n                if (isNaN(cpuMemCost)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid \"hash.memoryCost\" number must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                const parallelization = getNumberField(options.hash, 'parallelization');\n                if (isNaN(parallelization)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid \"hash.parallelization\" number must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                const blockSize = getNumberField(options.hash, 'blockSize');\n                if (isNaN(blockSize)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid \"hash.blockSize\" number must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                const dkLen = getNumberField(options.hash, 'derivedKeyLength');\n                if (isNaN(dkLen)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid \"hash.derivedKeyLength\" number must be provided for ' +\n                        `hash algorithm ${options.hash.algorithm}.`);\n                }\n                populatedOptions = {\n                    hashAlgorithm: options.hash.algorithm,\n                    cpuMemCost,\n                    parallelization,\n                    blockSize,\n                    dkLen,\n                };\n                break;\n            }\n            default:\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider \"${options.hash.algorithm}\".`);\n        }\n        return populatedOptions;\n    }\n    /**\n     * Validates and returns the users list of the uploadAccount request.\n     * Whenever a user with an error is detected, the error is cached and will later be\n     * merged into the user import result. This allows the processing of valid users without\n     * failing early on the first error detected.\n     * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n     *     objects.\n     * @param {ValidatorFunction=} userValidator The user validator function.\n     * @returns {UploadAccountUser[]} The populated uploadAccount users.\n     */\n    populateUsers(users, userValidator) {\n        const populatedUsers = [];\n        users.forEach((user, index) => {\n            try {\n                const result = populateUploadAccountUser(user, userValidator);\n                if (typeof result.passwordHash !== 'undefined') {\n                    this.requiresHashOptions = true;\n                }\n                // Only users that pass client screening will be passed to backend for processing.\n                populatedUsers.push(result);\n                // Map user's index (the one to be sent to backend) to original developer provided array.\n                this.indexMap[populatedUsers.length - 1] = index;\n            }\n            catch (error) {\n                // Save the client side error with respect to the developer provided array.\n                this.userImportResultErrors.push({\n                    index,\n                    error,\n                });\n            }\n        });\n        return populatedUsers;\n    }\n}\nexports.UserImportBuilder = UserImportBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}