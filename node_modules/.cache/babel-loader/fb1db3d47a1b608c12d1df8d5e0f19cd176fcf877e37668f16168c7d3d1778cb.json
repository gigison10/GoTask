{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n/* global AbortController */\nconst node_fetch_1 = require(\"node-fetch\");\nconst abort_controller_1 = require(\"abort-controller\");\nconst featureDetection_1 = require(\"./featureDetection\");\nconst streamArrayParser_1 = require(\"./streamArrayParser\");\nconst stream_1 = require(\"stream\");\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) {\n  const fetch = (0, featureDetection_1.hasWindowFetch)() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {\n    // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.\n    close: () => {\n      return {\n        cancel: () => {}\n      };\n    }\n  };\n  for (const [rpcName, rpc] of Object.entries(rpcs)) {\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      options !== null && options !== void 0 ? options : options = {};\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      let fetchParameters;\n      try {\n        fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);\n      } catch (err) {\n        // we could not encode parameters; pass error to the callback\n        // and return a no-op canceler object.\n        if (callback) {\n          callback(err);\n        }\n        return {\n          cancel() {}\n        };\n      }\n      const cancelController = (0, featureDetection_1.hasAbortController)() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n      const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: {\n            ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n        if (fetchParameters.method === 'GET' || fetchParameters.method === 'DELETE') {\n          delete fetchRequest['body'];\n        }\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        if (response.ok && rpc.responseStream) {\n          (0, stream_1.pipeline)(response.body, streamArrayParser, err => {\n            if (err && (!cancelRequested || err instanceof Error && err.name !== 'AbortError')) {\n              if (callback) {\n                callback(err);\n              }\n              streamArrayParser.emit('error', err);\n            }\n          });\n          return;\n        } else {\n          return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]).then(_ref => {\n            let [ok, buffer] = _ref;\n            const response = responseDecoder(rpc, ok, buffer);\n            callback(null, response);\n          }).catch(err => {\n            if (!cancelRequested || err.name !== 'AbortError') {\n              if (rpc.responseStream) {\n                if (callback) {\n                  callback(err);\n                }\n                streamArrayParser.emit('error', err);\n              } else if (callback) {\n                callback(err);\n              } else {\n                throw err;\n              }\n            }\n          });\n        }\n      }).catch(err => {\n        if (rpc.responseStream) {\n          if (callback) {\n            callback(err);\n          }\n          streamArrayParser.emit('error', err);\n        } else if (callback) {\n          callback(err);\n        } else {\n          throw err;\n        }\n      });\n      if (rpc.responseStream) {\n        return streamArrayParser;\n      }\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n  return serviceStub;\n}\nexports.generateServiceStub = generateServiceStub;","map":{"version":3,"names":["node_fetch_1","require","abort_controller_1","featureDetection_1","streamArrayParser_1","stream_1","generateServiceStub","rpcs","protocol","servicePath","servicePort","authClient","requestEncoder","responseDecoder","numericEnums","fetch","hasWindowFetch","window","default","serviceStub","close","cancel","rpcName","rpc","Object","entries","request","options","_metadata","callback","fetchParameters","err","cancelController","hasAbortController","AbortController","cancelSignal","signal","cancelRequested","url","headers","key","keys","streamArrayParser","StreamArrayParser","getRequestHeaders","then","authHeader","fetchRequest","body","method","response","ok","responseStream","pipeline","Error","name","emit","Promise","all","resolve","arrayBuffer","_ref","buffer","catch","abort","exports"],"sources":["../../src/fallbackServiceStub.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}