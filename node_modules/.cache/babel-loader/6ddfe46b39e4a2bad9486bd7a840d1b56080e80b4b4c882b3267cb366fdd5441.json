{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst validator_1 = require(\"../utils/validator\");\nconst utils = require(\"../utils\");\nconst error_1 = require(\"../utils/error\");\n/**\n * 'REDACTED', encoded as a base64 string.\n */\nconst B64_REDACTED = Buffer.from('REDACTED').toString('base64');\n/**\n * Parses a time stamp string or number and returns the corresponding date if valid.\n *\n * @param time - The unix timestamp string or number in milliseconds.\n * @returns The corresponding date as a UTC string, if valid. Otherwise, null.\n */\nfunction parseDate(time) {\n  try {\n    const date = new Date(parseInt(time, 10));\n    if (!isNaN(date.getTime())) {\n      return date.toUTCString();\n    }\n  } catch (e) {\n    // Do nothing. null will be returned.\n  }\n  return null;\n}\nvar MultiFactorId;\n(function (MultiFactorId) {\n  MultiFactorId[\"Phone\"] = \"phone\";\n})(MultiFactorId || (MultiFactorId = {}));\n/**\n * Interface representing the common properties of a user-enrolled second factor.\n */\nclass MultiFactorInfo {\n  /**\n   * Initializes the MultiFactorInfo associated subclass using the server side.\n   * If no MultiFactorInfo is associated with the response, null is returned.\n   *\n   * @param response - The server side response.\n   * @internal\n   */\n  static initMultiFactorInfo(response) {\n    let multiFactorInfo = null;\n    // Only PhoneMultiFactorInfo currently available.\n    try {\n      multiFactorInfo = new PhoneMultiFactorInfo(response);\n    } catch (e) {\n      // Ignore error.\n    }\n    return multiFactorInfo;\n  }\n  /**\n   * Initializes the MultiFactorInfo object using the server side response.\n   *\n   * @param response - The server side response.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    this.initFromServerResponse(response);\n  }\n  /**\n   * Returns a JSON-serializable representation of this object.\n   *\n   * @returns A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return {\n      uid: this.uid,\n      displayName: this.displayName,\n      factorId: this.factorId,\n      enrollmentTime: this.enrollmentTime\n    };\n  }\n  /**\n   * Initializes the MultiFactorInfo object using the provided server response.\n   *\n   * @param response - The server side response.\n   */\n  initFromServerResponse(response) {\n    const factorId = response && this.getFactorId(response);\n    if (!factorId || !response || !response.mfaEnrollmentId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');\n    }\n    utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);\n    utils.addReadonlyGetter(this, 'factorId', factorId);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.\n    // For example, \"2017-01-15T01:30:15.01Z\".\n    // This can be parsed directly via Date constructor.\n    // This can be computed using Data.prototype.toISOString.\n    if (response.enrolledAt) {\n      utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());\n    } else {\n      utils.addReadonlyGetter(this, 'enrollmentTime', null);\n    }\n  }\n}\nexports.MultiFactorInfo = MultiFactorInfo;\n/**\n * Interface representing a phone specific user-enrolled second factor.\n */\nclass PhoneMultiFactorInfo extends MultiFactorInfo {\n  /**\n   * Initializes the PhoneMultiFactorInfo object using the server side response.\n   *\n   * @param response - The server side response.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    super(response);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneInfo);\n  }\n  /**\n   * {@inheritdoc MultiFactorInfo.toJSON}\n   */\n  toJSON() {\n    return Object.assign(super.toJSON(), {\n      phoneNumber: this.phoneNumber\n    });\n  }\n  /**\n   * Returns the factor ID based on the response provided.\n   *\n   * @param response - The server side response.\n   * @returns The multi-factor ID associated with the provided response. If the response is\n   *     not associated with any known multi-factor ID, null is returned.\n   *\n   * @internal\n   */\n  getFactorId(response) {\n    return response && response.phoneInfo ? MultiFactorId.Phone : null;\n  }\n}\nexports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;\n/**\n * The multi-factor related user settings.\n */\nclass MultiFactorSettings {\n  /**\n   * Initializes the MultiFactor object using the server side or JWT format response.\n   *\n   * @param response - The server side response.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    const parsedEnrolledFactors = [];\n    if (!(0, validator_1.isNonNullObject)(response)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');\n    } else if (response.mfaInfo) {\n      response.mfaInfo.forEach(factorResponse => {\n        const multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);\n        if (multiFactorInfo) {\n          parsedEnrolledFactors.push(multiFactorInfo);\n        }\n      });\n    }\n    // Make enrolled factors immutable.\n    utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));\n  }\n  /**\n   * Returns a JSON-serializable representation of this multi-factor object.\n   *\n   * @returns A JSON-serializable representation of this multi-factor object.\n   */\n  toJSON() {\n    return {\n      enrolledFactors: this.enrolledFactors.map(info => info.toJSON())\n    };\n  }\n}\nexports.MultiFactorSettings = MultiFactorSettings;\n/**\n * Represents a user's metadata.\n */\nclass UserMetadata {\n  /**\n   * @param response - The server side response returned from the getAccountInfo\n   *     endpoint.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    // Creation date should always be available but due to some backend bugs there\n    // were cases in the past where users did not have creation date properly set.\n    // This included legacy Firebase migrating project users and some anonymous users.\n    // These bugs have already been addressed since then.\n    utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));\n    utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));\n    const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;\n    utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);\n  }\n  /**\n   * Returns a JSON-serializable representation of this object.\n   *\n   * @returns A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return {\n      lastSignInTime: this.lastSignInTime,\n      creationTime: this.creationTime,\n      lastRefreshTime: this.lastRefreshTime\n    };\n  }\n}\nexports.UserMetadata = UserMetadata;\n/**\n * Represents a user's info from a third-party identity provider\n * such as Google or Facebook.\n */\nclass UserInfo {\n  /**\n   * @param response - The server side response returned from the `getAccountInfo`\n   *     endpoint.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    // Provider user id and provider id are required.\n    if (!response.rawId || !response.providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');\n    }\n    utils.addReadonlyGetter(this, 'uid', response.rawId);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    utils.addReadonlyGetter(this, 'email', response.email);\n    utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n    utils.addReadonlyGetter(this, 'providerId', response.providerId);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n  }\n  /**\n   * Returns a JSON-serializable representation of this object.\n   *\n   * @returns A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    return {\n      uid: this.uid,\n      displayName: this.displayName,\n      email: this.email,\n      photoURL: this.photoURL,\n      providerId: this.providerId,\n      phoneNumber: this.phoneNumber\n    };\n  }\n}\nexports.UserInfo = UserInfo;\n/**\n * Represents a user.\n */\nclass UserRecord {\n  /**\n   * @param response - The server side response returned from the getAccountInfo\n   *     endpoint.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    // The Firebase user id is required.\n    if (!response.localId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');\n    }\n    utils.addReadonlyGetter(this, 'uid', response.localId);\n    utils.addReadonlyGetter(this, 'email', response.email);\n    utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);\n    utils.addReadonlyGetter(this, 'displayName', response.displayName);\n    utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n    utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n    // If disabled is not provided, the account is enabled by default.\n    utils.addReadonlyGetter(this, 'disabled', response.disabled || false);\n    utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));\n    const providerData = [];\n    for (const entry of response.providerUserInfo || []) {\n      providerData.push(new UserInfo(entry));\n    }\n    utils.addReadonlyGetter(this, 'providerData', providerData);\n    // If the password hash is redacted (probably due to missing permissions)\n    // then clear it out, similar to how the salt is returned. (Otherwise, it\n    // *looks* like a b64-encoded hash is present, which is confusing.)\n    if (response.passwordHash === B64_REDACTED) {\n      utils.addReadonlyGetter(this, 'passwordHash', undefined);\n    } else {\n      utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);\n    }\n    utils.addReadonlyGetter(this, 'passwordSalt', response.salt);\n    if (response.customAttributes) {\n      utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));\n    }\n    let validAfterTime = null;\n    // Convert validSince first to UTC milliseconds and then to UTC date string.\n    if (typeof response.validSince !== 'undefined') {\n      validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);\n    }\n    utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);\n    utils.addReadonlyGetter(this, 'tenantId', response.tenantId);\n    const multiFactor = new MultiFactorSettings(response);\n    if (multiFactor.enrolledFactors.length > 0) {\n      utils.addReadonlyGetter(this, 'multiFactor', multiFactor);\n    }\n  }\n  /**\n   * Returns a JSON-serializable representation of this object.\n   *\n   * @returns A JSON-serializable representation of this object.\n   */\n  toJSON() {\n    const json = {\n      uid: this.uid,\n      email: this.email,\n      emailVerified: this.emailVerified,\n      displayName: this.displayName,\n      photoURL: this.photoURL,\n      phoneNumber: this.phoneNumber,\n      disabled: this.disabled,\n      // Convert metadata to json.\n      metadata: this.metadata.toJSON(),\n      passwordHash: this.passwordHash,\n      passwordSalt: this.passwordSalt,\n      customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),\n      tokensValidAfterTime: this.tokensValidAfterTime,\n      tenantId: this.tenantId\n    };\n    if (this.multiFactor) {\n      json.multiFactor = this.multiFactor.toJSON();\n    }\n    json.providerData = [];\n    for (const entry of this.providerData) {\n      // Convert each provider data to json.\n      json.providerData.push(entry.toJSON());\n    }\n    return json;\n  }\n}\nexports.UserRecord = UserRecord;","map":{"version":3,"names":["Object","defineProperty","exports","value","UserRecord","UserInfo","UserMetadata","MultiFactorSettings","PhoneMultiFactorInfo","MultiFactorInfo","deep_copy_1","require","validator_1","utils","error_1","B64_REDACTED","Buffer","from","toString","parseDate","time","date","Date","parseInt","isNaN","getTime","toUTCString","e","MultiFactorId","initMultiFactorInfo","response","multiFactorInfo","constructor","initFromServerResponse","toJSON","uid","displayName","factorId","enrollmentTime","getFactorId","mfaEnrollmentId","FirebaseAuthError","AuthClientErrorCode","INTERNAL_ERROR","addReadonlyGetter","enrolledAt","phoneInfo","assign","phoneNumber","Phone","parsedEnrolledFactors","isNonNullObject","mfaInfo","forEach","factorResponse","push","freeze","enrolledFactors","map","info","createdAt","lastLoginAt","lastRefreshAt","lastSignInTime","creationTime","lastRefreshTime","rawId","providerId","email","photoUrl","photoURL","localId","emailVerified","disabled","providerData","entry","providerUserInfo","passwordHash","undefined","salt","customAttributes","JSON","parse","validAfterTime","validSince","tenantId","multiFactor","length","json","metadata","passwordSalt","customClaims","deepCopy","tokensValidAfterTime"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/auth/user-record.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst validator_1 = require(\"../utils/validator\");\nconst utils = require(\"../utils\");\nconst error_1 = require(\"../utils/error\");\n/**\n * 'REDACTED', encoded as a base64 string.\n */\nconst B64_REDACTED = Buffer.from('REDACTED').toString('base64');\n/**\n * Parses a time stamp string or number and returns the corresponding date if valid.\n *\n * @param time - The unix timestamp string or number in milliseconds.\n * @returns The corresponding date as a UTC string, if valid. Otherwise, null.\n */\nfunction parseDate(time) {\n    try {\n        const date = new Date(parseInt(time, 10));\n        if (!isNaN(date.getTime())) {\n            return date.toUTCString();\n        }\n    }\n    catch (e) {\n        // Do nothing. null will be returned.\n    }\n    return null;\n}\nvar MultiFactorId;\n(function (MultiFactorId) {\n    MultiFactorId[\"Phone\"] = \"phone\";\n})(MultiFactorId || (MultiFactorId = {}));\n/**\n * Interface representing the common properties of a user-enrolled second factor.\n */\nclass MultiFactorInfo {\n    /**\n     * Initializes the MultiFactorInfo associated subclass using the server side.\n     * If no MultiFactorInfo is associated with the response, null is returned.\n     *\n     * @param response - The server side response.\n     * @internal\n     */\n    static initMultiFactorInfo(response) {\n        let multiFactorInfo = null;\n        // Only PhoneMultiFactorInfo currently available.\n        try {\n            multiFactorInfo = new PhoneMultiFactorInfo(response);\n        }\n        catch (e) {\n            // Ignore error.\n        }\n        return multiFactorInfo;\n    }\n    /**\n     * Initializes the MultiFactorInfo object using the server side response.\n     *\n     * @param response - The server side response.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        this.initFromServerResponse(response);\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns A JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return {\n            uid: this.uid,\n            displayName: this.displayName,\n            factorId: this.factorId,\n            enrollmentTime: this.enrollmentTime,\n        };\n    }\n    /**\n     * Initializes the MultiFactorInfo object using the provided server response.\n     *\n     * @param response - The server side response.\n     */\n    initFromServerResponse(response) {\n        const factorId = response && this.getFactorId(response);\n        if (!factorId || !response || !response.mfaEnrollmentId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');\n        }\n        utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);\n        utils.addReadonlyGetter(this, 'factorId', factorId);\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\n        // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.\n        // For example, \"2017-01-15T01:30:15.01Z\".\n        // This can be parsed directly via Date constructor.\n        // This can be computed using Data.prototype.toISOString.\n        if (response.enrolledAt) {\n            utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());\n        }\n        else {\n            utils.addReadonlyGetter(this, 'enrollmentTime', null);\n        }\n    }\n}\nexports.MultiFactorInfo = MultiFactorInfo;\n/**\n * Interface representing a phone specific user-enrolled second factor.\n */\nclass PhoneMultiFactorInfo extends MultiFactorInfo {\n    /**\n     * Initializes the PhoneMultiFactorInfo object using the server side response.\n     *\n     * @param response - The server side response.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        super(response);\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneInfo);\n    }\n    /**\n     * {@inheritdoc MultiFactorInfo.toJSON}\n     */\n    toJSON() {\n        return Object.assign(super.toJSON(), {\n            phoneNumber: this.phoneNumber,\n        });\n    }\n    /**\n     * Returns the factor ID based on the response provided.\n     *\n     * @param response - The server side response.\n     * @returns The multi-factor ID associated with the provided response. If the response is\n     *     not associated with any known multi-factor ID, null is returned.\n     *\n     * @internal\n     */\n    getFactorId(response) {\n        return (response && response.phoneInfo) ? MultiFactorId.Phone : null;\n    }\n}\nexports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;\n/**\n * The multi-factor related user settings.\n */\nclass MultiFactorSettings {\n    /**\n     * Initializes the MultiFactor object using the server side or JWT format response.\n     *\n     * @param response - The server side response.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        const parsedEnrolledFactors = [];\n        if (!(0, validator_1.isNonNullObject)(response)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');\n        }\n        else if (response.mfaInfo) {\n            response.mfaInfo.forEach((factorResponse) => {\n                const multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);\n                if (multiFactorInfo) {\n                    parsedEnrolledFactors.push(multiFactorInfo);\n                }\n            });\n        }\n        // Make enrolled factors immutable.\n        utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));\n    }\n    /**\n     * Returns a JSON-serializable representation of this multi-factor object.\n     *\n     * @returns A JSON-serializable representation of this multi-factor object.\n     */\n    toJSON() {\n        return {\n            enrolledFactors: this.enrolledFactors.map((info) => info.toJSON()),\n        };\n    }\n}\nexports.MultiFactorSettings = MultiFactorSettings;\n/**\n * Represents a user's metadata.\n */\nclass UserMetadata {\n    /**\n     * @param response - The server side response returned from the getAccountInfo\n     *     endpoint.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        // Creation date should always be available but due to some backend bugs there\n        // were cases in the past where users did not have creation date properly set.\n        // This included legacy Firebase migrating project users and some anonymous users.\n        // These bugs have already been addressed since then.\n        utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));\n        utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));\n        const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;\n        utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns A JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return {\n            lastSignInTime: this.lastSignInTime,\n            creationTime: this.creationTime,\n            lastRefreshTime: this.lastRefreshTime,\n        };\n    }\n}\nexports.UserMetadata = UserMetadata;\n/**\n * Represents a user's info from a third-party identity provider\n * such as Google or Facebook.\n */\nclass UserInfo {\n    /**\n     * @param response - The server side response returned from the `getAccountInfo`\n     *     endpoint.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        // Provider user id and provider id are required.\n        if (!response.rawId || !response.providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');\n        }\n        utils.addReadonlyGetter(this, 'uid', response.rawId);\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\n        utils.addReadonlyGetter(this, 'email', response.email);\n        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n        utils.addReadonlyGetter(this, 'providerId', response.providerId);\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns A JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return {\n            uid: this.uid,\n            displayName: this.displayName,\n            email: this.email,\n            photoURL: this.photoURL,\n            providerId: this.providerId,\n            phoneNumber: this.phoneNumber,\n        };\n    }\n}\nexports.UserInfo = UserInfo;\n/**\n * Represents a user.\n */\nclass UserRecord {\n    /**\n     * @param response - The server side response returned from the getAccountInfo\n     *     endpoint.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        // The Firebase user id is required.\n        if (!response.localId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');\n        }\n        utils.addReadonlyGetter(this, 'uid', response.localId);\n        utils.addReadonlyGetter(this, 'email', response.email);\n        utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);\n        utils.addReadonlyGetter(this, 'displayName', response.displayName);\n        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);\n        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);\n        // If disabled is not provided, the account is enabled by default.\n        utils.addReadonlyGetter(this, 'disabled', response.disabled || false);\n        utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));\n        const providerData = [];\n        for (const entry of (response.providerUserInfo || [])) {\n            providerData.push(new UserInfo(entry));\n        }\n        utils.addReadonlyGetter(this, 'providerData', providerData);\n        // If the password hash is redacted (probably due to missing permissions)\n        // then clear it out, similar to how the salt is returned. (Otherwise, it\n        // *looks* like a b64-encoded hash is present, which is confusing.)\n        if (response.passwordHash === B64_REDACTED) {\n            utils.addReadonlyGetter(this, 'passwordHash', undefined);\n        }\n        else {\n            utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);\n        }\n        utils.addReadonlyGetter(this, 'passwordSalt', response.salt);\n        if (response.customAttributes) {\n            utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));\n        }\n        let validAfterTime = null;\n        // Convert validSince first to UTC milliseconds and then to UTC date string.\n        if (typeof response.validSince !== 'undefined') {\n            validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);\n        }\n        utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);\n        utils.addReadonlyGetter(this, 'tenantId', response.tenantId);\n        const multiFactor = new MultiFactorSettings(response);\n        if (multiFactor.enrolledFactors.length > 0) {\n            utils.addReadonlyGetter(this, 'multiFactor', multiFactor);\n        }\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns A JSON-serializable representation of this object.\n     */\n    toJSON() {\n        const json = {\n            uid: this.uid,\n            email: this.email,\n            emailVerified: this.emailVerified,\n            displayName: this.displayName,\n            photoURL: this.photoURL,\n            phoneNumber: this.phoneNumber,\n            disabled: this.disabled,\n            // Convert metadata to json.\n            metadata: this.metadata.toJSON(),\n            passwordHash: this.passwordHash,\n            passwordSalt: this.passwordSalt,\n            customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),\n            tokensValidAfterTime: this.tokensValidAfterTime,\n            tenantId: this.tenantId,\n        };\n        if (this.multiFactor) {\n            json.multiFactor = this.multiFactor.toJSON();\n        }\n        json.providerData = [];\n        for (const entry of this.providerData) {\n            // Convert each provider data to json.\n            json.providerData.push(entry.toJSON());\n        }\n        return json;\n    }\n}\nexports.UserRecord = UserRecord;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}