{"ast":null,"code":"import { inRange, decoderError, encoderError, isASCIICodePoint, end_of_stream, finished, isASCIIByte, floor } from '../utils';\nimport index, { indexBig5PointerFor, indexCodePointFor } from '../indexes';\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @implements {Decoder}\n */\nexport class Big5Decoder {\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    this.Big5_lead = 0x00;\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n    // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && this.Big5_lead !== 0x00) {\n      this.Big5_lead = 0x00;\n      return decoderError(this.fatal);\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.Big5_lead === 0x00) return finished;\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (this.Big5_lead !== 0x00) {\n      const lead = this.Big5_lead;\n      let pointer = null;\n      this.Big5_lead = 0x00;\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      const offset = bite < 0x7F ? 0x40 : 0x62;\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) pointer = (lead - 0x81) * 157 + (bite - offset);\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n        case 1133:\n          return [0x00CA, 0x0304];\n        case 1135:\n          return [0x00CA, 0x030C];\n        case 1164:\n          return [0x00EA, 0x0304];\n        case 1166:\n          return [0x00EA, 0x030C];\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      const code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5'));\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 6. If code point is null, return error.\n      if (code_point === null) return decoderError(this.fatal);\n\n      // 7. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite)) return bite;\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.Big5_lead = bite;\n      return null;\n    }\n\n    // 6. Return error.\n    return decoderError(this.fatal);\n  }\n}\n\n// 12.1.2 Big5 encoder\n/**\n * @implements {Encoder}\n */\nexport class Big5Encoder {\n  constructor() {\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     */\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point)) return code_point;\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      const pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null) return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      const lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1) return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      const trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      const offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n}","map":{"version":3,"names":["inRange","decoderError","encoderError","isASCIICodePoint","end_of_stream","finished","isASCIIByte","floor","index","indexBig5PointerFor","indexCodePointFor","Big5Decoder","constructor","options","fatal","Big5_lead","handler","stream","bite","lead","pointer","offset","code_point","prepend","Big5Encoder","trail"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/big5.js"],"sourcesContent":["import { inRange, decoderError, encoderError, isASCIICodePoint,\n  end_of_stream, finished, isASCIIByte, floor } from '../utils'\nimport index, { indexBig5PointerFor, indexCodePointFor } from '../indexes'\n\n//\n// 12. Legacy multi-byte Chinese (traditional) encodings\n//\n\n// 12.1 Big5\n\n// 12.1.1 Big5 decoder\n/**\n * @implements {Decoder}\n */\nexport class Big5Decoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    this.Big5_lead = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n  // Big5 lead to 0x00 and return error.\n    if (bite === end_of_stream && this.Big5_lead !== 0x00) {\n      this.Big5_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n    // finished.\n    if (bite === end_of_stream && this.Big5_lead === 0x00)\n      return finished\n\n    // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n    // pointer be null, set Big5 lead to 0x00, and then run these\n    // substeps:\n    if (this.Big5_lead !== 0x00) {\n      const lead = this.Big5_lead\n      let pointer = null\n      this.Big5_lead = 0x00\n\n      // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n      // otherwise.\n      const offset = bite < 0x7F ? 0x40 : 0x62\n\n      // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n      // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n      // (byte − offset).\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n        pointer = (lead - 0x81) * 157 + (bite - offset)\n\n      // 3. If there is a row in the table below whose first column\n      // is pointer, return the two code points listed in its second\n      // column\n      // Pointer | Code points\n      // --------+--------------\n      // 1133    | U+00CA U+0304\n      // 1135    | U+00CA U+030C\n      // 1164    | U+00EA U+0304\n      // 1166    | U+00EA U+030C\n      switch (pointer) {\n      case 1133: return [0x00CA, 0x0304]\n      case 1135: return [0x00CA, 0x030C]\n      case 1164: return [0x00EA, 0x0304]\n      case 1166: return [0x00EA, 0x030C]\n      }\n\n      // 4. Let code point be null if pointer is null and the index\n      // code point for pointer in index Big5 otherwise.\n      const code_point = (pointer === null) ? null :\n        indexCodePointFor(pointer, index('big5'))\n\n      // 5. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 6. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 7. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If byte is an ASCII byte, return a code point whose value\n    // is byte.\n    if (isASCIIByte(bite))\n      return bite\n\n    // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n    // lead to byte and return continue.\n    if (inRange(bite, 0x81, 0xFE)) {\n      this.Big5_lead = bite\n      return null\n    }\n\n    // 6. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n\n// 12.1.2 Big5 encoder\n/**\n * @implements {Encoder}\n */\nexport class Big5Encoder {\n  constructor() {\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     */\n    this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      const pointer = indexBig5PointerFor(code_point)\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point)\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      const lead = floor(pointer / 157) + 0x81\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point)\n\n      // 7. Let trail be pointer % 157.\n      const trail = pointer % 157\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      const offset = trail < 0x3F ? 0x40 : 0x62\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset]\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}