{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.cryptoSignerFromApp = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\nconst credential_internal_1 = require(\"../app/credential-internal\");\nconst api_request_1 = require(\"./api-request\");\nconst validator = require(\"../utils/validator\");\nconst ALGORITHM_RS256 = 'RS256';\n/**\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\n * sign data. Performs all operations locally, and does not make any RPC calls.\n */\nclass ServiceAccountSigner {\n  /**\n   * Creates a new CryptoSigner instance from the given service account credential.\n   *\n   * @param credential - A service account credential.\n   */\n  constructor(credential) {\n    this.credential = credential;\n    this.algorithm = ALGORITHM_RS256;\n    if (!credential) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.'\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  sign(buffer) {\n    const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\n    const sign = crypto.createSign('RSA-SHA256');\n    sign.update(buffer);\n    return Promise.resolve(sign.sign(this.credential.privateKey));\n  }\n  /**\n   * @inheritDoc\n   */\n  getAccountId() {\n    return Promise.resolve(this.credential.clientEmail);\n  }\n}\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\n *\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\n */\nclass IAMSigner {\n  constructor(httpClient, serviceAccountId) {\n    this.algorithm = ALGORITHM_RS256;\n    if (!httpClient) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.'\n      });\n    }\n    if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n        message: 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.'\n      });\n    }\n    this.httpClient = httpClient;\n    this.serviceAccountId = serviceAccountId;\n  }\n  /**\n   * @inheritDoc\n   */\n  sign(buffer) {\n    return this.getAccountId().then(serviceAccount => {\n      const request = {\n        method: 'POST',\n        url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,\n        data: {\n          payload: buffer.toString('base64')\n        }\n      };\n      return this.httpClient.send(request);\n    }).then(response => {\n      // Response from IAM is base64 encoded. Decode it into a buffer and return.\n      return Buffer.from(response.data.signedBlob, 'base64');\n    }).catch(err => {\n      if (err instanceof api_request_1.HttpError) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.SERVER_ERROR,\n          message: err.message,\n          cause: err\n        });\n      }\n      throw err;\n    });\n  }\n  /**\n   * @inheritDoc\n   */\n  getAccountId() {\n    if (validator.isNonEmptyString(this.serviceAccountId)) {\n      return Promise.resolve(this.serviceAccountId);\n    }\n    const request = {\n      method: 'GET',\n      url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n      headers: {\n        'Metadata-Flavor': 'Google'\n      }\n    };\n    const client = new api_request_1.HttpClient();\n    return client.send(request).then(response => {\n      if (!response.text) {\n        throw new CryptoSignerError({\n          code: CryptoSignerErrorCode.INTERNAL_ERROR,\n          message: 'HTTP Response missing payload'\n        });\n      }\n      this.serviceAccountId = response.text;\n      return response.text;\n    }).catch(err => {\n      throw new CryptoSignerError({\n        code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n        message: 'Failed to determine service account. Make sure to initialize ' + 'the SDK with a service account credential. Alternatively specify a service ' + `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`\n      });\n    });\n  }\n}\nexports.IAMSigner = IAMSigner;\n/**\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\n * service account credential, creates a ServiceAccountSigner.\n *\n * @param app - A FirebaseApp instance.\n * @returns A CryptoSigner instance.\n */\nfunction cryptoSignerFromApp(app) {\n  const credential = app.options.credential;\n  if (credential instanceof credential_internal_1.ServiceAccountCredential) {\n    return new ServiceAccountSigner(credential);\n  }\n  return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);\n}\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\n/**\n * CryptoSigner error code structure.\n *\n * @param errorInfo - The error information (code and message).\n * @constructor\n */\nclass CryptoSignerError extends Error {\n  constructor(errorInfo) {\n    super(errorInfo.message);\n    this.errorInfo = errorInfo;\n    /* tslint:disable:max-line-length */\n    // Set the prototype explicitly. See the following link for more details:\n    // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    /* tslint:enable:max-line-length */\n    this.__proto__ = CryptoSignerError.prototype;\n  }\n  /** @returns The error code. */\n  get code() {\n    return this.errorInfo.code;\n  }\n  /** @returns The error message. */\n  get message() {\n    return this.errorInfo.message;\n  }\n  /** @returns The error data. */\n  get cause() {\n    return this.errorInfo.cause;\n  }\n}\nexports.CryptoSignerError = CryptoSignerError;\n/**\n * Crypto Signer error codes and their default messages.\n */\nclass CryptoSignerErrorCode {}\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;\nCryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\nCryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\nCryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\nCryptoSignerErrorCode.SERVER_ERROR = 'server-error';","map":{"version":3,"names":["Object","defineProperty","exports","value","CryptoSignerErrorCode","CryptoSignerError","cryptoSignerFromApp","IAMSigner","ServiceAccountSigner","credential_internal_1","require","api_request_1","validator","ALGORITHM_RS256","constructor","credential","algorithm","code","INVALID_CREDENTIAL","message","sign","buffer","crypto","createSign","update","Promise","resolve","privateKey","getAccountId","clientEmail","httpClient","serviceAccountId","INVALID_ARGUMENT","isNonEmptyString","then","serviceAccount","request","method","url","data","payload","toString","send","response","Buffer","from","signedBlob","catch","err","HttpError","SERVER_ERROR","cause","headers","client","HttpClient","text","INTERNAL_ERROR","app","options","ServiceAccountCredential","AuthorizedHttpClient","Error","errorInfo","__proto__","prototype"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/utils/crypto-signer.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.cryptoSignerFromApp = exports.IAMSigner = exports.ServiceAccountSigner = void 0;\nconst credential_internal_1 = require(\"../app/credential-internal\");\nconst api_request_1 = require(\"./api-request\");\nconst validator = require(\"../utils/validator\");\nconst ALGORITHM_RS256 = 'RS256';\n/**\n * A CryptoSigner implementation that uses an explicitly specified service account private key to\n * sign data. Performs all operations locally, and does not make any RPC calls.\n */\nclass ServiceAccountSigner {\n    /**\n     * Creates a new CryptoSigner instance from the given service account credential.\n     *\n     * @param credential - A service account credential.\n     */\n    constructor(credential) {\n        this.credential = credential;\n        this.algorithm = ALGORITHM_RS256;\n        if (!credential) {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n                message: 'INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner.',\n            });\n        }\n    }\n    /**\n     * @inheritDoc\n     */\n    sign(buffer) {\n        const crypto = require('crypto'); // eslint-disable-line @typescript-eslint/no-var-requires\n        const sign = crypto.createSign('RSA-SHA256');\n        sign.update(buffer);\n        return Promise.resolve(sign.sign(this.credential.privateKey));\n    }\n    /**\n     * @inheritDoc\n     */\n    getAccountId() {\n        return Promise.resolve(this.credential.clientEmail);\n    }\n}\nexports.ServiceAccountSigner = ServiceAccountSigner;\n/**\n * A CryptoSigner implementation that uses the remote IAM service to sign data. If initialized without\n * a service account ID, attempts to discover a service account ID by consulting the local Metadata\n * service. This will succeed in managed environments like Google Cloud Functions and App Engine.\n *\n * @see https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts/signBlob\n * @see https://cloud.google.com/compute/docs/storing-retrieving-metadata\n */\nclass IAMSigner {\n    constructor(httpClient, serviceAccountId) {\n        this.algorithm = ALGORITHM_RS256;\n        if (!httpClient) {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n                message: 'INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner.',\n            });\n        }\n        if (typeof serviceAccountId !== 'undefined' && !validator.isNonEmptyString(serviceAccountId)) {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_ARGUMENT,\n                message: 'INTERNAL ASSERT: Service account ID must be undefined or a non-empty string.',\n            });\n        }\n        this.httpClient = httpClient;\n        this.serviceAccountId = serviceAccountId;\n    }\n    /**\n     * @inheritDoc\n     */\n    sign(buffer) {\n        return this.getAccountId().then((serviceAccount) => {\n            const request = {\n                method: 'POST',\n                url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,\n                data: { payload: buffer.toString('base64') },\n            };\n            return this.httpClient.send(request);\n        }).then((response) => {\n            // Response from IAM is base64 encoded. Decode it into a buffer and return.\n            return Buffer.from(response.data.signedBlob, 'base64');\n        }).catch((err) => {\n            if (err instanceof api_request_1.HttpError) {\n                throw new CryptoSignerError({\n                    code: CryptoSignerErrorCode.SERVER_ERROR,\n                    message: err.message,\n                    cause: err\n                });\n            }\n            throw err;\n        });\n    }\n    /**\n     * @inheritDoc\n     */\n    getAccountId() {\n        if (validator.isNonEmptyString(this.serviceAccountId)) {\n            return Promise.resolve(this.serviceAccountId);\n        }\n        const request = {\n            method: 'GET',\n            url: 'http://metadata/computeMetadata/v1/instance/service-accounts/default/email',\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n        };\n        const client = new api_request_1.HttpClient();\n        return client.send(request).then((response) => {\n            if (!response.text) {\n                throw new CryptoSignerError({\n                    code: CryptoSignerErrorCode.INTERNAL_ERROR,\n                    message: 'HTTP Response missing payload',\n                });\n            }\n            this.serviceAccountId = response.text;\n            return response.text;\n        }).catch((err) => {\n            throw new CryptoSignerError({\n                code: CryptoSignerErrorCode.INVALID_CREDENTIAL,\n                message: 'Failed to determine service account. Make sure to initialize ' +\n                    'the SDK with a service account credential. Alternatively specify a service ' +\n                    `account with iam.serviceAccounts.signBlob permission. Original error: ${err}`,\n            });\n        });\n    }\n}\nexports.IAMSigner = IAMSigner;\n/**\n * Creates a new CryptoSigner instance for the given app. If the app has been initialized with a\n * service account credential, creates a ServiceAccountSigner.\n *\n * @param app - A FirebaseApp instance.\n * @returns A CryptoSigner instance.\n */\nfunction cryptoSignerFromApp(app) {\n    const credential = app.options.credential;\n    if (credential instanceof credential_internal_1.ServiceAccountCredential) {\n        return new ServiceAccountSigner(credential);\n    }\n    return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);\n}\nexports.cryptoSignerFromApp = cryptoSignerFromApp;\n/**\n * CryptoSigner error code structure.\n *\n * @param errorInfo - The error information (code and message).\n * @constructor\n */\nclass CryptoSignerError extends Error {\n    constructor(errorInfo) {\n        super(errorInfo.message);\n        this.errorInfo = errorInfo;\n        /* tslint:disable:max-line-length */\n        // Set the prototype explicitly. See the following link for more details:\n        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        /* tslint:enable:max-line-length */\n        this.__proto__ = CryptoSignerError.prototype;\n    }\n    /** @returns The error code. */\n    get code() {\n        return this.errorInfo.code;\n    }\n    /** @returns The error message. */\n    get message() {\n        return this.errorInfo.message;\n    }\n    /** @returns The error data. */\n    get cause() {\n        return this.errorInfo.cause;\n    }\n}\nexports.CryptoSignerError = CryptoSignerError;\n/**\n * Crypto Signer error codes and their default messages.\n */\nclass CryptoSignerErrorCode {\n}\nexports.CryptoSignerErrorCode = CryptoSignerErrorCode;\nCryptoSignerErrorCode.INVALID_ARGUMENT = 'invalid-argument';\nCryptoSignerErrorCode.INTERNAL_ERROR = 'internal-error';\nCryptoSignerErrorCode.INVALID_CREDENTIAL = 'invalid-credential';\nCryptoSignerErrorCode.SERVER_ERROR = 'server-error';\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}