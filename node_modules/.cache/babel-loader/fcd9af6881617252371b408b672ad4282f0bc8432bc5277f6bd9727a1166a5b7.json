{"ast":null,"code":"/*! firebase-admin v11.9.0 */\n\"use strict\";\n\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TenantManager = exports.TenantAwareAuth = void 0;\nconst validator = require(\"../utils/validator\");\nconst utils = require(\"../utils/index\");\nconst error_1 = require(\"../utils/error\");\nconst base_auth_1 = require(\"./base-auth\");\nconst tenant_1 = require(\"./tenant\");\nconst auth_api_request_1 = require(\"./auth-api-request\");\n/**\n * Tenant-aware `Auth` interface used for managing users, configuring SAML/OIDC providers,\n * generating email links for password reset, email verification, etc for specific tenants.\n *\n * Multi-tenancy support requires Google Cloud's Identity Platform\n * (GCIP). To learn more about GCIP, including pricing and features,\n * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n *\n * Each tenant contains its own identity providers, settings and sets of users.\n * Using `TenantAwareAuth`, users for a specific tenant and corresponding OIDC/SAML\n * configurations can also be managed, ID tokens for users signed in to a specific tenant\n * can be verified, and email action links can also be generated for users belonging to the\n * tenant.\n *\n * `TenantAwareAuth` instances for a specific `tenantId` can be instantiated by calling\n * {@link TenantManager.authForTenant}.\n */\nclass TenantAwareAuth extends base_auth_1.BaseAuth {\n  /**\n   * The TenantAwareAuth class constructor.\n   *\n   * @param app - The app that created this tenant.\n   * @param tenantId - The corresponding tenant ID.\n   * @constructor\n   * @internal\n   */\n  constructor(app, tenantId) {\n    super(app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), (0, base_auth_1.createFirebaseTokenGenerator)(app, tenantId));\n    utils.addReadonlyGetter(this, 'tenantId', tenantId);\n  }\n  /**\n   * {@inheritdoc BaseAuth.verifyIdToken}\n   */\n  verifyIdToken(idToken) {\n    let checkRevoked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return super.verifyIdToken(idToken, checkRevoked).then(decodedClaims => {\n      // Validate tenant ID.\n      if (decodedClaims.firebase.tenant !== this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n      return decodedClaims;\n    });\n  }\n  /**\n   * {@inheritdoc BaseAuth.createSessionCookie}\n   */\n  createSessionCookie(idToken, sessionCookieOptions) {\n    // Validate arguments before processing.\n    if (!validator.isNonEmptyString(idToken)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n    }\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n    // This will verify the ID token and then match the tenant ID before creating the session cookie.\n    return this.verifyIdToken(idToken).then(() => {\n      return super.createSessionCookie(idToken, sessionCookieOptions);\n    });\n  }\n  /**\n   * {@inheritdoc BaseAuth.verifySessionCookie}\n   */\n  verifySessionCookie(sessionCookie) {\n    let checkRevoked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return super.verifySessionCookie(sessionCookie, checkRevoked).then(decodedClaims => {\n      if (decodedClaims.firebase.tenant !== this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n      return decodedClaims;\n    });\n  }\n}\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\n * Defines the tenant manager used to help manage tenant related operations.\n * This includes:\n * <ul>\n * <li>The ability to create, update, list, get and delete tenants for the underlying\n *     project.</li>\n * <li>Getting a `TenantAwareAuth` instance for running Auth related operations\n *     (user management, provider configuration management, token verification,\n *     email link generation, etc) in the context of a specified tenant.</li>\n * </ul>\n */\nclass TenantManager {\n  /**\n   * Initializes a TenantManager instance for a specified FirebaseApp.\n   *\n   * @param app - The app for this TenantManager instance.\n   *\n   * @constructor\n   * @internal\n   */\n  constructor(app) {\n    this.app = app;\n    this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);\n    this.tenantsMap = {};\n  }\n  /**\n   * Returns a `TenantAwareAuth` instance bound to the given tenant ID.\n   *\n   * @param tenantId - The tenant ID whose `TenantAwareAuth` instance is to be returned.\n   *\n   * @returns The `TenantAwareAuth` instance corresponding to this tenant identifier.\n   */\n  authForTenant(tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n    }\n    if (typeof this.tenantsMap[tenantId] === 'undefined') {\n      this.tenantsMap[tenantId] = new TenantAwareAuth(this.app, tenantId);\n    }\n    return this.tenantsMap[tenantId];\n  }\n  /**\n   * Gets the tenant configuration for the tenant corresponding to a given `tenantId`.\n   *\n   * @param tenantId - The tenant identifier corresponding to the tenant whose data to fetch.\n   *\n   * @returns A promise fulfilled with the tenant configuration to the provided `tenantId`.\n   */\n  getTenant(tenantId) {\n    return this.authRequestHandler.getTenant(tenantId).then(response => {\n      return new tenant_1.Tenant(response);\n    });\n  }\n  /**\n   * Retrieves a list of tenants (single batch only) with a size of `maxResults`\n   * starting from the offset as specified by `pageToken`. This is used to\n   * retrieve all the tenants of a specified project in batches.\n   *\n   * @param maxResults - The page size, 1000 if undefined. This is also\n   *   the maximum allowed limit.\n   * @param pageToken - The next page token. If not specified, returns\n   *   tenants starting without any offset.\n   *\n   * @returns A promise that resolves with\n   *   a batch of downloaded tenants and the next page token.\n   */\n  listTenants(maxResults, pageToken) {\n    return this.authRequestHandler.listTenants(maxResults, pageToken).then(response => {\n      // List of tenants to return.\n      const tenants = [];\n      // Convert each user response to a Tenant.\n      response.tenants.forEach(tenantResponse => {\n        tenants.push(new tenant_1.Tenant(tenantResponse));\n      });\n      // Return list of tenants and the next page token if available.\n      const result = {\n        tenants,\n        pageToken: response.nextPageToken\n      };\n      // Delete result.pageToken if undefined.\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n      return result;\n    });\n  }\n  /**\n   * Deletes an existing tenant.\n   *\n   * @param tenantId - The `tenantId` corresponding to the tenant to delete.\n   *\n   * @returns An empty promise fulfilled once the tenant has been deleted.\n   */\n  deleteTenant(tenantId) {\n    return this.authRequestHandler.deleteTenant(tenantId);\n  }\n  /**\n   * Creates a new tenant.\n   * When creating new tenants, tenants that use separate billing and quota will require their\n   * own project and must be defined as `full_service`.\n   *\n   * @param tenantOptions - The properties to set on the new tenant configuration to be created.\n   *\n   * @returns A promise fulfilled with the tenant configuration corresponding to the newly\n   *   created tenant.\n   */\n  createTenant(tenantOptions) {\n    return this.authRequestHandler.createTenant(tenantOptions).then(response => {\n      return new tenant_1.Tenant(response);\n    });\n  }\n  /**\n   * Updates an existing tenant configuration.\n   *\n   * @param tenantId - The `tenantId` corresponding to the tenant to delete.\n   * @param tenantOptions - The properties to update on the provided tenant.\n   *\n   * @returns A promise fulfilled with the update tenant data.\n   */\n  updateTenant(tenantId, tenantOptions) {\n    return this.authRequestHandler.updateTenant(tenantId, tenantOptions).then(response => {\n      return new tenant_1.Tenant(response);\n    });\n  }\n}\nexports.TenantManager = TenantManager;","map":{"version":3,"names":["Object","defineProperty","exports","value","TenantManager","TenantAwareAuth","validator","require","utils","error_1","base_auth_1","tenant_1","auth_api_request_1","BaseAuth","constructor","app","tenantId","TenantAwareAuthRequestHandler","createFirebaseTokenGenerator","addReadonlyGetter","verifyIdToken","idToken","checkRevoked","arguments","length","undefined","then","decodedClaims","firebase","tenant","FirebaseAuthError","AuthClientErrorCode","MISMATCHING_TENANT_ID","createSessionCookie","sessionCookieOptions","isNonEmptyString","Promise","reject","INVALID_ID_TOKEN","isNonNullObject","isNumber","expiresIn","INVALID_SESSION_COOKIE_DURATION","verifySessionCookie","sessionCookie","authRequestHandler","AuthRequestHandler","tenantsMap","authForTenant","INVALID_TENANT_ID","getTenant","response","Tenant","listTenants","maxResults","pageToken","tenants","forEach","tenantResponse","push","result","nextPageToken","deleteTenant","createTenant","tenantOptions","updateTenant"],"sources":["D:/Coding/React/taskmybusiness/node_modules/firebase-admin/lib/auth/tenant-manager.js"],"sourcesContent":["/*! firebase-admin v11.9.0 */\n\"use strict\";\n/*!\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TenantManager = exports.TenantAwareAuth = void 0;\nconst validator = require(\"../utils/validator\");\nconst utils = require(\"../utils/index\");\nconst error_1 = require(\"../utils/error\");\nconst base_auth_1 = require(\"./base-auth\");\nconst tenant_1 = require(\"./tenant\");\nconst auth_api_request_1 = require(\"./auth-api-request\");\n/**\n * Tenant-aware `Auth` interface used for managing users, configuring SAML/OIDC providers,\n * generating email links for password reset, email verification, etc for specific tenants.\n *\n * Multi-tenancy support requires Google Cloud's Identity Platform\n * (GCIP). To learn more about GCIP, including pricing and features,\n * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.\n *\n * Each tenant contains its own identity providers, settings and sets of users.\n * Using `TenantAwareAuth`, users for a specific tenant and corresponding OIDC/SAML\n * configurations can also be managed, ID tokens for users signed in to a specific tenant\n * can be verified, and email action links can also be generated for users belonging to the\n * tenant.\n *\n * `TenantAwareAuth` instances for a specific `tenantId` can be instantiated by calling\n * {@link TenantManager.authForTenant}.\n */\nclass TenantAwareAuth extends base_auth_1.BaseAuth {\n    /**\n     * The TenantAwareAuth class constructor.\n     *\n     * @param app - The app that created this tenant.\n     * @param tenantId - The corresponding tenant ID.\n     * @constructor\n     * @internal\n     */\n    constructor(app, tenantId) {\n        super(app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), (0, base_auth_1.createFirebaseTokenGenerator)(app, tenantId));\n        utils.addReadonlyGetter(this, 'tenantId', tenantId);\n    }\n    /**\n     * {@inheritdoc BaseAuth.verifyIdToken}\n     */\n    verifyIdToken(idToken, checkRevoked = false) {\n        return super.verifyIdToken(idToken, checkRevoked)\n            .then((decodedClaims) => {\n            // Validate tenant ID.\n            if (decodedClaims.firebase.tenant !== this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n            }\n            return decodedClaims;\n        });\n    }\n    /**\n     * {@inheritdoc BaseAuth.createSessionCookie}\n     */\n    createSessionCookie(idToken, sessionCookieOptions) {\n        // Validate arguments before processing.\n        if (!validator.isNonEmptyString(idToken)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n        }\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        // This will verify the ID token and then match the tenant ID before creating the session cookie.\n        return this.verifyIdToken(idToken)\n            .then(() => {\n            return super.createSessionCookie(idToken, sessionCookieOptions);\n        });\n    }\n    /**\n     * {@inheritdoc BaseAuth.verifySessionCookie}\n     */\n    verifySessionCookie(sessionCookie, checkRevoked = false) {\n        return super.verifySessionCookie(sessionCookie, checkRevoked)\n            .then((decodedClaims) => {\n            if (decodedClaims.firebase.tenant !== this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n            }\n            return decodedClaims;\n        });\n    }\n}\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\n * Defines the tenant manager used to help manage tenant related operations.\n * This includes:\n * <ul>\n * <li>The ability to create, update, list, get and delete tenants for the underlying\n *     project.</li>\n * <li>Getting a `TenantAwareAuth` instance for running Auth related operations\n *     (user management, provider configuration management, token verification,\n *     email link generation, etc) in the context of a specified tenant.</li>\n * </ul>\n */\nclass TenantManager {\n    /**\n     * Initializes a TenantManager instance for a specified FirebaseApp.\n     *\n     * @param app - The app for this TenantManager instance.\n     *\n     * @constructor\n     * @internal\n     */\n    constructor(app) {\n        this.app = app;\n        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);\n        this.tenantsMap = {};\n    }\n    /**\n     * Returns a `TenantAwareAuth` instance bound to the given tenant ID.\n     *\n     * @param tenantId - The tenant ID whose `TenantAwareAuth` instance is to be returned.\n     *\n     * @returns The `TenantAwareAuth` instance corresponding to this tenant identifier.\n     */\n    authForTenant(tenantId) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n        }\n        if (typeof this.tenantsMap[tenantId] === 'undefined') {\n            this.tenantsMap[tenantId] = new TenantAwareAuth(this.app, tenantId);\n        }\n        return this.tenantsMap[tenantId];\n    }\n    /**\n     * Gets the tenant configuration for the tenant corresponding to a given `tenantId`.\n     *\n     * @param tenantId - The tenant identifier corresponding to the tenant whose data to fetch.\n     *\n     * @returns A promise fulfilled with the tenant configuration to the provided `tenantId`.\n     */\n    getTenant(tenantId) {\n        return this.authRequestHandler.getTenant(tenantId)\n            .then((response) => {\n            return new tenant_1.Tenant(response);\n        });\n    }\n    /**\n     * Retrieves a list of tenants (single batch only) with a size of `maxResults`\n     * starting from the offset as specified by `pageToken`. This is used to\n     * retrieve all the tenants of a specified project in batches.\n     *\n     * @param maxResults - The page size, 1000 if undefined. This is also\n     *   the maximum allowed limit.\n     * @param pageToken - The next page token. If not specified, returns\n     *   tenants starting without any offset.\n     *\n     * @returns A promise that resolves with\n     *   a batch of downloaded tenants and the next page token.\n     */\n    listTenants(maxResults, pageToken) {\n        return this.authRequestHandler.listTenants(maxResults, pageToken)\n            .then((response) => {\n            // List of tenants to return.\n            const tenants = [];\n            // Convert each user response to a Tenant.\n            response.tenants.forEach((tenantResponse) => {\n                tenants.push(new tenant_1.Tenant(tenantResponse));\n            });\n            // Return list of tenants and the next page token if available.\n            const result = {\n                tenants,\n                pageToken: response.nextPageToken,\n            };\n            // Delete result.pageToken if undefined.\n            if (typeof result.pageToken === 'undefined') {\n                delete result.pageToken;\n            }\n            return result;\n        });\n    }\n    /**\n     * Deletes an existing tenant.\n     *\n     * @param tenantId - The `tenantId` corresponding to the tenant to delete.\n     *\n     * @returns An empty promise fulfilled once the tenant has been deleted.\n     */\n    deleteTenant(tenantId) {\n        return this.authRequestHandler.deleteTenant(tenantId);\n    }\n    /**\n     * Creates a new tenant.\n     * When creating new tenants, tenants that use separate billing and quota will require their\n     * own project and must be defined as `full_service`.\n     *\n     * @param tenantOptions - The properties to set on the new tenant configuration to be created.\n     *\n     * @returns A promise fulfilled with the tenant configuration corresponding to the newly\n     *   created tenant.\n     */\n    createTenant(tenantOptions) {\n        return this.authRequestHandler.createTenant(tenantOptions)\n            .then((response) => {\n            return new tenant_1.Tenant(response);\n        });\n    }\n    /**\n     * Updates an existing tenant configuration.\n     *\n     * @param tenantId - The `tenantId` corresponding to the tenant to delete.\n     * @param tenantOptions - The properties to update on the provided tenant.\n     *\n     * @returns A promise fulfilled with the update tenant data.\n     */\n    updateTenant(tenantId, tenantOptions) {\n        return this.authRequestHandler.updateTenant(tenantId, tenantOptions)\n            .then((response) => {\n            return new tenant_1.Tenant(response);\n        });\n    }\n}\nexports.TenantManager = TenantManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}