{"ast":null,"code":"import { inRange, decoderError, encoderError, floor, isASCIICodePoint, isASCIIByte, end_of_stream, finished } from '../utils';\nimport index, { indexCodePointFor, indexShiftJISPointerFor } from '../indexes';\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nexport class ShiftJISDecoder {\n  constructor(options) {\n    const {\n      fatal\n    } = options;\n    this.fatal = fatal;\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    this.Shift_JIS_lead = 0x00;\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n    // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n    // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && this.Shift_JIS_lead !== 0x00) {\n      this.Shift_JIS_lead = 0x00;\n      return decoderError(this.fatal);\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && this.Shift_JIS_lead === 0x00) return finished;\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (this.Shift_JIS_lead !== 0x00) {\n      var lead = this.Shift_JIS_lead;\n      var pointer = null;\n      this.Shift_JIS_lead = 0x00;\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = bite < 0x7F ? 0x40 : 0x41;\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = lead < 0xA0 ? 0x81 : 0xC1;\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n      // 188 + byte − offset.\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) pointer = (lead - lead_offset) * 188 + bite - offset;\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000 − 8836 + pointer.\n      if (inRange(pointer, 8836, 10715)) return 0xE000 - 8836 + pointer;\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208'));\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite)) stream.prepend(bite);\n\n      // 7. If code point is null, return error.\n      if (code_point === null) return decoderError(this.fatal);\n\n      // 8. Return a code point whose value is code point.\n      return code_point;\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80) return bite;\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61 − 0xA1 + byte.\n    if (inRange(bite, 0xA1, 0xDF)) return 0xFF61 - 0xA1 + bite;\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n      this.Shift_JIS_lead = bite;\n      return null;\n    }\n\n    // 7. Return error.\n    return decoderError(this.fatal);\n  }\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nexport class ShiftJISEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream) return finished;\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point;\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00A5) return 0x5C;\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203E) return 0x7E;\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point − 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xFF61, 0xFF9F)) return code_point - 0xFF61 + 0xA1;\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212) code_point = 0xFF0D;\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point);\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null) return encoderError(code_point);\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188);\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = lead < 0x1F ? 0x81 : 0xC1;\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188;\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = trail < 0x3F ? 0x40 : 0x41;\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset];\n  }\n}","map":{"version":3,"names":["inRange","decoderError","encoderError","floor","isASCIICodePoint","isASCIIByte","end_of_stream","finished","index","indexCodePointFor","indexShiftJISPointerFor","ShiftJISDecoder","constructor","options","fatal","Shift_JIS_lead","handler","stream","bite","lead","pointer","offset","lead_offset","code_point","prepend","ShiftJISEncoder","trail"],"sources":["D:/Coding/React/taskmybusiness/node_modules/text-decoding/src/implementations/shift-jis.js"],"sourcesContent":["import { inRange, decoderError, encoderError, floor, isASCIICodePoint, isASCIIByte,\n  end_of_stream, finished } from '../utils'\nimport index, { indexCodePointFor, indexShiftJISPointerFor } from '../indexes'\n\n\n// 13.3 Shift_JIS\n\n// 13.3.1 Shift_JIS decoder\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nexport class ShiftJISDecoder {\n  constructor(options) {\n    const { fatal } = options\n    this.fatal = fatal\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    this.Shift_JIS_lead = 0x00\n  }\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   */\n  handler(stream, bite) {\n  // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n  // set Shift_JIS lead to 0x00 and return error.\n    if (bite === end_of_stream && this.Shift_JIS_lead !== 0x00) {\n      this.Shift_JIS_lead = 0x00\n      return decoderError(this.fatal)\n    }\n\n    // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n    // return finished.\n    if (bite === end_of_stream && this.Shift_JIS_lead === 0x00)\n      return finished\n\n    // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n    // let pointer be null, set Shift_JIS lead to 0x00, and then run\n    // these substeps:\n    if (this.Shift_JIS_lead !== 0x00) {\n      var lead = this.Shift_JIS_lead\n      var pointer = null\n      this.Shift_JIS_lead = 0x00\n\n      // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n      // otherwise.\n      var offset = (bite < 0x7F) ? 0x40 : 0x41\n\n      // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1\n\n      // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n      // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n      // 188 + byte − offset.\n      if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n        pointer = (lead - lead_offset) * 188 + bite - offset\n\n      // 4. If pointer is in the range 8836 to 10715, inclusive,\n      // return a code point whose value is 0xE000 − 8836 + pointer.\n      if (inRange(pointer, 8836, 10715))\n        return 0xE000 - 8836 + pointer\n\n      // 5. Let code point be null, if pointer is null, and the\n      // index code point for pointer in index jis0208 otherwise.\n      var code_point = (pointer === null) ? null :\n        indexCodePointFor(pointer, index('jis0208'))\n\n      // 6. If code point is null and byte is an ASCII byte, prepend\n      // byte to stream.\n      if (code_point === null && isASCIIByte(bite))\n        stream.prepend(bite)\n\n      // 7. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(this.fatal)\n\n      // 8. Return a code point whose value is code point.\n      return code_point\n    }\n\n    // 4. If byte is an ASCII byte or 0x80, return a code point\n    // whose value is byte.\n    if (isASCIIByte(bite) || bite === 0x80)\n      return bite\n\n    // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n    // code point whose value is 0xFF61 − 0xA1 + byte.\n    if (inRange(bite, 0xA1, 0xDF))\n      return 0xFF61 - 0xA1 + bite\n\n    // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n    // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n    // continue.\n    if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n      this.Shift_JIS_lead = bite\n      return null\n    }\n\n    // 7. Return error.\n    return decoderError(this.fatal)\n  }\n}\n\n// 13.3.2 Shift_JIS encoder\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nexport class ShiftJISEncoder {\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   */\n  handler(stream, code_point) {\n  // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished\n\n    // 2. If code point is an ASCII code point or U+0080, return a\n    // byte whose value is code point.\n    if (isASCIICodePoint(code_point) || code_point === 0x0080)\n      return code_point\n\n    // 3. If code point is U+00A5, return byte 0x5C.\n    if (code_point === 0x00A5)\n      return 0x5C\n\n    // 4. If code point is U+203E, return byte 0x7E.\n    if (code_point === 0x203E)\n      return 0x7E\n\n    // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n    // return a byte whose value is code point − 0xFF61 + 0xA1.\n    if (inRange(code_point, 0xFF61, 0xFF9F))\n      return code_point - 0xFF61 + 0xA1\n\n    // 6. If code point is U+2212, set it to U+FF0D.\n    if (code_point === 0x2212)\n      code_point = 0xFF0D\n\n    // 7. Let pointer be the index Shift_JIS pointer for code point.\n    var pointer = indexShiftJISPointerFor(code_point)\n\n    // 8. If pointer is null, return error with code point.\n    if (pointer === null)\n      return encoderError(code_point)\n\n    // 9. Let lead be floor(pointer / 188).\n    var lead = floor(pointer / 188)\n\n    // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n    // 0xC1 otherwise.\n    var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1\n\n    // 11. Let trail be pointer % 188.\n    var trail = pointer % 188\n\n    // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n    // otherwise.\n    var offset = (trail < 0x3F) ? 0x40 : 0x41\n\n    // 13. Return two bytes whose values are lead + lead offset and\n    // trail + offset.\n    return [lead + lead_offset, trail + offset]\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}