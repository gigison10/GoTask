{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asyncMemoizer = void 0;\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\nvar events_1 = require(\"events\");\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nvar freeze_1 = require(\"./freeze\");\nvar sync_1 = require(\"./sync\");\nfunction asyncMemoizer(options) {\n  var cache = new lru_cache_1.default(options);\n  var load = options.load;\n  var hash = options.hash;\n  var bypass = options.bypass;\n  var itemMaxAge = options.itemMaxAge;\n  var freeze = options.freeze;\n  var clone = options.clone;\n  var queueMaxAge = options.queueMaxAge || 1000;\n  var loading = new Map();\n  var emitter = new events_1.EventEmitter();\n  var memoizerMethods = Object.assign({\n    del: del,\n    reset: function () {\n      return cache.reset();\n    },\n    keys: cache.keys.bind(cache),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n  if (options.disable) {\n    return Object.assign(load, memoizerMethods);\n  }\n  function del() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var key = hash.apply(void 0, __spread(args));\n    cache.del(key);\n  }\n  function add(key, parameters, result) {\n    if (freeze) {\n      result.forEach(freeze_1.deepFreeze);\n    }\n    if (itemMaxAge) {\n      cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n    } else {\n      cache.set(key, result);\n    }\n  }\n  function runCallbacks(callbacks, args) {\n    var e_1, _a;\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value;\n        // Simulate async call when returning from cache\n        // and yield between callback resolution\n        if (clone) {\n          setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n        } else {\n          setImmediate.apply(void 0, __spread([callback], args));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n  function emit(event) {\n    var parameters = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      parameters[_i - 1] = arguments[_i];\n    }\n    emitter.emit.apply(emitter, __spread([event], parameters));\n  }\n  function memoizedFunction() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var parameters = args.slice(0, -1);\n    var callback = args.slice(-1).pop();\n    var key;\n    if (bypass && bypass.apply(void 0, __spread(parameters))) {\n      emit.apply(void 0, __spread(['miss'], parameters));\n      return load.apply(void 0, __spread(args));\n    }\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash.apply(void 0, __spread(parameters));\n    }\n    var fromCache = cache.get(key);\n    if (fromCache) {\n      emit.apply(void 0, __spread(['hit'], parameters));\n      // found, invoke callback\n      return runCallbacks([callback], [null].concat(fromCache));\n    }\n    var pendingLoad = loading.get(key);\n    if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n      // request already in progress, queue and return\n      pendingLoad.queue.push(callback);\n      emit.apply(void 0, __spread(['queue'], parameters));\n      return;\n    }\n    emit.apply(void 0, __spread(['miss'], parameters));\n    var started = Date.now();\n    // no pending request or not resolved before expiration\n    // create a new queue and invoke load\n    var queue = [callback];\n    loading.set(key, {\n      queue: queue,\n      expiresAt: started + queueMaxAge\n    });\n    var loadHandler = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var err = args[0];\n      if (!err) {\n        add(key, parameters, args.slice(1));\n      }\n      // this can potentially delete a different queue than `queue` if\n      // this callback was called after expiration.\n      // that will only cause a new call to be performed and a new queue to be\n      // created\n      loading.delete(key);\n      emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n      runCallbacks(queue, args);\n    };\n    load.apply(void 0, __spread(parameters, [loadHandler]));\n  }\n  ;\n  return Object.assign(memoizedFunction, memoizerMethods);\n}\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;","map":{"version":3,"names":["lru_cache_1","__importDefault","require","events_1","lodash_clonedeep_1","freeze_1","sync_1","asyncMemoizer","options","cache","default","load","hash","bypass","itemMaxAge","freeze","clone","queueMaxAge","loading","Map","emitter","EventEmitter","memoizerMethods","Object","assign","del","reset","keys","bind","on","once","disable","args","_i","arguments","length","key","apply","__spread","add","parameters","result","forEach","deepFreeze","set","concat","runCallbacks","callbacks","callbacks_1","__values","callbacks_1_1","next","done","callback","value","setImmediate","map","emit","event","memoizedFunction","slice","pop","fromCache","get","pendingLoad","expiresAt","Date","now","queue","push","started","loadHandler","err","delete","exports","sync","syncMemoizer"],"sources":["../src/async.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}